{"version":3,"sources":["./worm_debug.c","../ncurses/./base/lib_addch.c","../ncurses/./base/lib_clreol.c","../ncurses/./base/lib_color.c","../ncurses/./base/lib_echo.c","../ncurses/./base/lib_endwin.c","../ncurses/./base/lib_getch.c","../ncurses/./base/lib_getstr.c","../ncurses/./base/lib_initscr.c","../ncurses/./base/lib_move.c","../ncurses/./tty/lib_mvcur.c","../ncurses/./base/lib_newterm.c","../ncurses/./base/lib_nl.c","../ncurses/./base/lib_refresh.c","../ncurses/./base/lib_scroll.c","../ncurses/./base/lib_set_term.c","../ncurses/./base/lib_slk.c","../ncurses/./base/lib_slkrefr.c","../ncurses/./base/lib_touch.c","../ncurses/./trace/lib_tracedmp.c","../ncurses/./tty/lib_tstp.c","../ncurses/./base/lib_ungetch.c","../ncurses/./tty/lib_vidattr.c","../ncurses/./base/lib_window.c","../ncurses/./tty/tty_update.c","../ncurses/./base/lib_dft_fgbg.c","../ncurses/./base/resizeterm.c","../ncurses/./base/use_window.c","../ncurses/./base/wresize.c","../ncurses/./tinfo/comp_error.c","../ncurses/./tinfo/doalloc.c","../ncurses/./tinfo/getenv_num.c","../ncurses/./tinfo/lib_acs.c","../ncurses/./tinfo/lib_baudrate.c","../ncurses/./tinfo/lib_cur_term.c","../ncurses/./tinfo/lib_data.c","../ncurses/./tinfo/lib_has_cap.c","../ncurses/./tinfo/lib_kernel.c","../ncurses/./tinfo/lib_napms.c","../ncurses/./tinfo/lib_options.c","../ncurses/./tinfo/lib_raw.c","../ncurses/./tinfo/lib_setup.c","../ncurses/./tinfo/lib_termname.c","../ncurses/./tinfo/lib_ti.c","../ncurses/./tinfo/lib_tparm.c","../ncurses/./tinfo/lib_tputs.c","../ncurses/./trace/lib_trace.c","../ncurses/./trace/lib_traceatr.c","../ncurses/./trace/lib_tracebits.c","../ncurses/./trace/lib_tracechr.c","../ncurses/./tinfo/lib_ttyflags.c","../ncurses/./tty/lib_twait.c","../ncurses/./tinfo/name_match.c","../ncurses/./tinfo/obsolete.c","../ncurses/./tinfo/read_entry.c","../ncurses/./tinfo/strings.c","../ncurses/./trace/trace_buf.c","../ncurses/unctrl.c","../ncurses/./trace/visbuf.c","../ncurses/./tty/hardscroll.c","../ncurses/./tty/hashmap.c","../ncurses/./base/lib_addstr.c","../ncurses/./base/lib_beep.c","../ncurses/./base/lib_clearok.c","../ncurses/./base/lib_hline.c","../ncurses/./base/lib_newwin.c","../ncurses/./base/lib_printw.c","../ncurses/./base/lib_slkclear.c","../ncurses/./base/lib_slktouch.c","../ncurses/./base/safe_sprintf.c","../ncurses/./trace/varargs.c","../ncurses/./tinfo/access.c","../ncurses/./tinfo/comp_hash.c","../ncurses/./tinfo/db_iterator.c","../ncurses/fallback.c","../ncurses/./tinfo/free_ttype.c","../ncurses/./tinfo/home_terminfo.c","../ncurses/./tinfo/init_keytry.c","../ncurses/lib_keyname.c","../ncurses/./trace/trace_tries.c","../ncurses/./base/key_defined.c","../ncurses/./base/keybound.c","../ncurses/./base/lib_erase.c","../ncurses/./tinfo/add_tries.c","../ncurses/comp_captab.c","../ncurses/./tinfo/entries.c","../ncurses/./base/tries.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAscA;AAOA;AAEA;AAGA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAGA;;;;AAIA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAIA;AAAA;A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AAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AA0BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAaA;AAAA;AACA;;AAbA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYA;AAAA;AACA;;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAWA;AAAA;AACA;;AAXA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AACA;;;;;;;;;;;;;;;;AArQA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;;;AA4DA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AA+LA;AAAA;AACA;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAsBA;;AAlBA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA;AAAA;AACA;;;;;;;;;;;;;;;;;AAojBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA7GA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AACA;AAmFA;AAAA;AAAA;;AAlFA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAiFA;AAAA;AAAA;;;AAzEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;AA6BA;AACA;;;AA7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;;AAEA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;;;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;;AANA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5QA;AAAA;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;;AAYA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAaA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAHA;AAAA;AAGA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;;;;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AAHA;AAAA;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAEA;AAAA;AAAA;AAHA;AAAA;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAHA;AAAA;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAOA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAHA;AAAA;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAMA;AAAA;;AACA;;AACA;;;AAEA;AAEA;AAAA;AACA;AAAA;AAAA;AAHA;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAHA;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAFA;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAHA;;;;;AAMA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAHA;;;;;;;;;;AAmBA;AAAA;;AACA;AACA;AACA;AADA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;;AADA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvYA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;;AAEA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;;AAEA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;;;;;AAKA;AAAA;;AACA;AA6JA;AAAA;;;AA1JA;AAAA;AAEA;AAAA;AAAA;;AAIA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;;AAEA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;;AAEA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAEA;AAmBA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;;AA0BA;AAAA;;;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAFA;AAAA;AAAA;;AAOA;;;AAKA;AAAA;;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;;AAEA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAEA;AAkBA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;AAKA;AAAA;;AACA;AAIA;AAAA;;;AADA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;AA/OA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAUA;AAEA;AAAA;;;AAXA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;AASA;AAAA;;AAPA;AAOA;AAAA;;;;;AA9BA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5UA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAAA;;AACA;AAAA;AAAA;AA8JA;AAAA;;AAxJA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;;;AAIA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AACA;AACA;AACA;AACA;AARA;AAQA;;AACA;AAAA;AACA;;;AAWA;AAAA;AAgBA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAOA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AADA;AAAA;AAAA;AAMA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;;;;;;AALA;AAAA;AAAA;AAAA;AASA;AAAA;AAEA;AAAA;AAAA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAIA;AAGA;AAIA;AAAA;AAEA;AACA;AAAA;;;AAIA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;AAhRA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAiBA;AAAA;AAAA;;AAdA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;;;;;;;;;;AAiQA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;;;;;;;;;AC9SA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAOA;AAAA;;AANA;AAAA;AAAA;AAKA;AAAA;AACA;AAAA;;;;;;;;;;;AAaA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAOA;AAAA;;AANA;AAAA;AAAA;AAKA;AAAA;AACA;AAAA;;;;;;;AAMA;AAAA;AAAA;;;;;;;;;;;ACzCA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAOA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAeA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAKA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;;AACA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AA6FA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AA1HA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA8HA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;;;AAvMA;AAAA;AAuMA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAiBA;AAAA;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAFA;AAFA;AAAA;AAAA;;AAQA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAFA;AAAA;AAAA;;;;AASA;AAAA;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAFA;AADA;AAAA;AAAA;;AAOA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AADA;AAAA;AAAA;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;;;;AAnEA;AAAA;AAAA;;AAmEA;;AAnEA;AAmEA;;;;;;;;;;;;;;AAKA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AACA;AAAA;;;AATA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAQA;AAAA;;;;;;;;;;;ACrFA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAGA;AAEA;AACA;AACA;AACA;AACA;;AAMA;AAAA;AAAA;;AACA;AAAA;;AADA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwMA;AAGA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAyYA;AAAA;;AAnXA;AAAA;AACA;AAAA;AAAA;AAAA;AAKA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;AACA;AACA;AAAA;AAKA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAsBA;AAAA;AAAA;AACA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AA0CA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAiBA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;;;;AAGA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AAYA;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAOA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;A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AAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAOA;AAAA;AAAA;;;;AACA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;AACA;AAAA;AA6HA;AAAA;;AA3HA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAXA;AAYA;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;;;;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAcA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AACA;AAAA;;;;;;;;;;;;;;AAiCA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;;AA0CA;AAAA;AAAA;;AA1CA;AAAA;AA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AAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;AAKA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAFA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAIA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AAKA;;;AAGA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AADA;AAAA;AAAA;;AAKA;AAAA;AAAA;;AACA;;AADA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuTA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAFA;AAAA;AAAA;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;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;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAFA;;;AAKA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAFA;;;AAKA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;AAKA;AACA;AAAA;;;AAnCA;AAmCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA/FA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAA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AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAIA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;;;;;AAIA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;;;;;AAIA;AAAA;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;;;;;AAIA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;;;;;AAWA;AAAA;;;;AACA;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;;AAEA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AACA;AAAA;AAAA;;;;;AAoCA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;;;;AAMA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;;AA3CA;AAAA;AACA;AAAA;;;;AAEA;AAAA;AAAA;AACA;;AACA;AA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","file":"../../worm.html","sourcesContent":["/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n/*\n\n\t @@@        @@@    @@@@@@@@@@     @@@@@@@@@@@    @@@@@@@@@@@@\n\t @@@        @@@   @@@@@@@@@@@@    @@@@@@@@@@@@   @@@@@@@@@@@@@\n\t @@@        @@@  @@@@      @@@@   @@@@           @@@@ @@@  @@@@\n\t @@@   @@   @@@  @@@        @@@   @@@            @@@  @@@   @@@\n\t @@@  @@@@  @@@  @@@        @@@   @@@            @@@  @@@   @@@\n\t @@@@ @@@@ @@@@  @@@        @@@   @@@            @@@  @@@   @@@\n\t  @@@@@@@@@@@@   @@@@      @@@@   @@@            @@@  @@@   @@@\n\t   @@@@  @@@@     @@@@@@@@@@@@    @@@            @@@  @@@   @@@\n\t    @@    @@       @@@@@@@@@@     @@@            @@@  @@@   @@@\n\n\t\t\t\t Eric P. Scott\n\t\t\t  Caltech High Energy Physics\n\t\t\t\t October, 1980\n\n\t\tHacks to turn this into a test frame for cursor movement:\n\t\t\tEric S. Raymond <esr@snark.thyrsus.com>\n\t\t\t\tJanuary, 1995\n\n\t\tJuly 1995 (esr): worms is now in living color! :-)\n\n  This program makes a good torture-test for the ncurses cursor-optimization\n  code.  You can use -T to set the worm move interval over which movement\n  traces will be dumped.  The program stops and waits for one character of\n  input at the beginning and end of the interval.\n\n  $Id: worm.c,v 1.76 2017/11/18 22:41:08 tom Exp $\n*/\n\n#include <test.priv.h>\n\n#ifndef NCURSES_VERSION\n#undef TRACE\n#endif\n\n#ifdef USE_PTHREADS\n#include <pthread.h>\n#endif\n\nWANT_USE_WINDOW();\n\n#define MAX_WORMS\t40\n#define MAX_LENGTH\t1024\n\nstatic chtype flavor[] =\n{\n    'O', '*', '#', '$', '%', '0', '@',\n};\nstatic const int xinc[] =\n{\n    1, 1, 1, 0, -1, -1, -1, 0\n}, yinc[] =\n{\n    -1, 0, 1, 1, 1, 0, -1, -1\n};\n\ntypedef struct worm {\n    int orientation;\n    int head;\n    int *xpos;\n    int *ypos;\n    chtype attrs;\n#ifdef USE_PTHREADS\n    pthread_t thread;\n#endif\n} WORM;\n\nstatic unsigned long sequence = 0;\nstatic bool quitting = FALSE;\n\nstatic WORM worm[MAX_WORMS];\nstatic int max_refs;\nstatic int **refs;\nstatic int last_x, last_y;\n\nstatic const char *field;\nstatic int length = 16, number = 3;\nstatic chtype trail = ' ';\n\nstatic unsigned pending;\n#ifdef TRACE\nstatic int generation, trace_start, trace_end;\n#endif /* TRACE */\n/* *INDENT-OFF* */\nstatic const struct options {\n    int nopts;\n    int opts[3];\n} normal[8]={\n    { 3, { 7, 0, 1 } },\n    { 3, { 0, 1, 2 } },\n    { 3, { 1, 2, 3 } },\n    { 3, { 2, 3, 4 } },\n    { 3, { 3, 4, 5 } },\n    { 3, { 4, 5, 6 } },\n    { 3, { 5, 6, 7 } },\n    { 3, { 6, 7, 0 } }\n}, upper[8]={\n    { 1, { 1, 0, 0 } },\n    { 2, { 1, 2, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 2, { 4, 5, 0 } },\n    { 1, { 5, 0, 0 } },\n    { 2, { 1, 5, 0 } }\n}, left[8]={\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 2, { 2, 3, 0 } },\n    { 1, { 3, 0, 0 } },\n    { 2, { 3, 7, 0 } },\n    { 1, { 7, 0, 0 } },\n    { 2, { 7, 0, 0 } }\n}, right[8]={\n    { 1, { 7, 0, 0 } },\n    { 2, { 3, 7, 0 } },\n    { 1, { 3, 0, 0 } },\n    { 2, { 3, 4, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 2, { 6, 7, 0 } }\n}, lower[8]={\n    { 0, { 0, 0, 0 } },\n    { 2, { 0, 1, 0 } },\n    { 1, { 1, 0, 0 } },\n    { 2, { 1, 5, 0 } },\n    { 1, { 5, 0, 0 } },\n    { 2, { 5, 6, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } }\n}, upleft[8]={\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 1, { 3, 0, 0 } },\n    { 2, { 1, 3, 0 } },\n    { 1, { 1, 0, 0 } }\n}, upright[8]={\n    { 2, { 3, 5, 0 } },\n    { 1, { 3, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 1, { 5, 0, 0 } }\n}, lowleft[8]={\n    { 3, { 7, 0, 1 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 1, { 1, 0, 0 } },\n    { 2, { 1, 7, 0 } },\n    { 1, { 7, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } }\n}, lowright[8]={\n    { 0, { 0, 0, 0 } },\n    { 1, { 7, 0, 0 } },\n    { 2, { 5, 7, 0 } },\n    { 1, { 5, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } },\n    { 0, { 0, 0, 0 } }\n};\n/* *INDENT-ON* */\n\n#ifdef KEY_RESIZE\nstatic void\nfailed(const char *s)\n{\n    perror(s);\n    exit_curses();\n    ExitProgram(EXIT_FAILURE);\n}\n#endif\n\nstatic void\ncleanup(void)\n{\n    USING_WINDOW(stdscr, wrefresh);\n    exit_curses();\n}\n\nstatic void\nonsig(int sig GCC_UNUSED)\n{\n    cleanup();\n    ExitProgram(EXIT_FAILURE);\n}\n\nstatic double\nranf(void)\n{\n    long r = (rand() & 077777);\n    return ((double) r / 32768.);\n}\n\nstatic int\ndraw_worm(WINDOW *win, void *data)\n{\n    WORM *w = (WORM *) data;\n    const struct options *op;\n    unsigned mask = (unsigned) (~(1 << (w - worm)));\n    chtype attrs = w->attrs | ((mask & pending) ? A_REVERSE : 0);\n\n    int x;\n    int y;\n    int h;\n\n    bool done = FALSE;\n\n    if ((x = w->xpos[h = w->head]) < 0) {\n\twmove(win, y = w->ypos[h] = last_y, x = w->xpos[h] = 0);\n\twaddch(win, attrs);\n\trefs[y][x]++;\n    } else {\n\ty = w->ypos[h];\n    }\n\n    if (x > last_x)\n\tx = last_x;\n    if (y > last_y)\n\ty = last_y;\n\n    if (++h == length)\n\th = 0;\n\n    if (w->xpos[w->head = h] >= 0) {\n\tint x1, y1;\n\tx1 = w->xpos[h];\n\ty1 = w->ypos[h];\n\tif (y1 < LINES\n\t    && x1 < COLS\n\t    && --refs[y1][x1] == 0) {\n\t    wmove(win, y1, x1);\n\t    waddch(win, trail);\n\t}\n    }\n\n    op = &(x == 0\n\t   ? (y == 0\n\t      ? upleft\n\t      : (y == last_y\n\t\t ? lowleft\n\t\t : left))\n\t   : (x == last_x\n\t      ? (y == 0\n\t\t ? upright\n\t\t : (y == last_y\n\t\t    ? lowright\n\t\t    : right))\n\t      : (y == 0\n\t\t ? upper\n\t\t : (y == last_y\n\t\t    ? lower\n\t\t    : normal))))[w->orientation];\n\n    switch (op->nopts) {\n    case 0:\n\tdone = TRUE;\n\tTrace((\"done - draw_worm\"));\n\tbreak;\n    case 1:\n\tw->orientation = op->opts[0];\n\tbreak;\n    default:\n\tw->orientation = op->opts[(int) (ranf() * (double) op->nopts)];\n\tbreak;\n    }\n\n    if (!done) {\n\tx += xinc[w->orientation];\n\ty += yinc[w->orientation];\n\twmove(win, y, x);\n\n\tif (y < 0)\n\t    y = 0;\n\twaddch(win, attrs);\n\n\tw->ypos[h] = y;\n\tw->xpos[h] = x;\n\trefs[y][x]++;\n    }\n\n    return done;\n}\n\n#ifdef USE_PTHREADS\nstatic bool\nquit_worm(int bitnum)\n{\n    pending = (pending | (unsigned) (1 << bitnum));\n    napms(10);\t\t\t/* let the other thread(s) have a chance */\n    pending = (pending & (unsigned) ~(1 << bitnum));\n    return quitting;\n}\n\nstatic void *\nstart_worm(void *arg)\n{\n    unsigned long compare = 0;\n    Trace((\"start_worm\"));\n    while (!quit_worm((int) (((struct worm *) arg) - worm))) {\n\twhile (compare < sequence) {\n\t    ++compare;\n#if HAVE_USE_WINDOW\n\t    use_window(stdscr, draw_worm, arg);\n#else\n\t    draw_worm(stdscr, arg);\n#endif\n\t}\n    }\n    Trace((\"...start_worm (done)\"));\n    return NULL;\n}\n#endif\n\nstatic bool\ndraw_all_worms(void)\n{\n    bool done = FALSE;\n    int n;\n    struct worm *w;\n\n#ifdef USE_PTHREADS\n    static bool first = TRUE;\n    if (first) {\n\tfirst = FALSE;\n\tfor (n = 0, w = &worm[0]; n < number; n++, w++) {\n\t    (void) pthread_create(&(w->thread), NULL, start_worm, w);\n\t}\n    }\n#else\n    for (n = 0, w = &worm[0]; n < number; n++, w++) {\n\tif (\n#if HAVE_USE_WINDOW\n\t       USING_WINDOW2(stdscr, draw_worm, w)\n#else\n\t       draw_worm(stdscr, w)\n#endif\n\t    )\n\t    done = TRUE;\n    }\n#endif\n    return done;\n}\n\nstatic int\nget_input(void)\n{\n    int ch;\n    ch = USING_WINDOW(stdscr, wgetch);\n    return ch;\n}\n\n#ifdef KEY_RESIZE\nstatic int\nupdate_refs(WINDOW *win)\n{\n    int x, y;\n\n    (void) win;\n    if (last_x != COLS - 1) {\n\tfor (y = 0; y <= last_y; y++) {\n\t    refs[y] = typeRealloc(int, (size_t) COLS, refs[y]);\n\t    if (!refs[y])\n\t\tfailed(\"update_refs\");\n\t    for (x = last_x + 1; x < COLS; x++)\n\t\trefs[y][x] = 0;\n\t}\n\tlast_x = COLS - 1;\n    }\n    if (last_y != LINES - 1) {\n\tfor (y = LINES; y <= last_y; y++)\n\t    free(refs[y]);\n\tmax_refs = LINES;\n\trefs = typeRealloc(int *, (size_t) LINES, refs);\n\tfor (y = last_y + 1; y < LINES; y++) {\n\t    refs[y] = typeMalloc(int, (size_t) COLS);\n\t    if (!refs[y])\n\t\tfailed(\"update_refs\");\n\t    for (x = 0; x < COLS; x++)\n\t\trefs[y][x] = 0;\n\t}\n\tlast_y = LINES - 1;\n    }\n    return OK;\n}\n#endif\n\nstatic void\nusage(void)\n{\n    static const char *msg[] =\n    {\n\t\"Usage: worm [options]\"\n\t,\"\"\n\t,\"Options:\"\n#if HAVE_USE_DEFAULT_COLORS\n\t,\" -d       invoke use_default_colors\"\n#endif\n\t,\" -f       fill screen with copies of \\\"WORM\\\" at start\"\n\t,\" -l <n>   set length of worms\"\n\t,\" -n <n>   set number of worms\"\n\t,\" -t       leave trail of \\\".\\\"\"\n#ifdef TRACE\n\t,\" -T <start>,<end> set trace interval\"\n\t,\" -N       suppress cursor-movement optimization\"\n#endif\n    };\n    size_t n;\n\n    for (n = 0; n < SIZEOF(msg); n++)\n\tfprintf(stderr, \"%s\\n\", msg[n]);\n\n    ExitProgram(EXIT_FAILURE);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    trace(TRACE_MAXIMUM);\n\n    int ch;\n    int x, y;\n    int n;\n    struct worm *w;\n    int *ip;\n    bool done = FALSE;\n#if HAVE_USE_DEFAULT_COLORS\n    bool opt_d = FALSE;\n#endif\n\n    setlocale(LC_ALL, \"\");\n\n    while ((ch = getopt(argc, argv, \"dfl:n:tT:N\")) != -1) {\n\tswitch (ch) {\n#if HAVE_USE_DEFAULT_COLORS\n\tcase 'd':\n\t    opt_d = TRUE;\n\t    break;\n#endif\n\tcase 'f':\n\t    field = \"WORM\";\n\t    break;\n\tcase 'l':\n\t    if ((length = atoi(optarg)) < 2 || length > MAX_LENGTH) {\n\t\tfprintf(stderr, \"%s: Invalid length\\n\", *argv);\n\t\tusage();\n\t    }\n\t    break;\n\tcase 'n':\n\t    if ((number = atoi(optarg)) < 1 || number > MAX_WORMS) {\n\t\tfprintf(stderr, \"%s: Invalid number of worms\\n\", *argv);\n\t\tusage();\n\t    }\n\t    break;\n\tcase 't':\n\t    trail = '.';\n\t    break;\n#ifdef TRACE\n\tcase 'T':\n\t    if (sscanf(optarg, \"%d,%d\", &trace_start, &trace_end) != 2)\n\t\tusage();\n\t    break;\n\tcase 'N':\n\t    _nc_optimize_enable ^= OPTIMIZE_ALL;\t/* declared by ncurses */\n\t    break;\n#endif /* TRACE */\n\tdefault:\n\t    usage();\n\t    /* NOTREACHED */\n\t}\n    }\n    if (optind < argc)\n\tusage();\n\n    signal(SIGINT, onsig);\n    initscr();\n    noecho();\n    cbreak();\n    nonl();\n\n    curs_set(0);\n\n    last_y = LINES - 1;\n    last_x = COLS - 1;\n\n#ifdef A_COLOR\n    if (has_colors()) {\n\tint bg = COLOR_BLACK;\n\tstart_color();\n#if HAVE_USE_DEFAULT_COLORS\n\tif (opt_d && (use_default_colors() == OK))\n\t    bg = -1;\n#endif\n\n#define SET_COLOR(num, fg) \\\n\t    init_pair(num+1, (short) fg, (short) bg); \\\n\t    flavor[num] |= (chtype) COLOR_PAIR(num+1) | A_BOLD\n\n\tSET_COLOR(0, COLOR_GREEN);\n\tSET_COLOR(1, COLOR_RED);\n\tSET_COLOR(2, COLOR_CYAN);\n\tSET_COLOR(3, COLOR_WHITE);\n\tSET_COLOR(4, COLOR_MAGENTA);\n\tSET_COLOR(5, COLOR_BLUE);\n\tSET_COLOR(6, COLOR_YELLOW);\n    }\n#endif /* A_COLOR */\n\n    max_refs = LINES;\n    refs = typeMalloc(int *, (size_t) max_refs);\n    for (y = 0; y < max_refs; y++) {\n\trefs[y] = typeMalloc(int, (size_t) COLS);\n\tfor (x = 0; x < COLS; x++) {\n\t    refs[y][x] = 0;\n\t}\n    }\n\n#ifdef BADCORNER\n    /* if addressing the lower right corner doesn't work in your curses */\n    refs[last_y][last_x] = 1;\n#endif /* BADCORNER */\n\n    for (n = number, w = &worm[0]; --n >= 0; w++) {\n\tw->attrs = flavor[(unsigned) n % SIZEOF(flavor)];\n\tw->orientation = 0;\n\tw->head = 0;\n\n\tif (!(ip = typeMalloc(int, (size_t) (length + 1)))) {\n\t    fprintf(stderr, \"%s: out of memory\\n\", *argv);\n\t    ExitProgram(EXIT_FAILURE);\n\t}\n\tw->xpos = ip;\n\tfor (x = length; --x >= 0;)\n\t    *ip++ = -1;\n\tif (!(ip = typeMalloc(int, (size_t) (length + 1)))) {\n\t    fprintf(stderr, \"%s: out of memory\\n\", *argv);\n\t    ExitProgram(EXIT_FAILURE);\n\t}\n\tw->ypos = ip;\n\tfor (y = length; --y >= 0;)\n\t    *ip++ = -1;\n    }\n    if (field) {\n\tconst char *p;\n\tp = field;\n\tfor (y = last_y; --y >= 0;) {\n\t    for (x = COLS; --x >= 0;) {\n\t\taddch((chtype) (*p++));\n\t\tif (!*p)\n\t\t    p = field;\n\t    }\n\t}\n    }\n    USING_WINDOW(stdscr, wrefresh);\n    nodelay(stdscr, TRUE);\n\n    while (!done) {\n\t++sequence;\n\tif ((ch = get_input()) > 0) {\n#ifdef TRACE\n\t    if (trace_start || trace_end) {\n\t\tif (generation == trace_start) {\n\t\t    trace(TRACE_CALLS);\n\t\t    get_input();\n\t\t} else if (generation == trace_end) {\n\t\t    trace(0);\n\t\t    get_input();\n\t\t}\n\n\t\tgeneration++;\n\t    }\n#endif\n\n#ifdef KEY_RESIZE\n\t    if (ch == KEY_RESIZE) {\n\t\tUSING_WINDOW(stdscr, update_refs);\n\t    }\n#endif\n\n\t    /*\n\t     * Make it simple to put this into single-step mode, or resume\n\t     * normal operation -T.Dickey\n\t     */\n\t    if (ch == 'q') {\n\t\tquitting = TRUE;\n\t\tdone = TRUE;\n\t\tTrace((\"done - quitting\"));\n\t\tcontinue;\n\t    } else if (ch == 's') {\n\t\tnodelay(stdscr, FALSE);\n\t    } else if (ch == ' ') {\n\t\tnodelay(stdscr, TRUE);\n\t    }\n\t}\n\n\tdone = draw_all_worms();\n\tnapms(10);\n\tUSING_WINDOW(stdscr, wrefresh);\n    }\n\n    Trace((\"Cleanup\"));\n    cleanup();\n#if NO_LEAKS\n    for (y = 0; y < max_refs; y++) {\n\tfree(refs[y]);\n    }\n    free(refs);\n    for (n = number, w = &worm[0]; --n >= 0; w++) {\n\tfree(w->xpos);\n\tfree(w->ypos);\n    }\n#endif\n#ifdef USE_PTHREADS\n    /*\n     * Do this just in case one of the threads did not really exit.\n     */\n    Trace((\"join all threads\"));\n    for (n = 0; n < number; n++) {\n\tpthread_join(worm[n].thread, NULL);\n    }\n#endif\n    ExitProgram(EXIT_SUCCESS);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/*\n**\tlib_addch.c\n**\n**\tThe routine waddch().\n**\n*/\n\n#include <curses.priv.h>\n#include <ctype.h>\n\nMODULE_ID(\"$Id: lib_addch.c,v 1.131 2017/07/29 20:42:02 tom Exp $\")\n\nstatic const NCURSES_CH_T blankchar = NewChar(BLANK_TEXT);\n\n/*\n * Ugly microtweaking alert.  Everything from here to end of module is\n * likely to be speed-critical -- profiling data sure says it is!\n * Most of the important screen-painting functions are shells around\n * waddch().  So we make every effort to reduce function-call overhead\n * by inlining stuff, even at the cost of making wrapped copies for\n * export.  Also we supply some internal versions that don't call the\n * window sync hook, for use by string-put functions.\n */\n\n/* Return bit mask for clearing color pair number if given ch has color */\n#define COLOR_MASK(ch) (~(attr_t)(((ch) & A_COLOR) ? A_COLOR : 0))\n\nstatic NCURSES_INLINE NCURSES_CH_T\nrender_char(WINDOW *win, NCURSES_CH_T ch)\n/* compute a rendition of the given char correct for the current context */\n{\n    attr_t a = WINDOW_ATTRS(win);\n    int pair = GetPair(ch);\n\n    if (ISBLANK(ch)\n\t&& AttrOf(ch) == A_NORMAL\n\t&& pair == 0) {\n\t/* color/pair in attrs has precedence over bkgrnd */\n\tch = win->_nc_bkgd;\n\tSetAttr(ch, a | AttrOf(win->_nc_bkgd));\n\tif ((pair = GET_WINDOW_PAIR(win)) == 0)\n\t    pair = GetPair(win->_nc_bkgd);\n\tSetPair(ch, pair);\n    } else {\n\t/* color in attrs has precedence over bkgrnd */\n\ta |= AttrOf(win->_nc_bkgd) & COLOR_MASK(a);\n\t/* color in ch has precedence */\n\tif (pair == 0) {\n\t    if ((pair = GET_WINDOW_PAIR(win)) == 0)\n\t\tpair = GetPair(win->_nc_bkgd);\n\t}\n\tAddAttr(ch, (a & COLOR_MASK(AttrOf(ch))));\n\tSetPair(ch, pair);\n    }\n\n    TR(TRACE_VIRTPUT,\n       (\"render_char bkg %s (%d), attrs %s (%d) -> ch %s (%d)\",\n\t_tracech_t2(1, CHREF(win->_nc_bkgd)),\n\tGetPair(win->_nc_bkgd),\n\t_traceattr(WINDOW_ATTRS(win)),\n\tGET_WINDOW_PAIR(win),\n\t_tracech_t2(3, CHREF(ch)),\n\tGetPair(ch)));\n\n    return (ch);\n}\n\nNCURSES_EXPORT(NCURSES_CH_T)\n_nc_render(WINDOW *win, NCURSES_CH_T ch)\n/* make render_char() visible while still allowing us to inline it below */\n{\n    return render_char(win, ch);\n}\n\n/* check if position is legal; if not, return error */\n#ifndef NDEBUG\t\t\t/* treat this like an assertion */\n#define CHECK_POSITION(win, x, y) \\\n\tif (y > win->_maxy \\\n\t || x > win->_maxx \\\n\t || y < 0 \\\n\t || x < 0) { \\\n\t\tTR(TRACE_VIRTPUT, (\"Alert! Win=%p _curx = %d, _cury = %d \" \\\n\t\t\t\t   \"(_maxx = %d, _maxy = %d)\", win, x, y, \\\n\t\t\t\t   win->_maxx, win->_maxy)); \\\n\t\treturn(ERR); \\\n\t}\n#else\n#define CHECK_POSITION(win, x, y)\t/* nothing */\n#endif\n\nstatic bool\nnewline_forces_scroll(WINDOW *win, NCURSES_SIZE_T *ypos)\n{\n    bool result = FALSE;\n\n    if (*ypos >= win->_regtop && *ypos <= win->_regbottom) {\n\tif (*ypos == win->_regbottom) {\n\t    *ypos = win->_regbottom;\n\t    result = TRUE;\n\t} else {\n\t    *ypos = (NCURSES_SIZE_T) (*ypos + 1);\n\t}\n    } else if (*ypos < win->_maxy) {\n\t*ypos = (NCURSES_SIZE_T) (*ypos + 1);\n    }\n    return result;\n}\n\n/*\n * The _WRAPPED flag is useful only for telling an application that we've just\n * wrapped the cursor.  We don't do anything with this flag except set it when\n * wrapping, and clear it whenever we move the cursor.  If we try to wrap at\n * the lower-right corner of a window, we cannot move the cursor (since that\n * wouldn't be legal).  So we return an error (which is what SVr4 does). \n * Unlike SVr4, we can successfully add a character to the lower-right corner\n * (Solaris 2.6 does this also, however).\n */\nstatic int\nwrap_to_next_line(WINDOW *win)\n{\n    win->_flags |= _WRAPPED;\n    if (newline_forces_scroll(win, &(win->_cury))) {\n\twin->_curx = win->_maxx;\n\tif (!win->_scroll)\n\t    return (ERR);\n\tscroll(win);\n    }\n    win->_curx = 0;\n    return (OK);\n}\n\n#if USE_WIDEC_SUPPORT\nstatic int waddch_literal(WINDOW *, NCURSES_CH_T);\n/*\n * Fill the given number of cells with blanks using the current background\n * rendition.  This saves/restores the current x-position.\n */\nstatic void\nfill_cells(WINDOW *win, int count)\n{\n    NCURSES_CH_T blank = blankchar;\n    int save_x = win->_curx;\n    int save_y = win->_cury;\n\n    while (count-- > 0) {\n\tif (waddch_literal(win, blank) == ERR)\n\t    break;\n    }\n    win->_curx = (NCURSES_SIZE_T) save_x;\n    win->_cury = (NCURSES_SIZE_T) save_y;\n}\n#endif\n\n/*\n * Build up the bytes for a multibyte character, returning the length when\n * complete (a positive number), -1 for error and -2 for incomplete.\n */\n#if USE_WIDEC_SUPPORT\nNCURSES_EXPORT(int)\n_nc_build_wch(WINDOW *win, ARG_CH_T ch)\n{\n    char *buffer = WINDOW_EXT(win, addch_work);\n    int len;\n    int x = win->_curx;\n    int y = win->_cury;\n    mbstate_t state;\n    wchar_t result;\n\n    if ((WINDOW_EXT(win, addch_used) != 0) &&\n\t(WINDOW_EXT(win, addch_x) != x ||\n\t WINDOW_EXT(win, addch_y) != y)) {\n\t/* discard the incomplete multibyte character */\n\tWINDOW_EXT(win, addch_used) = 0;\n\tTR(TRACE_VIRTPUT,\n\t   (\"Alert discarded multibyte on move (%d,%d) -> (%d,%d)\",\n\t    WINDOW_EXT(win, addch_y), WINDOW_EXT(win, addch_x),\n\t    y, x));\n    }\n    WINDOW_EXT(win, addch_x) = x;\n    WINDOW_EXT(win, addch_y) = y;\n\n    init_mb(state);\n    buffer[WINDOW_EXT(win, addch_used)] = (char) CharOf(CHDEREF(ch));\n    WINDOW_EXT(win, addch_used) += 1;\n    buffer[WINDOW_EXT(win, addch_used)] = '\\0';\n    if ((len = (int) mbrtowc(&result,\n\t\t\t     buffer,\n\t\t\t     (size_t) WINDOW_EXT(win, addch_used),\n\t\t\t     &state)) > 0) {\n\tattr_t attrs = AttrOf(CHDEREF(ch));\n\tif_EXT_COLORS(int pair = GetPair(CHDEREF(ch)));\n\tSetChar(CHDEREF(ch), result, attrs);\n\tif_EXT_COLORS(SetPair(CHDEREF(ch), pair));\n\tWINDOW_EXT(win, addch_used) = 0;\n    } else if (len == -1) {\n\t/*\n\t * An error occurred.  We could either discard everything,\n\t * or assume that the error was in the previous input.\n\t * Try the latter.\n\t */\n\tTR(TRACE_VIRTPUT, (\"Alert! mbrtowc returns error\"));\n\t/* handle this with unctrl() */\n\tWINDOW_EXT(win, addch_used) = 0;\n    }\n    return len;\n}\n#endif /* USE_WIDEC_SUPPORT */\n\nstatic\n#if !USE_WIDEC_SUPPORT\t\t/* cannot be inline if it is recursive */\nNCURSES_INLINE\n#endif\nint\nwaddch_literal(WINDOW *win, NCURSES_CH_T ch)\n{\n    int x;\n    int y;\n    struct ldat *line;\n\n    x = win->_curx;\n    y = win->_cury;\n\n    CHECK_POSITION(win, x, y);\n\n    ch = render_char(win, ch);\n\n    line = win->_line + y;\n\n    CHANGED_CELL(line, x);\n\n    /*\n     * Build up multibyte characters until we have a wide-character.\n     */\n#if NCURSES_SP_FUNCS\n#define DeriveSP() SCREEN *sp = _nc_screen_of(win);\n#else\n#define DeriveSP()\t\t/*nothing */\n#endif\n    if_WIDEC({\n\tDeriveSP();\n\tif (WINDOW_EXT(win, addch_used) != 0 || !Charable(ch)) {\n\t    int len = _nc_build_wch(win, CHREF(ch));\n\n\t    if (len >= -1) {\n\t\tattr_t attr = AttrOf(ch);\n\n\t\t/* handle EILSEQ (i.e., when len >= -1) */\n\t\tif (len == -1 && is8bits(CharOf(ch))) {\n\t\t    const char *s = NCURSES_SP_NAME(unctrl)\n\t\t      (NCURSES_SP_ARGx (chtype) CharOf(ch));\n\n\t\t    if (s[1] != '\\0') {\n\t\t\tint rc = OK;\n\t\t\twhile (*s != '\\0') {\n\t\t\t    rc = waddch(win, UChar(*s) | attr);\n\t\t\t    if (rc != OK)\n\t\t\t\tbreak;\n\t\t\t    ++s;\n\t\t\t}\n\t\t\treturn rc;\n\t\t    }\n\t\t}\n\t\tif (len == -1)\n\t\t    return waddch(win, ' ' | attr);\n\t    } else {\n\t\treturn OK;\n\t    }\n\t}\n    });\n\n    /*\n     * Non-spacing characters are added to the current cell.\n     *\n     * Spacing characters that are wider than one column require some display\n     * adjustments.\n     */\n    if_WIDEC({\n\tint len = wcwidth(CharOf(ch));\n\tint i;\n\tint j;\n\twchar_t *chars;\n\n\tif (len == 0) {\t\t/* non-spacing */\n\t    if ((x > 0 && y >= 0)\n\t\t|| (win->_maxx >= 0 && win->_cury >= 1)) {\n\t\tif (x > 0 && y >= 0)\n\t\t    chars = (win->_line[y].text[x - 1].chars);\n\t\telse\n\t\t    chars = (win->_line[y - 1].text[win->_maxx].chars);\n\t\tfor (i = 0; i < CCHARW_MAX; ++i) {\n\t\t    if (chars[i] == 0) {\n\t\t\tTR(TRACE_VIRTPUT,\n\t\t\t   (\"added non-spacing %d: %x\",\n\t\t\t    x, (int) CharOf(ch)));\n\t\t\tchars[i] = CharOf(ch);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    goto testwrapping;\n\t} else if (len > 1) {\t/* multi-column characters */\n\t    /*\n\t     * Check if the character will fit on the current line.  If it does\n\t     * not fit, fill in the remainder of the line with blanks.  and\n\t     * move to the next line.\n\t     */\n\t    if (len > win->_maxx + 1) {\n\t\tTR(TRACE_VIRTPUT, (\"character will not fit\"));\n\t\treturn ERR;\n\t    } else if (x + len > win->_maxx + 1) {\n\t\tint count = win->_maxx + 1 - x;\n\t\tTR(TRACE_VIRTPUT, (\"fill %d remaining cells\", count));\n\t\tfill_cells(win, count);\n\t\tif (wrap_to_next_line(win) == ERR)\n\t\t    return ERR;\n\t\tx = win->_curx;\n\t\ty = win->_cury;\n\t\tline = win->_line + y;\n\t    }\n\t    /*\n\t     * Check for cells which are orphaned by adding this character, set\n\t     * those to blanks.\n\t     *\n\t     * FIXME: this actually could fill j-i cells, more complicated to\n\t     * setup though.\n\t     */\n\t    for (i = 0; i < len; ++i) {\n\t\tif (isWidecBase(win->_line[y].text[x + i])) {\n\t\t    break;\n\t\t} else if (isWidecExt(win->_line[y].text[x + i])) {\n\t\t    for (j = i; x + j <= win->_maxx; ++j) {\n\t\t\tif (!isWidecExt(win->_line[y].text[x + j])) {\n\t\t\t    TR(TRACE_VIRTPUT, (\"fill %d orphan cells\", j));\n\t\t\t    fill_cells(win, j);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t    /*\n\t     * Finally, add the cells for this character.\n\t     */\n\t    for (i = 0; i < len; ++i) {\n\t\tNCURSES_CH_T value = ch;\n\t\tSetWidecExt(value, i);\n\t\tTR(TRACE_VIRTPUT, (\"multicolumn %d:%d (%d,%d)\",\n\t\t\t\t   i + 1, len,\n\t\t\t\t   win->_begy + y, win->_begx + x));\n\t\tline->text[x] = value;\n\t\tCHANGED_CELL(line, x);\n\t\t++x;\n\t    }\n\t    goto testwrapping;\n\t}\n    });\n\n    /*\n     * Single-column characters.\n     */\n    line->text[x++] = ch;\n    /*\n     * This label is used only for wide-characters.\n     */\n    if_WIDEC(\n  testwrapping:\n    );\n\n    TR(TRACE_VIRTPUT, (\"cell (%ld, %ld..%d) = %s\",\n\t\t       (long) win->_cury, (long) win->_curx, x - 1,\n\t\t       _tracech_t(CHREF(ch))));\n\n    if (x > win->_maxx) {\n\treturn wrap_to_next_line(win);\n    }\n    win->_curx = (NCURSES_SIZE_T) x;\n    return OK;\n}\n\nstatic NCURSES_INLINE int\nwaddch_nosync(WINDOW *win, const NCURSES_CH_T ch)\n/* the workhorse function -- add a character to the given window */\n{\n    NCURSES_SIZE_T x, y;\n    chtype t = (chtype) CharOf(ch);\n#if USE_WIDEC_SUPPORT || NCURSES_SP_FUNCS || USE_REENTRANT\n    SCREEN *sp = _nc_screen_of(win);\n#endif\n    const char *s = NCURSES_SP_NAME(unctrl) (NCURSES_SP_ARGx t);\n    int tabsize = 8;\n\n    /*\n     * If we are using the alternate character set, forget about locale.\n     * Otherwise, if unctrl() returns a single-character or the locale\n     * claims the code is printable (and not also a control character),\n     * treat it that way.\n     */\n    if ((AttrOf(ch) & A_ALTCHARSET)\n\t|| (\n#if USE_WIDEC_SUPPORT\n\t       (sp != 0 && sp->_legacy_coding) &&\n#endif\n\t       s[1] == 0\n\t)\n\t|| (\n\t       (isprint((int) t) && !iscntrl((int) t))\n#if USE_WIDEC_SUPPORT\n\t       || ((sp == 0 || !sp->_legacy_coding) &&\n\t\t   (WINDOW_EXT(win, addch_used)\n\t\t    || !_nc_is_charable(CharOf(ch))))\n#endif\n\t)) {\n\treturn waddch_literal(win, ch);\n    }\n\n    /*\n     * Handle carriage control and other codes that are not printable, or are\n     * known to expand to more than one character according to unctrl().\n     */\n    x = win->_curx;\n    y = win->_cury;\n\n    switch (t) {\n    case '\\t':\n#if USE_REENTRANT\n\ttabsize = *ptrTabsize(sp);\n#else\n\ttabsize = TABSIZE;\n#endif\n\tx = (NCURSES_SIZE_T) (x + (tabsize - (x % tabsize)));\n\t/*\n\t * Space-fill the tab on the bottom line so that we'll get the\n\t * \"correct\" cursor position.\n\t */\n\tif ((!win->_scroll && (y == win->_regbottom))\n\t    || (x <= win->_maxx)) {\n\t    NCURSES_CH_T blank = blankchar;\n\t    AddAttr(blank, AttrOf(ch));\n\t    while (win->_curx < x) {\n\t\tif (waddch_literal(win, blank) == ERR)\n\t\t    return (ERR);\n\t    }\n\t    break;\n\t} else {\n\t    wclrtoeol(win);\n\t    win->_flags |= _WRAPPED;\n\t    if (newline_forces_scroll(win, &y)) {\n\t\tx = win->_maxx;\n\t\tif (win->_scroll) {\n\t\t    scroll(win);\n\t\t    x = 0;\n\t\t}\n\t    } else {\n\t\tx = 0;\n\t    }\n\t}\n\tbreak;\n    case '\\n':\n\twclrtoeol(win);\n\tif (newline_forces_scroll(win, &y)) {\n\t    if (win->_scroll)\n\t\tscroll(win);\n\t    else\n\t\treturn (ERR);\n\t}\n\t/* FALLTHRU */\n    case '\\r':\n\tx = 0;\n\twin->_flags &= ~_WRAPPED;\n\tbreak;\n    case '\\b':\n\tif (x == 0)\n\t    return (OK);\n\tx--;\n\twin->_flags &= ~_WRAPPED;\n\tbreak;\n    default:\n\twhile (*s) {\n\t    NCURSES_CH_T sch;\n\t    SetChar(sch, UChar(*s++), AttrOf(ch));\n\t    if_EXT_COLORS(SetPair(sch, GetPair(ch)));\n\t    if (waddch_literal(win, sch) == ERR)\n\t\treturn ERR;\n\t}\n\treturn (OK);\n    }\n\n    win->_curx = x;\n    win->_cury = y;\n\n    return (OK);\n}\n\nNCURSES_EXPORT(int)\n_nc_waddch_nosync(WINDOW *win, const NCURSES_CH_T c)\n/* export copy of waddch_nosync() so the string-put functions can use it */\n{\n    return (waddch_nosync(win, c));\n}\n\n/*\n * The versions below call _nc_synchook().  We wanted to avoid this in the\n * version exported for string puts; they'll call _nc_synchook once at end\n * of run.\n */\n\n/* These are actual entry points */\n\nNCURSES_EXPORT(int)\nwaddch(WINDOW *win, const chtype ch)\n{\n    int code = ERR;\n    NCURSES_CH_T wch;\n    SetChar2(wch, ch);\n\n    TR(TRACE_VIRTPUT | TRACE_CCALLS, (T_CALLED(\"waddch(%p, %s)\"), (void *) win,\n\t\t\t\t      _tracechtype(ch)));\n\n    if (win && (waddch_nosync(win, wch) != ERR)) {\n\t_nc_synchook(win);\n\tcode = OK;\n    }\n\n    TR(TRACE_VIRTPUT | TRACE_CCALLS, (T_RETURN(\"%d\"), code));\n    return (code);\n}\n\nNCURSES_EXPORT(int)\nwechochar(WINDOW *win, const chtype ch)\n{\n    int code = ERR;\n    NCURSES_CH_T wch;\n    SetChar2(wch, ch);\n\n    TR(TRACE_VIRTPUT | TRACE_CCALLS, (T_CALLED(\"wechochar(%p, %s)\"),\n\t\t\t\t      (void *) win,\n\t\t\t\t      _tracechtype(ch)));\n\n    if (win && (waddch_nosync(win, wch) != ERR)) {\n\tbool save_immed = win->_immed;\n\twin->_immed = TRUE;\n\t_nc_synchook(win);\n\twin->_immed = save_immed;\n\tcode = OK;\n    }\n    TR(TRACE_VIRTPUT | TRACE_CCALLS, (T_RETURN(\"%d\"), code));\n    return (code);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2001,2009 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n ****************************************************************************/\n\n/*\n**\tlib_clreol.c\n**\n**\tThe routine wclrtoeol().\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_clreol.c,v 1.22 2009/10/24 22:33:06 tom Exp $\")\n\nNCURSES_EXPORT(int)\nwclrtoeol(WINDOW *win)\n{\n    int code = ERR;\n\n    T((T_CALLED(\"wclrtoeol(%p)\"), (void *) win));\n\n    if (win) {\n\tNCURSES_CH_T blank;\n\tNCURSES_CH_T *ptr, *end;\n\tstruct ldat *line;\n\tNCURSES_SIZE_T y = win->_cury;\n\tNCURSES_SIZE_T x = win->_curx;\n\n\t/*\n\t * If we have just wrapped the cursor, the clear applies to the\n\t * new line, unless we are at the lower right corner.\n\t */\n\tif ((win->_flags & _WRAPPED) != 0\n\t    && y < win->_maxy) {\n\t    win->_flags &= ~_WRAPPED;\n\t}\n\n\t/*\n\t * There's no point in clearing if we're not on a legal\n\t * position, either.\n\t */\n\tif ((win->_flags & _WRAPPED) != 0\n\t    || y > win->_maxy\n\t    || x > win->_maxx)\n\t    returnCode(ERR);\n\n\tblank = win->_nc_bkgd;\n\tline = &win->_line[y];\n\tCHANGED_TO_EOL(line, x, win->_maxx);\n\n\tptr = &(line->text[x]);\n\tend = &(line->text[win->_maxx]);\n\n\twhile (ptr <= end)\n\t    *ptr++ = blank;\n\n\t_nc_synchook(win);\n\tcode = OK;\n    }\n    returnCode(code);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/* lib_color.c\n *\n * Handles color emulation of SYS V curses\n */\n\n#define NEW_PAIR_INTERNAL 1\n\n#include <curses.priv.h>\n#include <new_pair.h>\n#include <tic.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_color.c,v 1.136 2017/10/22 15:19:37 tom Exp $\")\n\n#ifdef USE_TERM_DRIVER\n#define CanChange      InfoOf(SP_PARM).canchange\n#define DefaultPalette InfoOf(SP_PARM).defaultPalette\n#define HasColor       InfoOf(SP_PARM).hascolor\n#define InitColor      InfoOf(SP_PARM).initcolor\n#define MaxColors      InfoOf(SP_PARM).maxcolors\n#define MaxPairs       InfoOf(SP_PARM).maxpairs\n#define UseHlsPalette  (DefaultPalette == _nc_hls_palette)\n#else\n#define CanChange      can_change\n#define DefaultPalette (hue_lightness_saturation ? hls_palette : cga_palette)\n#define HasColor       has_color\n#define InitColor      initialize_color\n#define MaxColors      max_colors\n#define MaxPairs       max_pairs\n#define UseHlsPalette  (hue_lightness_saturation)\n#endif\n\n#ifndef USE_TERM_DRIVER\n/*\n * These should be screen structure members.  They need to be globals for\n * historical reasons.  So we assign them in start_color() and also in\n * set_term()'s screen-switching logic.\n */\n#if USE_REENTRANT\nNCURSES_EXPORT(int)\nNCURSES_PUBLIC_VAR(COLOR_PAIRS) (void)\n{\n    return SP ? SP->_pair_count : -1;\n}\nNCURSES_EXPORT(int)\nNCURSES_PUBLIC_VAR(COLORS) (void)\n{\n    return SP ? SP->_color_count : -1;\n}\n#else\nNCURSES_EXPORT_VAR(int) COLOR_PAIRS = 0;\nNCURSES_EXPORT_VAR(int) COLORS = 0;\n#endif\n#endif /* !USE_TERM_DRIVER */\n\n#define DATA(r,g,b) {r,g,b, 0,0,0, 0}\n\n#define TYPE_CALLOC(type,elts) typeCalloc(type, (unsigned)(elts))\n\n#define MAX_PALETTE\t8\n\n#define OkColorHi(n)\t(((n) < COLORS) && ((n) < maxcolors))\n#define InPalette(n)\t((n) >= 0 && (n) < MAX_PALETTE)\n\n/*\n * Given a RGB range of 0..1000, we'll normally set the individual values\n * to about 2/3 of the maximum, leaving full-range for bold/bright colors.\n */\n#define RGB_ON  680\n#define RGB_OFF 0\n/* *INDENT-OFF* */\nstatic const color_t cga_palette[] =\n{\n    /*  R               G               B */\n    DATA(RGB_OFF,\tRGB_OFF,\tRGB_OFF),\t/* COLOR_BLACK */\n    DATA(RGB_ON,\tRGB_OFF,\tRGB_OFF),\t/* COLOR_RED */\n    DATA(RGB_OFF,\tRGB_ON,\t\tRGB_OFF),\t/* COLOR_GREEN */\n    DATA(RGB_ON,\tRGB_ON,\t\tRGB_OFF),\t/* COLOR_YELLOW */\n    DATA(RGB_OFF,\tRGB_OFF,\tRGB_ON),\t/* COLOR_BLUE */\n    DATA(RGB_ON,\tRGB_OFF,\tRGB_ON),\t/* COLOR_MAGENTA */\n    DATA(RGB_OFF,\tRGB_ON,\t\tRGB_ON),\t/* COLOR_CYAN */\n    DATA(RGB_ON,\tRGB_ON,\t\tRGB_ON),\t/* COLOR_WHITE */\n};\n\nstatic const color_t hls_palette[] =\n{\n    /*  \tH       L       S */\n    DATA(\t0,\t0,\t0),\t\t/* COLOR_BLACK */\n    DATA(\t120,\t50,\t100),\t\t/* COLOR_RED */\n    DATA(\t240,\t50,\t100),\t\t/* COLOR_GREEN */\n    DATA(\t180,\t50,\t100),\t\t/* COLOR_YELLOW */\n    DATA(\t330,\t50,\t100),\t\t/* COLOR_BLUE */\n    DATA(\t60,\t50,\t100),\t\t/* COLOR_MAGENTA */\n    DATA(\t300,\t50,\t100),\t\t/* COLOR_CYAN */\n    DATA(\t0,\t50,\t100),\t\t/* COLOR_WHITE */\n};\n\n#ifdef USE_TERM_DRIVER\nNCURSES_EXPORT_VAR(const color_t*) _nc_cga_palette = cga_palette;\nNCURSES_EXPORT_VAR(const color_t*) _nc_hls_palette = hls_palette;\n#endif\n\n/* *INDENT-ON* */\n\n#if NCURSES_EXT_FUNCS\n/*\n * These are called from _nc_do_color(), which in turn is called from\n * vidattr - so we have to assume that sp may be null.\n */\nstatic int\ndefault_fg(NCURSES_SP_DCL0)\n{\n    return (SP_PARM != 0) ? SP_PARM->_default_fg : COLOR_WHITE;\n}\n\nstatic int\ndefault_bg(NCURSES_SP_DCL0)\n{\n    return SP_PARM != 0 ? SP_PARM->_default_bg : COLOR_BLACK;\n}\n#else\n#define default_fg(sp) COLOR_WHITE\n#define default_bg(sp) COLOR_BLACK\n#endif\n\n#ifndef USE_TERM_DRIVER\n/*\n * SVr4 curses is known to interchange color codes (1,4) and (3,6), possibly\n * to maintain compatibility with a pre-ANSI scheme.  The same scheme is\n * also used in the FreeBSD syscons.\n */\nstatic int\ntoggled_colors(int c)\n{\n    if (c < 16) {\n\tstatic const int table[] =\n\t{0, 4, 2, 6, 1, 5, 3, 7,\n\t 8, 12, 10, 14, 9, 13, 11, 15};\n\tc = table[c];\n    }\n    return c;\n}\n#endif\n\nstatic void\nset_background_color(NCURSES_SP_DCLx int bg, NCURSES_SP_OUTC outc)\n{\n#ifdef USE_TERM_DRIVER\n    CallDriver_3(SP_PARM, td_color, FALSE, bg, outc);\n#else\n    if (set_a_background) {\n\tTPUTS_TRACE(\"set_a_background\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_1(set_a_background, bg),\n\t\t\t\t1, outc);\n    } else {\n\tTPUTS_TRACE(\"set_background\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_1(set_background, toggled_colors(bg)),\n\t\t\t\t1, outc);\n    }\n#endif\n}\n\nstatic void\nset_foreground_color(NCURSES_SP_DCLx int fg, NCURSES_SP_OUTC outc)\n{\n#ifdef USE_TERM_DRIVER\n    CallDriver_3(SP_PARM, td_color, TRUE, fg, outc);\n#else\n    if (set_a_foreground) {\n\tTPUTS_TRACE(\"set_a_foreground\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_1(set_a_foreground, fg),\n\t\t\t\t1, outc);\n    } else {\n\tTPUTS_TRACE(\"set_foreground\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_1(set_foreground, toggled_colors(fg)),\n\t\t\t\t1, outc);\n    }\n#endif\n}\n\nstatic void\ninit_color_table(NCURSES_SP_DCL0)\n{\n    const color_t *tp = DefaultPalette;\n    int n;\n\n    assert(tp != 0);\n\n    for (n = 0; n < COLORS; n++) {\n\tif (InPalette(n)) {\n\t    SP_PARM->_color_table[n] = tp[n];\n\t} else {\n\t    SP_PARM->_color_table[n] = tp[n % MAX_PALETTE];\n\t    if (UseHlsPalette) {\n\t\tSP_PARM->_color_table[n].green = 100;\n\t    } else {\n\t\tif (SP_PARM->_color_table[n].red)\n\t\t    SP_PARM->_color_table[n].red = 1000;\n\t\tif (SP_PARM->_color_table[n].green)\n\t\t    SP_PARM->_color_table[n].green = 1000;\n\t\tif (SP_PARM->_color_table[n].blue)\n\t\t    SP_PARM->_color_table[n].blue = 1000;\n\t    }\n\t}\n    }\n}\n\nstatic bool\ninit_direct_colors(NCURSES_SP_DCL0)\n{\n    static NCURSES_CONST char name[] = \"RGB\";\n\n    int n;\n    const char *s;\n    int width;\n    rgb_bits_t *result = &(SP_PARM->_direct_color);\n\n    result->value = 0;\n\n    if (COLORS >= 8) {\n\t/* find the number of bits needed for the maximum color value */\n\tfor (width = 0; (1 << width) - 1 < (COLORS - 1); ++width) {\n\t    ;\n\t}\n\n\tif ((n = tigetflag(name)) > 0) {\n\t    n = (width + 2) / 3;\n\t    result->bits.red = UChar(n);\n\t    result->bits.green = UChar(n);\n\t    result->bits.blue = UChar(width - (2 * n));\n\t} else if ((n = tigetnum(name)) > 0) {\n\t    result->bits.red = UChar(n);\n\t    result->bits.green = UChar(n);\n\t    result->bits.blue = UChar(n);\n\t} else if ((s = tigetstr(name)) != 0 && VALID_STRING(s)) {\n\t    int red = n;\n\t    int green = n;\n\t    int blue = width - (2 * n);\n\n\t    switch (sscanf(s, \"%d/%d/%d\", &red, &green, &blue)) {\n\t    default:\n\t\tblue = width - (2 * n);\n\t\t/* FALLTHRU */\n\t    case 1:\n\t\tgreen = n;\n\t\t/* FALLTHRU */\n\t    case 2:\n\t\tred = n;\n\t\t/* FALLTHRU */\n\t    case 3:\n\t\t/* okay */\n\t\tbreak;\n\t    }\n\t    result->bits.red = UChar(red);\n\t    result->bits.green = UChar(green);\n\t    result->bits.blue = UChar(blue);\n\t}\n    }\n    return (result->value != 0);\n}\n\n/*\n * Reset the color pair, e.g., to whatever color pair 0 is.\n */\nstatic bool\nreset_color_pair(NCURSES_SP_DCL0)\n{\n#ifdef USE_TERM_DRIVER\n    return CallDriver(SP_PARM, td_rescol);\n#else\n    bool result = FALSE;\n\n    (void) SP_PARM;\n    if (orig_pair != 0) {\n\t(void) NCURSES_PUTP2(\"orig_pair\", orig_pair);\n\tresult = TRUE;\n    }\n    return result;\n#endif\n}\n\n/*\n * Reset color pairs and definitions.  Actually we do both more to accommodate\n * badly-written terminal descriptions than for the relatively rare case where\n * someone has changed the color definitions.\n */\nNCURSES_EXPORT(bool)\nNCURSES_SP_NAME(_nc_reset_colors) (NCURSES_SP_DCL0)\n{\n    int result = FALSE;\n\n    T((T_CALLED(\"_nc_reset_colors(%p)\"), (void *) SP_PARM));\n    if (SP_PARM->_color_defs > 0)\n\tSP_PARM->_color_defs = -(SP_PARM->_color_defs);\n    if (reset_color_pair(NCURSES_SP_ARG))\n\tresult = TRUE;\n\n#ifdef USE_TERM_DRIVER\n    result = CallDriver(SP_PARM, td_rescolors);\n#else\n    if (orig_colors != 0) {\n\tNCURSES_PUTP2(\"orig_colors\", orig_colors);\n\tresult = TRUE;\n    }\n#endif\n    returnBool(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(bool)\n_nc_reset_colors(void)\n{\n    return NCURSES_SP_NAME(_nc_reset_colors) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(start_color) (NCURSES_SP_DCL0)\n{\n    int result = ERR;\n    int maxpairs = 0, maxcolors = 0;\n\n    T((T_CALLED(\"start_color(%p)\"), (void *) SP_PARM));\n\n    if (SP_PARM == 0) {\n\tresult = ERR;\n    } else if (SP_PARM->_coloron) {\n\tresult = OK;\n    } else {\n\tmaxpairs = MaxPairs;\n\tmaxcolors = MaxColors;\n\tif (reset_color_pair(NCURSES_SP_ARG) != TRUE) {\n\t    set_foreground_color(NCURSES_SP_ARGx\n\t\t\t\t default_fg(NCURSES_SP_ARG),\n\t\t\t\t NCURSES_SP_NAME(_nc_outch));\n\t    set_background_color(NCURSES_SP_ARGx\n\t\t\t\t default_bg(NCURSES_SP_ARG),\n\t\t\t\t NCURSES_SP_NAME(_nc_outch));\n\t}\n#if !NCURSES_EXT_COLORS\n\t/*\n\t * Without ext-colors, we cannot represent more than 256 color pairs.\n\t */\n\tif (maxpairs > 256)\n\t    maxpairs = 256;\n#endif\n\n\tif (maxpairs > 0 && maxcolors > 0) {\n\t    SP_PARM->_pair_limit = maxpairs;\n\n#if NCURSES_EXT_FUNCS\n\t    /*\n\t     * If using default colors, allocate extra space in table to\n\t     * allow for default-color as a component of a color-pair.\n\t     */\n\t    SP_PARM->_pair_limit += (1 + (2 * maxcolors));\n\t    SP_PARM->_pair_limit = limit_PAIRS(SP_PARM->_pair_limit);\n#endif\n\t    SP_PARM->_pair_count = maxpairs;\n\t    SP_PARM->_color_count = maxcolors;\n#if !USE_REENTRANT\n\t    COLOR_PAIRS = maxpairs;\n\t    COLORS = maxcolors;\n#endif\n\n\t    _nc_reserve_pairs(SP_PARM, 16);\n\t    if (SP_PARM->_color_pairs != 0) {\n\t\tif (init_direct_colors(NCURSES_SP_ARG)) {\n\t\t    result = OK;\n\t\t} else {\n\t\t    SP_PARM->_color_table = TYPE_CALLOC(color_t, maxcolors);\n\t\t    if (SP_PARM->_color_table != 0) {\n\t\t\tMakeColorPair(SP_PARM->_color_pairs[0],\n\t\t\t\t      default_fg(NCURSES_SP_ARG),\n\t\t\t\t      default_bg(NCURSES_SP_ARG));\n\t\t\tinit_color_table(NCURSES_SP_ARG);\n\n\t\t\tresult = OK;\n\t\t    }\n\t\t}\n\t\tif (result == OK) {\n\t\t    T((\"started color: COLORS = %d, COLOR_PAIRS = %d\",\n\t\t       COLORS, COLOR_PAIRS));\n\n\t\t    SP_PARM->_coloron = 1;\n\t\t} else if (SP_PARM->_color_pairs != 0) {\n\t\t    FreeAndNull(SP_PARM->_color_pairs);\n\t\t}\n\t    }\n\t} else {\n\t    result = OK;\n\t}\n    }\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nstart_color(void)\n{\n    return NCURSES_SP_NAME(start_color) (CURRENT_SCREEN);\n}\n#endif\n\n/* This function was originally written by Daniel Weaver <danw@znyx.com> */\nstatic void\nrgb2hls(int r, int g, int b, int *h, int *l, int *s)\n/* convert RGB to HLS system */\n{\n    int min, max, t;\n\n    if ((min = g < r ? g : r) > b)\n\tmin = b;\n    if ((max = g > r ? g : r) < b)\n\tmax = b;\n\n    /* calculate lightness */\n    *l = ((min + max) / 20);\n\n    if (min == max) {\t\t/* black, white and all shades of gray */\n\t*h = 0;\n\t*s = 0;\n\treturn;\n    }\n\n    /* calculate saturation */\n    if (*l < 50)\n\t*s = (((max - min) * 100) / (max + min));\n    else\n\t*s = (((max - min) * 100) / (2000 - max - min));\n\n    /* calculate hue */\n    if (r == max)\n\tt = (120 + ((g - b) * 60) / (max - min));\n    else if (g == max)\n\tt = (240 + ((b - r) * 60) / (max - min));\n    else\n\tt = (360 + ((r - g) * 60) / (max - min));\n\n    *h = (t % 360);\n}\n\n/*\n * Change all cells which use(d) a given color pair to force a repaint.\n */\nNCURSES_EXPORT(void)\n_nc_change_pair(SCREEN *sp, int pair)\n{\n    int y, x;\n\n    if (CurScreen(sp)->_clear)\n\treturn;\n#if NO_LEAKS\n    if (_nc_globals.leak_checking)\n\treturn;\n#endif\n\n    for (y = 0; y <= CurScreen(sp)->_maxy; y++) {\n\tstruct ldat *ptr = &(CurScreen(sp)->_line[y]);\n\tbool changed = FALSE;\n\tfor (x = 0; x <= CurScreen(sp)->_maxx; x++) {\n\t    if (GetPair(ptr->text[x]) == pair) {\n\t\t/* Set the old cell to zero to ensure it will be\n\t\t   updated on the next doupdate() */\n\t\tSetChar(ptr->text[x], 0, 0);\n\t\tCHANGED_CELL(ptr, x);\n\t\tchanged = TRUE;\n\t    }\n\t}\n\tif (changed)\n\t    NCURSES_SP_NAME(_nc_make_oldhash) (NCURSES_SP_ARGx y);\n    }\n}\n\nNCURSES_EXPORT(colorpair_t *)\n_nc_reserve_pairs(SCREEN *sp, int want)\n{\n    colorpair_t *result = 0;\n    int have = sp->_pair_alloc;\n\n    if ((sp->_color_pairs != 0) && (want < sp->_pair_alloc)) {\n\tresult = &(sp->_color_pairs[want]);\n    } else {\n\n\tif (have == 0)\n\t    have = 1;\n\twhile (have <= want)\n\t    have *= 2;\n\tif (have > sp->_pair_limit)\n\t    have = sp->_pair_limit;\n\n\tif (sp->_color_pairs == 0) {\n\t    sp->_color_pairs = TYPE_CALLOC(colorpair_t, have);\n\t} else if (have > sp->_pair_alloc) {\n#if USE_NEW_PAIR\n\t    colorpair_t *next;\n\n\t    if ((next = typeCalloc(colorpair_t, have)) == 0)\n\t\t_nc_err_abort(MSG_NO_MEMORY);\n\t    memcpy(next, sp->_color_pairs, (size_t) sp->_pair_alloc * sizeof(*next));\n\t    _nc_copy_pairs(sp, next, sp->_color_pairs, sp->_pair_alloc);\n\t    free(sp->_color_pairs);\n\t    sp->_color_pairs = next;\n#else\n\t    TYPE_REALLOC(colorpair_t, have, sp->_color_pairs);\n\t    if (sp->_color_pairs != 0) {\n\t\tmemset(sp->_color_pairs + sp->_pair_alloc, 0,\n\t\t       sizeof(colorpair_t) * (size_t) (have - sp->_pair_alloc));\n\t    }\n#endif\n\t}\n\tif (sp->_color_pairs != 0) {\n\t    sp->_pair_alloc = have;\n\t    result = &(sp->_color_pairs[want]);\n\t}\n    }\n    return result;\n}\n\n/*\n * Extension (1997/1/18) - Allow negative f/b values to set default color\n * values.\n */\nNCURSES_EXPORT(int)\n_nc_init_pair(SCREEN *sp, int pair, int f, int b)\n{\n    static colorpair_t null_pair;\n    colorpair_t result = null_pair;\n    colorpair_t previous;\n    int maxcolors;\n\n    T((T_CALLED(\"init_pair(%p,%d,%d,%d)\"), (void *) sp, pair, f, b));\n\n    if (!ValidPair(sp, pair))\n\treturnCode(ERR);\n\n    maxcolors = MaxColors;\n\n    _nc_reserve_pairs(sp, pair);\n    previous = sp->_color_pairs[pair];\n#if NCURSES_EXT_FUNCS\n    if (sp->_default_color || sp->_assumed_color) {\n\tbool isDefault = FALSE;\n\tbool wasDefault = FALSE;\n\tint default_pairs = sp->_default_pairs;\n\n\t/*\n\t * Map caller's color number, e.g., -1, 0, 1, .., 7, etc., into\n\t * internal unsigned values which we will store in the _color_pairs[]\n\t * table.\n\t */\n\tif (isDefaultColor(f)) {\n\t    f = COLOR_DEFAULT;\n\t    isDefault = TRUE;\n\t} else if (!OkColorHi(f)) {\n\t    returnCode(ERR);\n\t}\n\n\tif (isDefaultColor(b)) {\n\t    b = COLOR_DEFAULT;\n\t    isDefault = TRUE;\n\t} else if (!OkColorHi(b)) {\n\t    returnCode(ERR);\n\t}\n\n\t/*\n\t * Check if the table entry that we are going to init/update used\n\t * default colors.\n\t */\n\tif (isDefaultColor(FORE_OF(previous))\n\t    || isDefaultColor(BACK_OF(previous)))\n\t    wasDefault = TRUE;\n\n\t/*\n\t * Keep track of the number of entries in the color pair table which\n\t * used a default color.\n\t */\n\tif (isDefault && !wasDefault) {\n\t    ++default_pairs;\n\t} else if (wasDefault && !isDefault) {\n\t    --default_pairs;\n\t}\n\n\t/*\n\t * As an extension, ncurses allows the pair number to exceed the\n\t * terminal's color_pairs value for pairs using a default color.\n\t *\n\t * Note that updating a pair which used a default color with one\n\t * that does not will decrement the count - and possibly interfere\n\t * with sequentially adding new pairs.\n\t */\n\tif (pair > (sp->_pair_count + default_pairs)) {\n\t    returnCode(ERR);\n\t}\n\tsp->_default_pairs = default_pairs;\n    } else\n#endif\n    {\n\tif ((f < 0) || !OkColorHi(f)\n\t    || (b < 0) || !OkColorHi(b)\n\t    || (pair < 1)) {\n\t    returnCode(ERR);\n\t}\n    }\n\n    /*\n     * When a pair's content is changed, replace its colors (if pair was\n     * initialized before a screen update is performed replacing original\n     * pair colors with the new ones).\n     */\n    MakeColorPair(result, f, b);\n    if ((FORE_OF(previous) != 0\n\t || BACK_OF(previous) != 0)\n\t&& !isSamePair(previous, result)) {\n\t_nc_change_pair(sp, pair);\n    }\n\n    _nc_reset_color_pair(sp, pair, &result);\n    sp->_color_pairs[pair] = result;\n    _nc_set_color_pair(sp, pair, cpINIT);\n\n    if (GET_SCREEN_PAIR(sp) == pair)\n\tSET_SCREEN_PAIR(sp, (int) (~0));\t/* force attribute update */\n\n#ifdef USE_TERM_DRIVER\n    CallDriver_3(sp, td_initpair, pair, f, b);\n#else\n    if (initialize_pair && InPalette(f) && InPalette(b)) {\n\tconst color_t *tp = DefaultPalette;\n\n\tTR(TRACE_ATTRS,\n\t   (\"initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)\",\n\t    (int) pair,\n\t    (int) tp[f].red, (int) tp[f].green, (int) tp[f].blue,\n\t    (int) tp[b].red, (int) tp[b].green, (int) tp[b].blue));\n\n\tNCURSES_PUTP2(\"initialize_pair\",\n\t\t      TPARM_7(initialize_pair,\n\t\t\t      pair,\n\t\t\t      (int) tp[f].red,\n\t\t\t      (int) tp[f].green,\n\t\t\t      (int) tp[f].blue,\n\t\t\t      (int) tp[b].red,\n\t\t\t      (int) tp[b].green,\n\t\t\t      (int) tp[b].blue));\n    }\n#endif\n\n    returnCode(OK);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(init_pair) (NCURSES_SP_DCLx\n\t\t\t    NCURSES_PAIRS_T pair,\n\t\t\t    NCURSES_COLOR_T f,\n\t\t\t    NCURSES_COLOR_T b)\n{\n    return _nc_init_pair(SP_PARM, pair, f, b);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ninit_pair(NCURSES_COLOR_T pair, NCURSES_COLOR_T f, NCURSES_COLOR_T b)\n{\n    return NCURSES_SP_NAME(init_pair) (CURRENT_SCREEN, pair, f, b);\n}\n#endif\n\n#define okRGB(n) ((n) >= 0 && (n) <= 1000)\n\nNCURSES_EXPORT(int)\n_nc_init_color(SCREEN *sp, int color, int r, int g, int b)\n{\n    int result = ERR;\n    int maxcolors;\n\n    T((T_CALLED(\"init_color(%p,%d,%d,%d,%d)\"),\n       (void *) sp,\n       color,\n       r, g, b));\n\n    if (sp == 0 || sp->_direct_color.value)\n\treturnCode(result);\n\n    maxcolors = MaxColors;\n\n    if (InitColor\n\t&& sp->_coloron\n\t&& (color >= 0 && OkColorHi(color))\n\t&& (okRGB(r) && okRGB(g) && okRGB(b))) {\n\n\tsp->_color_table[color].init = 1;\n\tsp->_color_table[color].r = r;\n\tsp->_color_table[color].g = g;\n\tsp->_color_table[color].b = b;\n\n\tif (UseHlsPalette) {\n\t    rgb2hls(r, g, b,\n\t\t    &sp->_color_table[color].red,\n\t\t    &sp->_color_table[color].green,\n\t\t    &sp->_color_table[color].blue);\n\t} else {\n\t    sp->_color_table[color].red = r;\n\t    sp->_color_table[color].green = g;\n\t    sp->_color_table[color].blue = b;\n\t}\n\n#ifdef USE_TERM_DRIVER\n\tCallDriver_4(sp, td_initcolor, color, r, g, b);\n#else\n\tNCURSES_PUTP2(\"initialize_color\",\n\t\t      TPARM_4(initialize_color, color, r, g, b));\n#endif\n\tsp->_color_defs = max(color + 1, sp->_color_defs);\n\n\tresult = OK;\n    }\n    returnCode(result);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(init_color) (NCURSES_SP_DCLx\n\t\t\t     NCURSES_COLOR_T color,\n\t\t\t     NCURSES_COLOR_T r,\n\t\t\t     NCURSES_COLOR_T g,\n\t\t\t     NCURSES_COLOR_T b)\n{\n    return _nc_init_color(SP_PARM, color, r, g, b);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ninit_color(NCURSES_COLOR_T color,\n\t   NCURSES_COLOR_T r,\n\t   NCURSES_COLOR_T g,\n\t   NCURSES_COLOR_T b)\n{\n    return NCURSES_SP_NAME(init_color) (CURRENT_SCREEN, color, r, g, b);\n}\n#endif\n\nNCURSES_EXPORT(bool)\nNCURSES_SP_NAME(can_change_color) (NCURSES_SP_DCL)\n{\n    int result = FALSE;\n\n    T((T_CALLED(\"can_change_color(%p)\"), (void *) SP_PARM));\n\n    if (HasTerminal(SP_PARM) && (CanChange != 0)) {\n\tresult = TRUE;\n    }\n\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(bool)\ncan_change_color(void)\n{\n    return NCURSES_SP_NAME(can_change_color) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(bool)\nNCURSES_SP_NAME(has_colors) (NCURSES_SP_DCL0)\n{\n    int code = FALSE;\n\n    (void) SP_PARM;\n    T((T_CALLED(\"has_colors()\")));\n    if (HasTerminal(SP_PARM)) {\n#ifdef USE_TERM_DRIVER\n\tcode = HasColor;\n#else\n\tcode = ((VALID_NUMERIC(max_colors) && VALID_NUMERIC(max_pairs)\n\t\t && (((set_foreground != NULL)\n\t\t      && (set_background != NULL))\n\t\t     || ((set_a_foreground != NULL)\n\t\t\t && (set_a_background != NULL))\n\t\t     || set_color_pair)) ? TRUE : FALSE);\n#endif\n    }\n    returnCode(code);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(bool)\nhas_colors(void)\n{\n    return NCURSES_SP_NAME(has_colors) (CURRENT_SCREEN);\n}\n#endif\n\nstatic int\n_nc_color_content(SCREEN *sp, int color, int *r, int *g, int *b)\n{\n    int result = ERR;\n    int maxcolors;\n\n    T((T_CALLED(\"color_content(%p,%d,%p,%p,%p)\"),\n       (void *) sp,\n       color,\n       (void *) r,\n       (void *) g,\n       (void *) b));\n\n    if (sp == 0)\n\treturnCode(result);\n\n    maxcolors = MaxColors;\n\n    if (color < 0 || !OkColorHi(color) || !sp->_coloron) {\n\tresult = ERR;\n    } else {\n\tint c_r, c_g, c_b;\n\n\tif (sp->_direct_color.value) {\n\t    rgb_bits_t *work = &(sp->_direct_color);\n\n#define max_direct_color(name)\t((1 << work->bits.name) - 1)\n#define value_direct_color(max) (1000 * ((color >> bitoff) & max)) / max\n\n\t    int max_r = max_direct_color(red);\n\t    int max_g = max_direct_color(green);\n\t    int max_b = max_direct_color(blue);\n\n\t    int bitoff = 0;\n\n\t    c_b = value_direct_color(max_b);\n\t    bitoff += work->bits.blue;\n\n\t    c_g = value_direct_color(max_g);\n\t    bitoff += work->bits.green;\n\n\t    c_r = value_direct_color(max_r);\n\n\t} else {\n\t    c_r = sp->_color_table[color].red;\n\t    c_g = sp->_color_table[color].green;\n\t    c_b = sp->_color_table[color].blue;\n\t}\n\n\tif (r)\n\t    *r = c_r;\n\tif (g)\n\t    *g = c_g;\n\tif (b)\n\t    *b = c_b;\n\n\tTR(TRACE_ATTRS, (\"...color_content(%d,%d,%d,%d)\",\n\t\t\t color, c_r, c_g, c_b));\n\tresult = OK;\n    }\n    returnCode(result);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(color_content) (NCURSES_SP_DCLx\n\t\t\t\tNCURSES_COLOR_T color,\n\t\t\t\tNCURSES_COLOR_T *r,\n\t\t\t\tNCURSES_COLOR_T *g,\n\t\t\t\tNCURSES_COLOR_T *b)\n{\n    int my_r, my_g, my_b;\n    int rc = _nc_color_content(SP_PARM, color, &my_r, &my_g, &my_b);\n    if (rc == OK) {\n\t*r = limit_COLOR(my_r);\n\t*g = limit_COLOR(my_g);\n\t*b = limit_COLOR(my_b);\n    }\n    return rc;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ncolor_content(NCURSES_COLOR_T color,\n\t      NCURSES_COLOR_T *r,\n\t      NCURSES_COLOR_T *g,\n\t      NCURSES_COLOR_T *b)\n{\n    return NCURSES_SP_NAME(color_content) (CURRENT_SCREEN, color, r, g, b);\n}\n#endif\n\nNCURSES_EXPORT(int)\n_nc_pair_content(SCREEN *sp, int pair, int *f, int *b)\n{\n    int result;\n\n    T((T_CALLED(\"pair_content(%p,%d,%p,%p)\"),\n       (void *) sp,\n       (int) pair,\n       (void *) f,\n       (void *) b));\n\n    if (!ValidPair(sp, pair)) {\n\tresult = ERR;\n    } else {\n\tint fg = FORE_OF(sp->_color_pairs[pair]);\n\tint bg = BACK_OF(sp->_color_pairs[pair]);\n\n#if NCURSES_EXT_FUNCS\n\tif (isDefaultColor(fg))\n\t    fg = -1;\n\tif (isDefaultColor(bg))\n\t    bg = -1;\n#endif\n\n\tif (f)\n\t    *f = fg;\n\tif (b)\n\t    *b = bg;\n\n\tTR(TRACE_ATTRS, (\"...pair_content(%p,%d,%d,%d)\",\n\t\t\t (void *) sp,\n\t\t\t (int) pair,\n\t\t\t (int) fg, (int) bg));\n\tresult = OK;\n    }\n    returnCode(result);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(pair_content) (NCURSES_SP_DCLx\n\t\t\t       NCURSES_PAIRS_T pair,\n\t\t\t       NCURSES_COLOR_T *f,\n\t\t\t       NCURSES_COLOR_T *b)\n{\n    int my_f, my_b;\n    int rc = _nc_pair_content(SP_PARM, pair, &my_f, &my_b);\n    if (rc == OK) {\n\t*f = limit_COLOR(my_f);\n\t*b = limit_COLOR(my_b);\n    }\n    return rc;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\npair_content(NCURSES_COLOR_T pair, NCURSES_COLOR_T *f, NCURSES_COLOR_T *b)\n{\n    return NCURSES_SP_NAME(pair_content) (CURRENT_SCREEN, pair, f, b);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_do_color) (NCURSES_SP_DCLx\n\t\t\t       int old_pair,\n\t\t\t       int pair,\n\t\t\t       int reverse,\n\t\t\t       NCURSES_SP_OUTC outc)\n{\n#ifdef USE_TERM_DRIVER\n    CallDriver_4(SP_PARM, td_docolor, old_pair, pair, reverse, outc);\n#else\n    int fg = COLOR_DEFAULT;\n    int bg = COLOR_DEFAULT;\n    int old_fg = -1;\n    int old_bg = -1;\n\n    if (!ValidPair(SP_PARM, pair)) {\n\treturn;\n    } else if (pair != 0) {\n\tif (set_color_pair) {\n\t    TPUTS_TRACE(\"set_color_pair\");\n\t    NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t    TPARM_1(set_color_pair, pair),\n\t\t\t\t    1, outc);\n\t    return;\n\t} else if (SP_PARM != 0) {\n\t    if (_nc_pair_content(SP_PARM, pair, &fg, &bg) == ERR)\n\t\treturn;\n\t}\n    }\n\n    if (old_pair >= 0\n\t&& SP_PARM != 0\n\t&& _nc_pair_content(SP_PARM, old_pair, &old_fg, &old_bg) != ERR) {\n\tif ((isDefaultColor(fg) && !isDefaultColor(old_fg))\n\t    || (isDefaultColor(bg) && !isDefaultColor(old_bg))) {\n#if NCURSES_EXT_FUNCS\n\t    /*\n\t     * A minor optimization - but extension.  If \"AX\" is specified in\n\t     * the terminal description, treat it as screen's indicator of ECMA\n\t     * SGR 39 and SGR 49, and assume the two sequences are independent.\n\t     */\n\t    if (SP_PARM->_has_sgr_39_49\n\t\t&& isDefaultColor(old_bg)\n\t\t&& !isDefaultColor(old_fg)) {\n\t\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx \"\\033[39m\", 1, outc);\n\t    } else if (SP_PARM->_has_sgr_39_49\n\t\t       && isDefaultColor(old_fg)\n\t\t       && !isDefaultColor(old_bg)) {\n\t\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx \"\\033[49m\", 1, outc);\n\t    } else\n#endif\n\t\treset_color_pair(NCURSES_SP_ARG);\n\t}\n    } else {\n\treset_color_pair(NCURSES_SP_ARG);\n\tif (old_pair < 0 && pair <= 0)\n\t    return;\n    }\n\n#if NCURSES_EXT_FUNCS\n    if (isDefaultColor(fg))\n\tfg = default_fg(NCURSES_SP_ARG);\n    if (isDefaultColor(bg))\n\tbg = default_bg(NCURSES_SP_ARG);\n#endif\n\n    if (reverse) {\n\tint xx = fg;\n\tfg = bg;\n\tbg = xx;\n    }\n\n    TR(TRACE_ATTRS, (\"setting colors: pair = %d, fg = %d, bg = %d\", pair,\n\t\t     fg, bg));\n\n    if (!isDefaultColor(fg)) {\n\tset_foreground_color(NCURSES_SP_ARGx fg, outc);\n    }\n    if (!isDefaultColor(bg)) {\n\tset_background_color(NCURSES_SP_ARGx bg, outc);\n    }\n#endif\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_do_color(int old_pair, int pair, int reverse, NCURSES_OUTC outc)\n{\n    SetSafeOutcWrapper(outc);\n    NCURSES_SP_NAME(_nc_do_color) (CURRENT_SCREEN,\n\t\t\t\t   old_pair,\n\t\t\t\t   pair,\n\t\t\t\t   reverse,\n\t\t\t\t   _nc_outc_wrapper);\n}\n#endif\n\n#if USE_EXTENDED_COLORS\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(init_extended_pair) (NCURSES_SP_DCLx int pair, int f, int b)\n{\n    return _nc_init_pair(SP_PARM, pair, f, b);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(init_extended_color) (NCURSES_SP_DCLx\n\t\t\t\t      int color,\n\t\t\t\t      int r, int g, int b)\n{\n    return _nc_init_color(SP_PARM, color, r, g, b);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx\n\t\t\t\t\t int color,\n\t\t\t\t\t int *r, int *g, int *b)\n{\n    return _nc_color_content(SP_PARM, color, r, g, b);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(extended_pair_content) (NCURSES_SP_DCLx\n\t\t\t\t\tint pair,\n\t\t\t\t\tint *f, int *b)\n{\n    return _nc_pair_content(SP_PARM, pair, f, b);\n}\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(reset_color_pairs) (NCURSES_SP_DCL0)\n{\n    if (SP_PARM != 0) {\n\tif (SP_PARM->_color_pairs) {\n\t    _nc_free_ordered_pairs(SP_PARM);\n\t    free(SP_PARM->_color_pairs);\n\t    SP_PARM->_color_pairs = 0;\n\t    SP_PARM->_pair_alloc = 0;\n\t    _nc_reserve_pairs(SP_PARM, 16);\n\t    clearok(CurScreen(SP_PARM), TRUE);\n\t    touchwin(StdScreen(SP_PARM));\n\t}\n    }\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ninit_extended_pair(int pair, int f, int b)\n{\n    return NCURSES_SP_NAME(init_extended_pair) (CURRENT_SCREEN, pair, f, b);\n}\n\nNCURSES_EXPORT(int)\ninit_extended_color(int color, int r, int g, int b)\n{\n    return NCURSES_SP_NAME(init_extended_color) (CURRENT_SCREEN,\n\t\t\t\t\t\t color,\n\t\t\t\t\t\t r, g, b);\n}\n\nNCURSES_EXPORT(int)\nextended_color_content(int color, int *r, int *g, int *b)\n{\n    return NCURSES_SP_NAME(extended_color_content) (CURRENT_SCREEN,\n\t\t\t\t\t\t    color,\n\t\t\t\t\t\t    r, g, b);\n}\n\nNCURSES_EXPORT(int)\nextended_pair_content(int pair, int *f, int *b)\n{\n    return NCURSES_SP_NAME(extended_pair_content) (CURRENT_SCREEN, pair, f, b);\n}\n\nNCURSES_EXPORT(void)\nreset_color_pairs(void)\n{\n    NCURSES_SP_NAME(reset_color_pairs) (CURRENT_SCREEN);\n}\n#endif /* NCURSES_SP_FUNCS */\n#endif /* USE_EXTENDED_COLORS */\n","/****************************************************************************\n * Copyright (c) 1998-2008,2009 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n *\techo.c\n *\n *\tRoutines:\n *\t\techo()\n *\t\tnoecho()\n *\n */\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_echo.c,v 1.8 2009/10/24 22:02:14 tom Exp $\")\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(echo) (NCURSES_SP_DCL0)\n{\n    T((T_CALLED(\"echo(%p)\"), (void *) SP_PARM));\n    if (0 == SP_PARM)\n\treturnCode(ERR);\n    SP_PARM->_echo = TRUE;\n    returnCode(OK);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\necho(void)\n{\n    return NCURSES_SP_NAME(echo) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(noecho) (NCURSES_SP_DCL0)\n{\n    T((T_CALLED(\"noecho(%p)\"), (void *) SP_PARM));\n    if (0 == SP_PARM)\n\treturnCode(ERR);\n    SP_PARM->_echo = FALSE;\n    returnCode(OK);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nnoecho(void)\n{\n    return NCURSES_SP_NAME(noecho) (CURRENT_SCREEN);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2014,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n**\tlib_endwin.c\n**\n**\tThe routine endwin().\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_endwin.c,v 1.24 2017/07/22 23:29:40 tom Exp $\")\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(endwin) (NCURSES_SP_DCL0)\n{\n    int code = ERR;\n\n    T((T_CALLED(\"endwin(%p)\"), (void *) SP_PARM));\n\n    if (SP_PARM) {\n#ifdef USE_TERM_DRIVER\n\tTERMINAL_CONTROL_BLOCK *TCB = TCBOf(SP_PARM);\n\n\tSP_PARM->_endwin = ewSuspend;\n\tif (TCB && TCB->drv && TCB->drv->td_scexit)\n\t    TCB->drv->td_scexit(SP_PARM);\n#else\n\tSP_PARM->_endwin = ewSuspend;\n\tSP_PARM->_mouse_wrap(SP_PARM);\n\t_nc_screen_wrap();\n\t_nc_mvcur_wrap();\t/* wrap up cursor addressing */\n#endif\n\tcode = NCURSES_SP_NAME(reset_shell_mode) (NCURSES_SP_ARG);\n    }\n\n    returnCode(code);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nendwin(void)\n{\n    return NCURSES_SP_NAME(endwin) (CURRENT_SCREEN);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2015,2016 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n**\tlib_getch.c\n**\n**\tThe routine getch().\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_getch.c,v 1.136 2016/09/10 21:59:16 tom Exp $\")\n\n#include <fifo_defs.h>\n\n#if USE_REENTRANT\n#define GetEscdelay(sp) *_nc_ptr_Escdelay(sp)\nNCURSES_EXPORT(int)\nNCURSES_PUBLIC_VAR(ESCDELAY) (void)\n{\n    return *(_nc_ptr_Escdelay(CURRENT_SCREEN));\n}\n\nNCURSES_EXPORT(int *)\n_nc_ptr_Escdelay(SCREEN *sp)\n{\n    return ptrEscdelay(sp);\n}\n#else\n#define GetEscdelay(sp) ESCDELAY\nNCURSES_EXPORT_VAR(int) ESCDELAY = 1000;\n#endif\n\n#if NCURSES_EXT_FUNCS\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(set_escdelay) (NCURSES_SP_DCLx int value)\n{\n    int code = OK;\n#if USE_REENTRANT\n    if (SP_PARM) {\n\tSET_ESCDELAY(value);\n    } else {\n\tcode = ERR;\n    }\n#else\n    (void) SP_PARM;\n    ESCDELAY = value;\n#endif\n    return code;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nset_escdelay(int value)\n{\n    int code;\n#if USE_REENTRANT\n    code = NCURSES_SP_NAME(set_escdelay) (CURRENT_SCREEN, value);\n#else\n    ESCDELAY = value;\n    code = OK;\n#endif\n    return code;\n}\n#endif\n#endif /* NCURSES_EXT_FUNCS */\n\n#if NCURSES_EXT_FUNCS\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(get_escdelay) (NCURSES_SP_DCL0)\n{\n#if !USE_REENTRANT\n    (void) SP_PARM;\n#endif\n    return GetEscdelay(SP_PARM);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nget_escdelay(void)\n{\n    return NCURSES_SP_NAME(get_escdelay) (CURRENT_SCREEN);\n}\n#endif\n#endif /* NCURSES_EXT_FUNCS */\n\nstatic int\n_nc_use_meta(WINDOW *win)\n{\n    SCREEN *sp = _nc_screen_of(win);\n    return (sp ? sp->_use_meta : 0);\n}\n\n#ifdef USE_TERM_DRIVER\n# ifdef __MINGW32__\nstatic HANDLE\n_nc_get_handle(int fd)\n{\n    intptr_t value = _get_osfhandle(fd);\n    return (HANDLE) value;\n}\n# endif\n#endif\n\n/*\n * Check for mouse activity, returning nonzero if we find any.\n */\nstatic int\ncheck_mouse_activity(SCREEN *sp, int delay EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    int rc;\n\n#ifdef USE_TERM_DRIVER\n    TERMINAL_CONTROL_BLOCK *TCB = TCBOf(sp);\n    rc = TCBOf(sp)->drv->td_testmouse(TCBOf(sp), delay EVENTLIST_2nd(evl));\n# ifdef __MINGW32__\n    /* if we emulate terminfo on console, we have to use the console routine */\n    if (IsTermInfoOnConsole(sp)) {\n\tHANDLE fd = _nc_get_handle(sp->_ifd);\n\trc = _nc_mingw_testmouse(sp, fd, delay EVENTLIST_2nd(evl));\n    } else\n# endif\n\trc = TCB->drv->td_testmouse(TCB, delay EVENTLIST_2nd(evl));\n#else\n#if USE_SYSMOUSE\n    if ((sp->_mouse_type == M_SYSMOUSE)\n\t&& (sp->_sysmouse_head < sp->_sysmouse_tail)) {\n\trc = TW_MOUSE;\n    } else\n#endif\n    {\n\trc = _nc_timed_wait(sp,\n\t\t\t    TWAIT_MASK,\n\t\t\t    delay,\n\t\t\t    (int *) 0\n\t\t\t    EVENTLIST_2nd(evl));\n#if USE_SYSMOUSE\n\tif ((sp->_mouse_type == M_SYSMOUSE)\n\t    && (sp->_sysmouse_head < sp->_sysmouse_tail)\n\t    && (rc == 0)\n\t    && (errno == EINTR)) {\n\t    rc |= TW_MOUSE;\n\t}\n#endif\n    }\n#endif\n    return rc;\n}\n\nstatic NCURSES_INLINE int\nfifo_peek(SCREEN *sp)\n{\n    int ch = (peek >= 0) ? sp->_fifo[peek] : ERR;\n    TR(TRACE_IEVENT, (\"peeking at %d\", peek));\n\n    p_inc();\n    return ch;\n}\n\nstatic NCURSES_INLINE int\nfifo_pull(SCREEN *sp)\n{\n    int ch = (head >= 0) ? sp->_fifo[head] : ERR;\n\n    TR(TRACE_IEVENT, (\"pulling %s from %d\", _nc_tracechar(sp, ch), head));\n\n    if (peek == head) {\n\th_inc();\n\tpeek = head;\n    } else {\n\th_inc();\n    }\n\n#ifdef TRACE\n    if (USE_TRACEF(TRACE_IEVENT)) {\n\t_nc_fifo_dump(sp);\n\t_nc_unlock_global(tracef);\n    }\n#endif\n    return ch;\n}\n\nstatic NCURSES_INLINE int\nfifo_push(SCREEN *sp EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    int n;\n    int ch = 0;\n    int mask = 0;\n\n    (void) mask;\n    if (tail < 0)\n\treturn ERR;\n\n#ifdef NCURSES_WGETCH_EVENTS\n    if (evl\n#if USE_GPM_SUPPORT || USE_EMX_MOUSE || USE_SYSMOUSE\n\t|| (sp->_mouse_fd >= 0)\n#endif\n\t) {\n\tmask = check_mouse_activity(sp, -1 EVENTLIST_2nd(evl));\n    } else\n\tmask = 0;\n\n    if (mask & TW_EVENT) {\n\tT((\"fifo_push: ungetch KEY_EVENT\"));\n\tsafe_ungetch(sp, KEY_EVENT);\n\treturn KEY_EVENT;\n    }\n#elif USE_GPM_SUPPORT || USE_EMX_MOUSE || USE_SYSMOUSE\n    if (sp->_mouse_fd >= 0) {\n\tmask = check_mouse_activity(sp, -1 EVENTLIST_2nd(evl));\n    }\n#endif\n\n#if USE_GPM_SUPPORT || USE_EMX_MOUSE\n    if ((sp->_mouse_fd >= 0) && (mask & TW_MOUSE)) {\n\tsp->_mouse_event(sp);\n\tch = KEY_MOUSE;\n\tn = 1;\n    } else\n#endif\n#if USE_SYSMOUSE\n\tif ((sp->_mouse_type == M_SYSMOUSE)\n\t    && (sp->_sysmouse_head < sp->_sysmouse_tail)) {\n\tsp->_mouse_event(sp);\n\tch = KEY_MOUSE;\n\tn = 1;\n    } else if ((sp->_mouse_type == M_SYSMOUSE)\n\t       && (mask <= 0) && errno == EINTR) {\n\tsp->_mouse_event(sp);\n\tch = KEY_MOUSE;\n\tn = 1;\n    } else\n#endif\n#ifdef USE_TERM_DRIVER\n\tif ((sp->_mouse_type == M_TERM_DRIVER)\n\t    && (sp->_drv_mouse_head < sp->_drv_mouse_tail)) {\n\tsp->_mouse_event(sp);\n\tch = KEY_MOUSE;\n\tn = 1;\n    } else\n#endif\n#if USE_KLIBC_KBD\n    if (NC_ISATTY(sp->_ifd) && sp->_cbreak) {\n\tch = _read_kbd(0, 1, !sp->_raw);\n\tn = (ch == -1) ? -1 : 1;\n\tsp->_extended_key = (ch == 0);\n    } else\n#endif\n    {\t\t\t\t/* Can block... */\n#ifdef USE_TERM_DRIVER\n\tint buf;\n#ifdef __MINGW32__\n\tif (NC_ISATTY(sp->_ifd) && IsTermInfoOnConsole(sp) && sp->_cbreak)\n\t    n = _nc_mingw_console_read(sp,\n\t\t\t\t       _nc_get_handle(sp->_ifd),\n\t\t\t\t       &buf);\n\telse\n#endif\n\t    n = CallDriver_1(sp, td_read, &buf);\n\tch = buf;\n#else\n\tunsigned char c2 = 0;\n# if USE_PTHREADS_EINTR\n#  if USE_WEAK_SYMBOLS\n\tif ((pthread_self) && (pthread_kill) && (pthread_equal))\n#  endif\n\t    _nc_globals.read_thread = pthread_self();\n# endif\n\tn = (int) read(sp->_ifd, &c2, (size_t) 1);\n#if USE_PTHREADS_EINTR\n\t_nc_globals.read_thread = 0;\n#endif\n\tch = c2;\n#endif\n    }\n\n    if ((n == -1) || (n == 0)) {\n\tTR(TRACE_IEVENT, (\"read(%d,&ch,1)=%d, errno=%d\", sp->_ifd, n, errno));\n\tch = ERR;\n    }\n    TR(TRACE_IEVENT, (\"read %d characters\", n));\n\n    sp->_fifo[tail] = ch;\n    sp->_fifohold = 0;\n    if (head == -1)\n\thead = peek = tail;\n    t_inc();\n    TR(TRACE_IEVENT, (\"pushed %s at %d\", _nc_tracechar(sp, ch), tail));\n#ifdef TRACE\n    if (USE_TRACEF(TRACE_IEVENT)) {\n\t_nc_fifo_dump(sp);\n\t_nc_unlock_global(tracef);\n    }\n#endif\n    return ch;\n}\n\nstatic NCURSES_INLINE void\nfifo_clear(SCREEN *sp)\n{\n    memset(sp->_fifo, 0, sizeof(sp->_fifo));\n    head = -1;\n    tail = peek = 0;\n}\n\nstatic int kgetch(SCREEN *, bool EVENTLIST_2nd(_nc_eventlist *));\n\nstatic void\nrecur_wrefresh(WINDOW *win)\n{\n#ifdef USE_PTHREADS\n    SCREEN *sp = _nc_screen_of(win);\n    if (_nc_use_pthreads && sp != CURRENT_SCREEN) {\n\tSCREEN *save_SP;\n\n\t/* temporarily switch to the window's screen to check/refresh */\n\t_nc_lock_global(curses);\n\tsave_SP = CURRENT_SCREEN;\n\t_nc_set_screen(sp);\n\trecur_wrefresh(win);\n\t_nc_set_screen(save_SP);\n\t_nc_unlock_global(curses);\n    } else\n#endif\n\tif ((is_wintouched(win) || (win->_flags & _HASMOVED))\n\t    && !(win->_flags & _ISPAD)) {\n\twrefresh(win);\n    }\n}\n\nstatic int\nrecur_wgetnstr(WINDOW *win, char *buf)\n{\n    SCREEN *sp = _nc_screen_of(win);\n    int rc;\n\n    if (sp != 0) {\n#ifdef USE_PTHREADS\n\tif (_nc_use_pthreads && sp != CURRENT_SCREEN) {\n\t    SCREEN *save_SP;\n\n\t    /* temporarily switch to the window's screen to get cooked input */\n\t    _nc_lock_global(curses);\n\t    save_SP = CURRENT_SCREEN;\n\t    _nc_set_screen(sp);\n\t    rc = recur_wgetnstr(win, buf);\n\t    _nc_set_screen(save_SP);\n\t    _nc_unlock_global(curses);\n\t} else\n#endif\n\t{\n\t    sp->_called_wgetch = TRUE;\n\t    rc = wgetnstr(win, buf, MAXCOLUMNS);\n\t    sp->_called_wgetch = FALSE;\n\t}\n    } else {\n\trc = ERR;\n    }\n    return rc;\n}\n\nNCURSES_EXPORT(int)\n_nc_wgetch(WINDOW *win,\n\t   int *result,\n\t   int use_meta\n\t   EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    SCREEN *sp;\n    int ch;\n    int rc = 0;\n#ifdef NCURSES_WGETCH_EVENTS\n    int event_delay = -1;\n#endif\n\n    T((T_CALLED(\"_nc_wgetch(%p)\"), (void *) win));\n\n    *result = 0;\n\n    sp = _nc_screen_of(win);\n    if (win == 0 || sp == 0) {\n\treturnCode(ERR);\n    }\n\n    if (cooked_key_in_fifo()) {\n\trecur_wrefresh(win);\n\t*result = fifo_pull(sp);\n\treturnCode(*result >= KEY_MIN ? KEY_CODE_YES : OK);\n    }\n#ifdef NCURSES_WGETCH_EVENTS\n    if (evl && (evl->count == 0))\n\tevl = NULL;\n    event_delay = _nc_eventlist_timeout(evl);\n#endif\n\n    /*\n     * Handle cooked mode.  Grab a string from the screen,\n     * stuff its contents in the FIFO queue, and pop off\n     * the first character to return it.\n     */\n    if (head == -1 &&\n\t!sp->_notty &&\n\t!sp->_raw &&\n\t!sp->_cbreak &&\n\t!sp->_called_wgetch) {\n\tchar buf[MAXCOLUMNS], *bufp;\n\n\tTR(TRACE_IEVENT, (\"filling queue in cooked mode\"));\n\n\t/* ungetch in reverse order */\n#ifdef NCURSES_WGETCH_EVENTS\n\trc = recur_wgetnstr(win, buf);\n\tif (rc != KEY_EVENT && rc != ERR)\n\t    safe_ungetch(sp, '\\n');\n#else\n\tif (recur_wgetnstr(win, buf) != ERR)\n\t    safe_ungetch(sp, '\\n');\n#endif\n\tfor (bufp = buf + strlen(buf); bufp > buf; bufp--)\n\t    safe_ungetch(sp, bufp[-1]);\n\n#ifdef NCURSES_WGETCH_EVENTS\n\t/* Return it first */\n\tif (rc == KEY_EVENT) {\n\t    *result = rc;\n\t} else\n#endif\n\t    *result = fifo_pull(sp);\n\treturnCode(*result >= KEY_MIN ? KEY_CODE_YES : OK);\n    }\n\n    if (win->_use_keypad != sp->_keypad_on)\n\t_nc_keypad(sp, win->_use_keypad);\n\n    recur_wrefresh(win);\n\n    if (win->_notimeout || (win->_delay >= 0) || (sp->_cbreak > 1)) {\n\tif (head == -1) {\t/* fifo is empty */\n\t    int delay;\n\n\t    TR(TRACE_IEVENT, (\"timed delay in wgetch()\"));\n\t    if (sp->_cbreak > 1)\n\t\tdelay = (sp->_cbreak - 1) * 100;\n\t    else\n\t\tdelay = win->_delay;\n\n#ifdef NCURSES_WGETCH_EVENTS\n\t    if (event_delay >= 0 && delay > event_delay)\n\t\tdelay = event_delay;\n#endif\n\n\t    TR(TRACE_IEVENT, (\"delay is %d milliseconds\", delay));\n\n\t    rc = check_mouse_activity(sp, delay EVENTLIST_2nd(evl));\n\n#ifdef NCURSES_WGETCH_EVENTS\n\t    if (rc & TW_EVENT) {\n\t\t*result = KEY_EVENT;\n\t\treturnCode(KEY_CODE_YES);\n\t    }\n#endif\n\t    if (!rc) {\n\t\tgoto check_sigwinch;\n\t    }\n\t}\n\t/* else go on to read data available */\n    }\n\n    if (win->_use_keypad) {\n\t/*\n\t * This is tricky.  We only want to get special-key\n\t * events one at a time.  But we want to accumulate\n\t * mouse events until either (a) the mouse logic tells\n\t * us it's picked up a complete gesture, or (b)\n\t * there's a detectable time lapse after one.\n\t *\n\t * Note: if the mouse code starts failing to compose\n\t * press/release events into clicks, you should probably\n\t * increase the wait with mouseinterval().\n\t */\n\tint runcount = 0;\n\n\tdo {\n\t    ch = kgetch(sp, win->_notimeout EVENTLIST_2nd(evl));\n\t    if (ch == KEY_MOUSE) {\n\t\t++runcount;\n\t\tif (sp->_mouse_inline(sp))\n\t\t    break;\n\t    }\n\t    if (sp->_maxclick < 0)\n\t\tbreak;\n\t} while\n\t    (ch == KEY_MOUSE\n\t     && (((rc = check_mouse_activity(sp, sp->_maxclick\n\t\t\t\t\t     EVENTLIST_2nd(evl))) != 0\n\t\t  && !(rc & TW_EVENT))\n\t\t || !sp->_mouse_parse(sp, runcount)));\n#ifdef NCURSES_WGETCH_EVENTS\n\tif ((rc & TW_EVENT) && !(ch == KEY_EVENT)) {\n\t    safe_ungetch(sp, ch);\n\t    ch = KEY_EVENT;\n\t}\n#endif\n\tif (runcount > 0 && ch != KEY_MOUSE) {\n#ifdef NCURSES_WGETCH_EVENTS\n\t    /* mouse event sequence ended by an event, report event */\n\t    if (ch == KEY_EVENT) {\n\t\tsafe_ungetch(sp, KEY_MOUSE);\t/* FIXME This interrupts a gesture... */\n\t    } else\n#endif\n\t    {\n\t\t/* mouse event sequence ended by keystroke, store keystroke */\n\t\tsafe_ungetch(sp, ch);\n\t\tch = KEY_MOUSE;\n\t    }\n\t}\n    } else {\n\tif (head == -1)\n\t    fifo_push(sp EVENTLIST_2nd(evl));\n\tch = fifo_pull(sp);\n    }\n\n    if (ch == ERR) {\n      check_sigwinch:\n#if USE_SIZECHANGE\n\tif (_nc_handle_sigwinch(sp)) {\n\t    _nc_update_screensize(sp);\n\t    /* resizeterm can push KEY_RESIZE */\n\t    if (cooked_key_in_fifo()) {\n\t\t*result = fifo_pull(sp);\n\t\t/*\n\t\t * Get the ERR from queue -- it is from WINCH,\n\t\t * so we should take it out, the \"error\" is handled.\n\t\t */\n\t\tif (fifo_peek(sp) == -1)\n\t\t    fifo_pull(sp);\n\t\treturnCode(*result >= KEY_MIN ? KEY_CODE_YES : OK);\n\t    }\n\t}\n#endif\n\treturnCode(ERR);\n    }\n\n    /*\n     * If echo() is in effect, display the printable version of the\n     * key on the screen.  Carriage return and backspace are treated\n     * specially by Solaris curses:\n     *\n     * If carriage return is defined as a function key in the\n     * terminfo, e.g., kent, then Solaris may return either ^J (or ^M\n     * if nonl() is set) or KEY_ENTER depending on the echo() mode.\n     * We echo before translating carriage return based on nonl(),\n     * since the visual result simply moves the cursor to column 0.\n     *\n     * Backspace is a different matter.  Solaris curses does not\n     * translate it to KEY_BACKSPACE if kbs=^H.  This does not depend\n     * on the stty modes, but appears to be a hardcoded special case.\n     * This is a difference from ncurses, which uses the terminfo entry.\n     * However, we provide the same visual result as Solaris, moving the\n     * cursor to the left.\n     */\n    if (sp->_echo && !(win->_flags & _ISPAD)) {\n\tchtype backup = (chtype) ((ch == KEY_BACKSPACE) ? '\\b' : ch);\n\tif (backup < KEY_MIN)\n\t    wechochar(win, backup);\n    }\n\n    /*\n     * Simulate ICRNL mode\n     */\n    if ((ch == '\\r') && sp->_nl)\n\tch = '\\n';\n\n    /* Strip 8th-bit if so desired.  We do this only for characters that\n     * are in the range 128-255, to provide compatibility with terminals\n     * that display only 7-bit characters.  Note that 'ch' may be a\n     * function key at this point, so we mustn't strip _those_.\n     */\n    if (!use_meta)\n\tif ((ch < KEY_MIN) && (ch & 0x80))\n\t    ch &= 0x7f;\n\n    T((\"wgetch returning : %s\", _nc_tracechar(sp, ch)));\n\n    *result = ch;\n    returnCode(ch >= KEY_MIN ? KEY_CODE_YES : OK);\n}\n\n#ifdef NCURSES_WGETCH_EVENTS\nNCURSES_EXPORT(int)\nwgetch_events(WINDOW *win, _nc_eventlist * evl)\n{\n    int code;\n    int value;\n\n    T((T_CALLED(\"wgetch_events(%p,%p)\"), (void *) win, (void *) evl));\n    code = _nc_wgetch(win,\n\t\t      &value,\n\t\t      _nc_use_meta(win)\n\t\t      EVENTLIST_2nd(evl));\n    if (code != ERR)\n\tcode = value;\n    returnCode(code);\n}\n#endif\n\nNCURSES_EXPORT(int)\nwgetch(WINDOW *win)\n{\n    int code;\n    int value;\n\n    T((T_CALLED(\"wgetch(%p)\"), (void *) win));\n    code = _nc_wgetch(win,\n\t\t      &value,\n\t\t      _nc_use_meta(win)\n\t\t      EVENTLIST_2nd((_nc_eventlist *) 0));\n    if (code != ERR)\n\tcode = value;\n    returnCode(code);\n}\n\n/*\n**      int\n**      kgetch()\n**\n**      Get an input character, but take care of keypad sequences, returning\n**      an appropriate code when one matches the input.  After each character\n**      is received, set an alarm call based on ESCDELAY.  If no more of the\n**      sequence is received by the time the alarm goes off, pass through\n**      the sequence gotten so far.\n**\n**\tThis function must be called when there are no cooked keys in queue.\n**\t(that is head==-1 || peek==head)\n**\n*/\n\nstatic int\nkgetch(SCREEN *sp, bool forever EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    TRIES *ptr;\n    int ch = 0;\n    int timeleft = forever ? 9999999 : GetEscdelay(sp);\n\n    TR(TRACE_IEVENT, (\"kgetch() called\"));\n\n    ptr = sp->_keytry;\n\n    for (;;) {\n\tif (cooked_key_in_fifo() && sp->_fifo[head] >= KEY_MIN) {\n\t    break;\n\t} else if (!raw_key_in_fifo()) {\n\t    ch = fifo_push(sp EVENTLIST_2nd(evl));\n\t    if (ch == ERR) {\n\t\tpeek = head;\t/* the keys stay uninterpreted */\n\t\treturn ERR;\n\t    }\n#ifdef NCURSES_WGETCH_EVENTS\n\t    else if (ch == KEY_EVENT) {\n\t\tpeek = head;\t/* the keys stay uninterpreted */\n\t\treturn fifo_pull(sp);\t/* Remove KEY_EVENT from the queue */\n\t    }\n#endif\n\t}\n\n\tch = fifo_peek(sp);\n\tif (ch >= KEY_MIN) {\n\t    /* If not first in queue, somebody put this key there on purpose in\n\t     * emergency.  Consider it higher priority than the unfinished\n\t     * keysequence we are parsing.\n\t     */\n\t    peek = head;\n\t    /* assume the key is the last in fifo */\n\t    t_dec();\t\t/* remove the key */\n\t    return ch;\n\t}\n\n\tTR(TRACE_IEVENT, (\"ch: %s\", _nc_tracechar(sp, (unsigned char) ch)));\n\twhile ((ptr != NULL) && (ptr->ch != (unsigned char) ch))\n\t    ptr = ptr->sibling;\n\n\tif (ptr == NULL) {\n\t    TR(TRACE_IEVENT, (\"ptr is null\"));\n\t    break;\n\t}\n\tTR(TRACE_IEVENT, (\"ptr=%p, ch=%d, value=%d\",\n\t\t\t  (void *) ptr, ptr->ch, ptr->value));\n\n\tif (ptr->value != 0) {\t/* sequence terminated */\n\t    TR(TRACE_IEVENT, (\"end of sequence\"));\n\t    if (peek == tail) {\n\t\tfifo_clear(sp);\n\t    } else {\n\t\thead = peek;\n\t    }\n\t    return (ptr->value);\n\t}\n\n\tptr = ptr->child;\n\n\tif (!raw_key_in_fifo()) {\n\t    int rc;\n\n\t    TR(TRACE_IEVENT, (\"waiting for rest of sequence\"));\n\t    rc = check_mouse_activity(sp, timeleft EVENTLIST_2nd(evl));\n#ifdef NCURSES_WGETCH_EVENTS\n\t    if (rc & TW_EVENT) {\n\t\tTR(TRACE_IEVENT, (\"interrupted by a user event\"));\n\t\t/* FIXME Should have preserved remainder timeleft for reuse... */\n\t\tpeek = head;\t/* Restart interpreting later */\n\t\treturn KEY_EVENT;\n\t    }\n#endif\n\t    if (!rc) {\n\t\tTR(TRACE_IEVENT, (\"ran out of time\"));\n\t\tbreak;\n\t    }\n\t}\n    }\n    ch = fifo_pull(sp);\n    peek = head;\n    return ch;\n}\n","/****************************************************************************\n * Copyright (c) 1998-2011,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n ****************************************************************************/\n\n/*\n**\tlib_getstr.c\n**\n**\tThe routine wgetstr().\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_getstr.c,v 1.31 2017/03/25 21:09:51 tom Exp $\")\n\n/*\n * This wipes out the last character, no matter whether it was a tab, control\n * or other character, and handles reverse wraparound.\n */\nstatic char *\nWipeOut(WINDOW *win, int y, int x, char *first, char *last, int echoed)\n{\n    if (last > first) {\n\t*--last = '\\0';\n\tif (echoed) {\n\t    int y1 = win->_cury;\n\t    int x1 = win->_curx;\n\n\t    wmove(win, y, x);\n\t    waddstr(win, first);\n\t    getyx(win, y, x);\n\t    while (win->_cury < y1\n\t\t   || (win->_cury == y1 && win->_curx < x1))\n\t\twaddch(win, (chtype) ' ');\n\n\t    wmove(win, y, x);\n\t}\n    }\n    return last;\n}\n\nNCURSES_EXPORT(int)\nwgetnstr_events(WINDOW *win,\n\t\tchar *str,\n\t\tint maxlen,\n\t\tEVENTLIST_1st(_nc_eventlist * evl))\n{\n    SCREEN *sp = _nc_screen_of(win);\n    TTY buf;\n    bool oldnl, oldecho, oldraw, oldcbreak;\n    char erasec;\n    char killc;\n    char *oldstr;\n    int ch;\n    int y, x;\n\n    T((T_CALLED(\"wgetnstr(%p,%p,%d)\"), (void *) win, (void *) str, maxlen));\n\n    if (!win || !str)\n\treturnCode(ERR);\n\n    NCURSES_SP_NAME(_nc_get_tty_mode) (NCURSES_SP_ARGx &buf);\n\n    oldnl = sp->_nl;\n    oldecho = sp->_echo;\n    oldraw = sp->_raw;\n    oldcbreak = sp->_cbreak;\n    NCURSES_SP_NAME(nl) (NCURSES_SP_ARG);\n    NCURSES_SP_NAME(noecho) (NCURSES_SP_ARG);\n    NCURSES_SP_NAME(noraw) (NCURSES_SP_ARG);\n    NCURSES_SP_NAME(cbreak) (NCURSES_SP_ARG);\n\n    erasec = NCURSES_SP_NAME(erasechar) (NCURSES_SP_ARG);\n    killc = NCURSES_SP_NAME(killchar) (NCURSES_SP_ARG);\n\n    oldstr = str;\n    getyx(win, y, x);\n\n    if (is_wintouched(win) || (win->_flags & _HASMOVED))\n\twrefresh(win);\n\n    while ((ch = wgetch_events(win, evl)) != ERR) {\n\t/*\n\t * Some terminals (the Wyse-50 is the most common) generate\n\t * a \\n from the down-arrow key.  With this logic, it's the\n\t * user's choice whether to set kcud=\\n for wgetch();\n\t * terminating *getstr() with \\n should work either way.\n\t */\n\tif (ch == '\\n'\n\t    || ch == '\\r'\n\t    || ch == KEY_DOWN\n\t    || ch == KEY_ENTER) {\n\t    if (oldecho == TRUE\n\t\t&& win->_cury == win->_maxy\n\t\t&& win->_scroll)\n\t\twechochar(win, (chtype) '\\n');\n\t    break;\n\t}\n#ifdef KEY_EVENT\n\tif (ch == KEY_EVENT)\n\t    break;\n#endif\n#ifdef KEY_RESIZE\n\tif (ch == KEY_RESIZE)\n\t    break;\n#endif\n\tif (ch == erasec || ch == KEY_LEFT || ch == KEY_BACKSPACE) {\n\t    if (str > oldstr) {\n\t\tstr = WipeOut(win, y, x, oldstr, str, oldecho);\n\t    }\n\t} else if (ch == killc) {\n\t    while (str > oldstr) {\n\t\tstr = WipeOut(win, y, x, oldstr, str, oldecho);\n\t    }\n\t} else if (ch >= KEY_MIN\n\t\t   || (maxlen >= 0 && str - oldstr >= maxlen)) {\n\t    NCURSES_SP_NAME(beep) (NCURSES_SP_ARG);\n\t} else {\n\t    *str++ = (char) ch;\n\t    if (oldecho == TRUE) {\n\t\tint oldy = win->_cury;\n\t\tif (waddch(win, (chtype) ch) == ERR) {\n\t\t    /*\n\t\t     * We can't really use the lower-right\n\t\t     * corner for input, since it'll mess\n\t\t     * up bookkeeping for erases.\n\t\t     */\n\t\t    win->_flags &= ~_WRAPPED;\n\t\t    waddch(win, (chtype) ' ');\n\t\t    str = WipeOut(win, y, x, oldstr, str, oldecho);\n\t\t    continue;\n\t\t} else if (win->_flags & _WRAPPED) {\n\t\t    /*\n\t\t     * If the last waddch forced a wrap &\n\t\t     * scroll, adjust our reference point\n\t\t     * for erasures.\n\t\t     */\n\t\t    if (win->_scroll\n\t\t\t&& oldy == win->_maxy\n\t\t\t&& win->_cury == win->_maxy) {\n\t\t\tif (--y <= 0) {\n\t\t\t    y = 0;\n\t\t\t}\n\t\t    }\n\t\t    win->_flags &= ~_WRAPPED;\n\t\t}\n\t\twrefresh(win);\n\t    }\n\t}\n    }\n\n    win->_curx = 0;\n    win->_flags &= ~_WRAPPED;\n    if (win->_cury < win->_maxy)\n\twin->_cury++;\n    wrefresh(win);\n\n    /* Restore with a single I/O call, to fix minor asymmetry between\n     * raw/noraw, etc.\n     */\n    sp->_nl = oldnl;\n    sp->_echo = oldecho;\n    sp->_raw = oldraw;\n    sp->_cbreak = oldcbreak;\n\n    NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n\n    *str = '\\0';\n    if (ch == ERR)\n\treturnCode(ch);\n\n    T((\"wgetnstr returns %s\", _nc_visbuf(oldstr)));\n\n#ifdef KEY_EVENT\n    if (ch == KEY_EVENT)\n\treturnCode(ch);\n#endif\n#ifdef KEY_RESIZE\n    if (ch == KEY_RESIZE)\n\treturnCode(ch);\n#endif\n\n    returnCode(OK);\n}\n\n#ifdef NCURSES_WGETCH_EVENTS\nNCURSES_EXPORT(int)\nwgetnstr(WINDOW *win, char *str, int maxlen)\n{\n    returnCode(wgetnstr_events(win,\n\t\t\t       str,\n\t\t\t       maxlen,\n\t\t\t       EVENTLIST_1st((_nc_eventlist *) 0)));\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-2003               *\n ****************************************************************************/\n\n/*\n**\tlib_initscr.c\n**\n**\tThe routines initscr(), and termname().\n**\n*/\n\n#include <curses.priv.h>\n\n#if HAVE_SYS_TERMIO_H\n#include <sys/termio.h>\t\t/* needed for ISC */\n#endif\n\nMODULE_ID(\"$Id: lib_initscr.c,v 1.43 2017/06/17 18:42:45 tom Exp $\")\n\nNCURSES_EXPORT(WINDOW *)\ninitscr(void)\n{\n    WINDOW *result;\n\n    START_TRACE();\n    T((T_CALLED(\"initscr()\")));\n\n    _nc_init_pthreads();\n    _nc_lock_global(curses);\n\n    /* Portable applications must not call initscr() more than once */\n    if (!_nc_globals.init_screen) {\n\tNCURSES_CONST char *name;\n\n\t_nc_globals.init_screen = TRUE;\n\n\tif ((name = getenv(\"TERM\")) == 0\n\t    || *name == '\\0') {\n\t    static char unknown_name[] = \"unknown\";\n\t    name = unknown_name;\n\t}\n#ifdef __CYGWIN__\n\t/*\n\t * 2002/9/21\n\t * Work around a bug in Cygwin.  Full-screen subprocesses run from\n\t * bash, in turn spawned from another full-screen process, will dump\n\t * core when attempting to write to stdout.  Opening /dev/tty\n\t * explicitly seems to fix the problem.\n\t */\n\tif (NC_ISATTY(fileno(stdout))) {\n\t    FILE *fp = fopen(\"/dev/tty\", \"w\");\n\t    if (fp != 0 && NC_ISATTY(fileno(fp))) {\n\t\tfclose(stdout);\n\t\tdup2(fileno(fp), STDOUT_FILENO);\n\t\tstdout = fdopen(STDOUT_FILENO, \"w\");\n\t    }\n\t}\n#endif\n\tif (newterm(name, stdout, stdin) == 0) {\n\t    fprintf(stderr, \"Error opening terminal: %s.\\n\", name);\n\t    ExitProgram(EXIT_FAILURE);\n\t}\n\n\t/* def_shell_mode - done in newterm/_nc_setupscreen */\n#if NCURSES_SP_FUNCS\n\tNCURSES_SP_NAME(def_prog_mode) (CURRENT_SCREEN);\n#else\n\tdef_prog_mode();\n#endif\n    }\n    result = stdscr;\n    _nc_unlock_global(curses);\n\n    returnWin(result);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2004,2009 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n ****************************************************************************/\n\n/*\n**\tlib_move.c\n**\n**\tThe routine wmove().\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_move.c,v 1.13 2009/10/24 22:34:07 tom Exp $\")\n\nNCURSES_EXPORT(int)\nwmove(WINDOW *win, int y, int x)\n{\n    T((T_CALLED(\"wmove(%p,%d,%d)\"), (void *) win, y, x));\n\n    if (LEGALYX(win, y, x)) {\n\twin->_curx = (NCURSES_SIZE_T) x;\n\twin->_cury = (NCURSES_SIZE_T) y;\n\n\twin->_flags &= ~_WRAPPED;\n\twin->_flags |= _HASMOVED;\n\treturnCode(OK);\n    } else\n\treturnCode(ERR);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n**\tlib_mvcur.c\n**\n**\tThe routines for moving the physical cursor and scrolling:\n**\n**\t\tvoid _nc_mvcur_init(void)\n**\n**\t\tvoid _nc_mvcur_resume(void)\n**\n**\t\tint mvcur(int old_y, int old_x, int new_y, int new_x)\n**\n**\t\tvoid _nc_mvcur_wrap(void)\n**\n** Comparisons with older movement optimizers:\n**    SVr3 curses mvcur() can't use cursor_to_ll or auto_left_margin.\n**    4.4BSD curses can't use cuu/cud/cuf/cub/hpa/vpa/tab/cbt for local\n** motions.  It doesn't use tactics based on auto_left_margin.  Weirdly\n** enough, it doesn't use its own hardware-scrolling routine to scroll up\n** destination lines for out-of-bounds addresses!\n**    old ncurses optimizer: less accurate cost computations (in fact,\n** it was broken and had to be commented out!).\n**\n** Compile with -DMAIN to build an interactive tester/timer for the movement\n** optimizer.  You can use it to investigate the optimizer's behavior.\n** You can also use it for tuning the formulas used to determine whether\n** or not full optimization is attempted.\n**\n** This code has a nasty tendency to find bugs in terminfo entries, because it\n** exercises the non-cup movement capabilities heavily.  If you think you've\n** found a bug, try deleting subsets of the following capabilities (arranged\n** in decreasing order of suspiciousness): it, tab, cbt, hpa, vpa, cuu, cud,\n** cuf, cub, cuu1, cud1, cuf1, cub1.  It may be that one or more are wrong.\n**\n** Note: you should expect this code to look like a resource hog in a profile.\n** That's because it does a lot of I/O, through the tputs() calls.  The I/O\n** cost swamps the computation overhead (and as machines get faster, this\n** will become even more true).  Comments in the test exerciser at the end\n** go into detail about tuning and how you can gauge the optimizer's\n** effectiveness.\n**/\n\n/****************************************************************************\n *\n * Constants and macros for optimizer tuning.\n *\n ****************************************************************************/\n\n/*\n * The average overhead of a full optimization computation in character\n * transmission times.  If it's too high, the algorithm will be a bit\n * over-biased toward using cup rather than local motions; if it's too\n * low, the algorithm may spend more time than is strictly optimal\n * looking for non-cup motions.  Profile the optimizer using the `t'\n * command of the exerciser (see below), and round to the nearest integer.\n *\n * Yes, I (esr) thought about computing expected overhead dynamically, say\n * by derivation from a running average of optimizer times.  But the\n * whole point of this optimization is to *decrease* the frequency of\n * system calls. :-)\n */\n#define COMPUTE_OVERHEAD\t1\t/* I use a 90MHz Pentium @ 9.6Kbps */\n\n/*\n * LONG_DIST is the distance we consider to be just as costly to move over as a\n * cup sequence is to emit.  In other words, it's the length of a cup sequence\n * adjusted for average computation overhead.  The magic number is the length\n * of \"\\033[yy;xxH\", the typical cup sequence these days.\n */\n#define LONG_DIST\t\t(8 - COMPUTE_OVERHEAD)\n\n/*\n * Tell whether a motion is optimizable by local motions.  Needs to be cheap to\n * compute. In general, all the fast moves go to either the right or left edge\n * of the screen.  So any motion to a location that is (a) further away than\n * LONG_DIST and (b) further inward from the right or left edge than LONG_DIST,\n * we'll consider nonlocal.\n */\n#define NOT_LOCAL(sp, fy, fx, ty, tx)\t((tx > LONG_DIST) \\\n\t\t && (tx < screen_columns(sp) - 1 - LONG_DIST) \\\n\t\t && (abs(ty-fy) + abs(tx-fx) > LONG_DIST))\n\n/****************************************************************************\n *\n * External interfaces\n *\n ****************************************************************************/\n\n/*\n * For this code to work OK, the following components must live in the\n * screen structure:\n *\n *\tint\t\t_char_padding;\t// cost of character put\n *\tint\t\t_cr_cost;\t// cost of (carriage_return)\n *\tint\t\t_cup_cost;\t// cost of (cursor_address)\n *\tint\t\t_home_cost;\t// cost of (cursor_home)\n *\tint\t\t_ll_cost;\t// cost of (cursor_to_ll)\n *#if USE_HARD_TABS\n *\tint\t\t_ht_cost;\t// cost of (tab)\n *\tint\t\t_cbt_cost;\t// cost of (back_tab)\n *#endif USE_HARD_TABS\n *\tint\t\t_cub1_cost;\t// cost of (cursor_left)\n *\tint\t\t_cuf1_cost;\t// cost of (cursor_right)\n *\tint\t\t_cud1_cost;\t// cost of (cursor_down)\n *\tint\t\t_cuu1_cost;\t// cost of (cursor_up)\n *\tint\t\t_cub_cost;\t// cost of (parm_cursor_left)\n *\tint\t\t_cuf_cost;\t// cost of (parm_cursor_right)\n *\tint\t\t_cud_cost;\t// cost of (parm_cursor_down)\n *\tint\t\t_cuu_cost;\t// cost of (parm_cursor_up)\n *\tint\t\t_hpa_cost;\t// cost of (column_address)\n *\tint\t\t_vpa_cost;\t// cost of (row_address)\n *\tint\t\t_ech_cost;\t// cost of (erase_chars)\n *\tint\t\t_rep_cost;\t// cost of (repeat_char)\n *\n * The USE_HARD_TABS switch controls whether it is reliable to use tab/backtabs\n * for local motions.  On many systems, it's not, due to uncertainties about\n * tab delays and whether or not tabs will be expanded in raw mode.  If you\n * have parm_right_cursor, tab motions don't win you a lot anyhow.\n */\n\n#include <curses.priv.h>\n#include <ctype.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_mvcur.c,v 1.145 2017/07/23 00:08:37 tom Exp $\")\n\n#define WANT_CHAR(sp, y, x) NewScreen(sp)->_line[y].text[x]\t/* desired state */\n\n#if NCURSES_SP_FUNCS\n#define BAUDRATE(sp)\tsp->_term->_baudrate\t/* bits per second */\n#else\n#define BAUDRATE(sp)\tcur_term->_baudrate\t/* bits per second */\n#endif\n\n#if defined(MAIN) || defined(NCURSES_TEST)\n#include <sys/time.h>\n\nstatic bool profiling = FALSE;\nstatic float diff;\n#endif /* MAIN */\n\n#undef NCURSES_OUTC_FUNC\n#define NCURSES_OUTC_FUNC myOutCh\n\n#define OPT_SIZE 512\n\nstatic int normalized_cost(NCURSES_SP_DCLx const char *const cap, int affcnt);\n\n/****************************************************************************\n *\n * Initialization/wrapup (including cost pre-computation)\n *\n ****************************************************************************/\n\n#ifdef TRACE\nstatic int\ntrace_cost_of(NCURSES_SP_DCLx const char *capname, const char *cap, int affcnt)\n{\n    int result = NCURSES_SP_NAME(_nc_msec_cost) (NCURSES_SP_ARGx cap, affcnt);\n    TR(TRACE_CHARPUT | TRACE_MOVE,\n       (\"CostOf %s %d %s\", capname, result, _nc_visbuf(cap)));\n    return result;\n}\n#define CostOf(cap,affcnt) trace_cost_of(NCURSES_SP_ARGx #cap, cap, affcnt)\n\nstatic int\ntrace_normalized_cost(NCURSES_SP_DCLx const char *capname, const char *cap, int affcnt)\n{\n    int result = normalized_cost(NCURSES_SP_ARGx cap, affcnt);\n    TR(TRACE_CHARPUT | TRACE_MOVE,\n       (\"NormalizedCost %s %d %s\", capname, result, _nc_visbuf(cap)));\n    return result;\n}\n#define NormalizedCost(cap,affcnt) trace_normalized_cost(NCURSES_SP_ARGx #cap, cap, affcnt)\n\n#else\n\n#define CostOf(cap,affcnt) NCURSES_SP_NAME(_nc_msec_cost)(NCURSES_SP_ARGx cap, affcnt)\n#define NormalizedCost(cap,affcnt) normalized_cost(NCURSES_SP_ARGx cap, affcnt)\n\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_msec_cost) (NCURSES_SP_DCLx const char *const cap, int affcnt)\n/* compute the cost of a given operation */\n{\n    if (cap == 0)\n\treturn (INFINITY);\n    else {\n\tconst char *cp;\n\tfloat cum_cost = 0.0;\n\n\tfor (cp = cap; *cp; cp++) {\n\t    /* extract padding, either mandatory or required */\n\t    if (cp[0] == '$' && cp[1] == '<' && strchr(cp, '>')) {\n\t\tfloat number = 0.0;\n\n\t\tfor (cp += 2; *cp != '>'; cp++) {\n\t\t    if (isdigit(UChar(*cp)))\n\t\t\tnumber = number * 10 + (float) (*cp - '0');\n\t\t    else if (*cp == '*')\n\t\t\tnumber *= (float) affcnt;\n\t\t    else if (*cp == '.' && (*++cp != '>') && isdigit(UChar(*cp)))\n\t\t\tnumber += (float) ((*cp - '0') / 10.0);\n\t\t}\n\n#if NCURSES_NO_PADDING\n\t\tif (!GetNoPadding(SP_PARM))\n#endif\n\t\t    cum_cost += number * 10;\n\t    } else if (SP_PARM) {\n\t\tcum_cost += (float) SP_PARM->_char_padding;\n\t    }\n\t}\n\n\treturn ((int) cum_cost);\n    }\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_msec_cost(const char *const cap, int affcnt)\n{\n    return NCURSES_SP_NAME(_nc_msec_cost) (CURRENT_SCREEN, cap, affcnt);\n}\n#endif\n\nstatic int\nnormalized_cost(NCURSES_SP_DCLx const char *const cap, int affcnt)\n/* compute the effective character-count for an operation (round up) */\n{\n    int cost = NCURSES_SP_NAME(_nc_msec_cost) (NCURSES_SP_ARGx cap, affcnt);\n    if (cost != INFINITY)\n\tcost = (cost + SP_PARM->_char_padding - 1) / SP_PARM->_char_padding;\n    return cost;\n}\n\nstatic void\nreset_scroll_region(NCURSES_SP_DCL0)\n/* Set the scroll-region to a known state (the default) */\n{\n    if (change_scroll_region) {\n\tNCURSES_PUTP2(\"change_scroll_region\",\n\t\t      TPARM_2(change_scroll_region,\n\t\t\t      0, screen_lines(SP_PARM) - 1));\n    }\n}\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_mvcur_resume) (NCURSES_SP_DCL0)\n/* what to do at initialization time and after each shellout */\n{\n    if (!SP_PARM || !IsTermInfo(SP_PARM))\n\treturn;\n\n    /* initialize screen for cursor access */\n    if (enter_ca_mode) {\n\tNCURSES_PUTP2(\"enter_ca_mode\", enter_ca_mode);\n    }\n\n    /*\n     * Doing this here rather than in _nc_mvcur_wrap() ensures that\n     * ncurses programs will see a reset scroll region even if a\n     * program that messed with it died ungracefully.\n     *\n     * This also undoes the effects of terminal init strings that assume\n     * they know the screen size.  This is useful when you're running\n     * a vt100 emulation through xterm.\n     */\n    reset_scroll_region(NCURSES_SP_ARG);\n    SP_PARM->_cursrow = SP_PARM->_curscol = -1;\n\n    /* restore cursor shape */\n    if (SP_PARM->_cursor != -1) {\n\tint cursor = SP_PARM->_cursor;\n\tSP_PARM->_cursor = -1;\n\tNCURSES_SP_NAME(curs_set) (NCURSES_SP_ARGx cursor);\n    }\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_mvcur_resume(void)\n{\n    NCURSES_SP_NAME(_nc_mvcur_resume) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_mvcur_init) (NCURSES_SP_DCL0)\n/* initialize the cost structure */\n{\n    if (SP_PARM->_ofp && NC_ISATTY(fileno(SP_PARM->_ofp))) {\n\tSP_PARM->_char_padding = ((BAUDBYTE * 1000 * 10)\n\t\t\t\t  / (BAUDRATE(SP_PARM) > 0\n\t\t\t\t     ? BAUDRATE(SP_PARM)\n\t\t\t\t     : 9600));\n    } else {\n\tSP_PARM->_char_padding = 1;\t/* must be nonzero */\n    }\n    if (SP_PARM->_char_padding <= 0)\n\tSP_PARM->_char_padding = 1;\t/* must be nonzero */\n    TR(TRACE_CHARPUT | TRACE_MOVE, (\"char_padding %d msecs\", SP_PARM->_char_padding));\n\n    /* non-parameterized local-motion strings */\n    SP_PARM->_cr_cost = CostOf(carriage_return, 0);\n    SP_PARM->_home_cost = CostOf(cursor_home, 0);\n    SP_PARM->_ll_cost = CostOf(cursor_to_ll, 0);\n#if USE_HARD_TABS\n    if (getenv(\"NCURSES_NO_HARD_TABS\") == 0) {\n\tSP_PARM->_ht_cost = CostOf(tab, 0);\n\tSP_PARM->_cbt_cost = CostOf(back_tab, 0);\n    } else {\n\tSP_PARM->_ht_cost = INFINITY;\n\tSP_PARM->_cbt_cost = INFINITY;\n    }\n#endif /* USE_HARD_TABS */\n    SP_PARM->_cub1_cost = CostOf(cursor_left, 0);\n    SP_PARM->_cuf1_cost = CostOf(cursor_right, 0);\n    SP_PARM->_cud1_cost = CostOf(cursor_down, 0);\n    SP_PARM->_cuu1_cost = CostOf(cursor_up, 0);\n\n    SP_PARM->_smir_cost = CostOf(enter_insert_mode, 0);\n    SP_PARM->_rmir_cost = CostOf(exit_insert_mode, 0);\n    SP_PARM->_ip_cost = 0;\n    if (insert_padding) {\n\tSP_PARM->_ip_cost = CostOf(insert_padding, 0);\n    }\n\n    /*\n     * Assumption: if the terminal has memory_relative addressing, the\n     * initialization strings or smcup will set single-page mode so we\n     * can treat it like absolute screen addressing.  This seems to be true\n     * for all cursor_mem_address terminal types in the terminfo database.\n     */\n    SP_PARM->_address_cursor = cursor_address ? cursor_address : cursor_mem_address;\n\n    /*\n     * Parametrized local-motion strings.  This static cost computation\n     * depends on the following assumptions:\n     *\n     * (1) They never have * padding.  In the entire master terminfo database\n     *     as of March 1995, only the obsolete Zenith Z-100 pc violates this.\n     *     (Proportional padding is found mainly in insert, delete and scroll\n     *     capabilities).\n     *\n     * (2) The average case of cup has two two-digit parameters.  Strictly,\n     *     the average case for a 24 * 80 screen has ((10*10*(1 + 1)) +\n     *     (14*10*(1 + 2)) + (10*70*(2 + 1)) + (14*70*4)) / (24*80) = 3.458\n     *     digits of parameters.  On a 25x80 screen the average is 3.6197.\n     *     On larger screens the value gets much closer to 4.\n     *\n     * (3) The average case of cub/cuf/hpa/ech/rep has 2 digits of parameters\n     *     (strictly, (((10 * 1) + (70 * 2)) / 80) = 1.8750).\n     *\n     * (4) The average case of cud/cuu/vpa has 2 digits of parameters\n     *     (strictly, (((10 * 1) + (14 * 2)) / 24) = 1.5833).\n     *\n     * All these averages depend on the assumption that all parameter values\n     * are equally probable.\n     */\n    SP_PARM->_cup_cost = CostOf(TPARM_2(SP_PARM->_address_cursor, 23, 23), 1);\n    SP_PARM->_cub_cost = CostOf(TPARM_1(parm_left_cursor, 23), 1);\n    SP_PARM->_cuf_cost = CostOf(TPARM_1(parm_right_cursor, 23), 1);\n    SP_PARM->_cud_cost = CostOf(TPARM_1(parm_down_cursor, 23), 1);\n    SP_PARM->_cuu_cost = CostOf(TPARM_1(parm_up_cursor, 23), 1);\n    SP_PARM->_hpa_cost = CostOf(TPARM_1(column_address, 23), 1);\n    SP_PARM->_vpa_cost = CostOf(TPARM_1(row_address, 23), 1);\n\n    /* non-parameterized screen-update strings */\n    SP_PARM->_ed_cost = NormalizedCost(clr_eos, 1);\n    SP_PARM->_el_cost = NormalizedCost(clr_eol, 1);\n    SP_PARM->_el1_cost = NormalizedCost(clr_bol, 1);\n    SP_PARM->_dch1_cost = NormalizedCost(delete_character, 1);\n    SP_PARM->_ich1_cost = NormalizedCost(insert_character, 1);\n\n    /*\n     * If this is a bce-terminal, we want to bias the choice so we use clr_eol\n     * rather than spaces at the end of a line.\n     */\n    if (back_color_erase)\n\tSP_PARM->_el_cost = 0;\n\n    /* parameterized screen-update strings */\n    SP_PARM->_dch_cost = NormalizedCost(TPARM_1(parm_dch, 23), 1);\n    SP_PARM->_ich_cost = NormalizedCost(TPARM_1(parm_ich, 23), 1);\n    SP_PARM->_ech_cost = NormalizedCost(TPARM_1(erase_chars, 23), 1);\n    SP_PARM->_rep_cost = NormalizedCost(TPARM_2(repeat_char, ' ', 23), 1);\n\n    SP_PARM->_cup_ch_cost = NormalizedCost(\n\t\t\t\t\t      TPARM_2(SP_PARM->_address_cursor,\n\t\t\t\t\t\t      23, 23),\n\t\t\t\t\t      1);\n    SP_PARM->_hpa_ch_cost = NormalizedCost(TPARM_1(column_address, 23), 1);\n    SP_PARM->_cuf_ch_cost = NormalizedCost(TPARM_1(parm_right_cursor, 23), 1);\n    SP_PARM->_inline_cost = min(SP_PARM->_cup_ch_cost,\n\t\t\t\tmin(SP_PARM->_hpa_ch_cost,\n\t\t\t\t    SP_PARM->_cuf_ch_cost));\n\n    /*\n     * If save_cursor is used within enter_ca_mode, we should not use it for\n     * scrolling optimization, since the corresponding restore_cursor is not\n     * nested on the various terminals (vt100, xterm, etc.) which use this\n     * feature.\n     */\n    if (save_cursor != 0\n\t&& enter_ca_mode != 0\n\t&& strstr(enter_ca_mode, save_cursor) != 0) {\n\tT((\"...suppressed sc/rc capability due to conflict with smcup/rmcup\"));\n\tsave_cursor = 0;\n\trestore_cursor = 0;\n    }\n\n    /*\n     * A different, possibly better way to arrange this would be to set the\n     * SCREEN's _endwin at window initialization time and let this be called by\n     * doupdate's return-from-shellout code.\n     */\n    NCURSES_SP_NAME(_nc_mvcur_resume) (NCURSES_SP_ARG);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_mvcur_init(void)\n{\n    NCURSES_SP_NAME(_nc_mvcur_init) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_mvcur_wrap) (NCURSES_SP_DCL0)\n/* wrap up cursor-addressing mode */\n{\n    /* leave cursor at screen bottom */\n    TINFO_MVCUR(NCURSES_SP_ARGx -1, -1, screen_lines(SP_PARM) - 1, 0);\n\n    if (!SP_PARM || !IsTermInfo(SP_PARM))\n\treturn;\n\n    /* set cursor to normal mode */\n    if (SP_PARM->_cursor != -1) {\n\tint cursor = SP_PARM->_cursor;\n\tNCURSES_SP_NAME(curs_set) (NCURSES_SP_ARGx 1);\n\tSP_PARM->_cursor = cursor;\n    }\n\n    if (exit_ca_mode) {\n\tNCURSES_PUTP2(\"exit_ca_mode\", exit_ca_mode);\n    }\n    /*\n     * Reset terminal's tab counter.  There's a long-time bug that\n     * if you exit a \"curses\" program such as vi or more, tab\n     * forward, and then backspace, the cursor doesn't go to the\n     * right place.  The problem is that the kernel counts the\n     * escape sequences that reset things as column positions.\n     * Utter a \\r to reset this invisibly.\n     */\n    NCURSES_SP_NAME(_nc_outch) (NCURSES_SP_ARGx '\\r');\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_mvcur_wrap(void)\n{\n    NCURSES_SP_NAME(_nc_mvcur_wrap) (CURRENT_SCREEN);\n}\n#endif\n\n/****************************************************************************\n *\n * Optimized cursor movement\n *\n ****************************************************************************/\n\n/*\n * Perform repeated-append, returning cost\n */\nstatic NCURSES_INLINE int\nrepeated_append(string_desc * target, int total, int num, int repeat, const char *src)\n{\n    size_t need = (size_t) repeat * strlen(src);\n\n    if (need < target->s_size) {\n\twhile (repeat-- > 0) {\n\t    if (_nc_safe_strcat(target, src)) {\n\t\ttotal += num;\n\t    } else {\n\t\ttotal = INFINITY;\n\t\tbreak;\n\t    }\n\t}\n    } else {\n\ttotal = INFINITY;\n    }\n    return total;\n}\n\n#ifndef NO_OPTIMIZE\n#define NEXTTAB(fr)\t(fr + init_tabs - (fr % init_tabs))\n\n/*\n * Assume back_tab (CBT) does not wrap backwards at the left margin, return\n * a negative value at that point to simplify the loop.\n */\n#define LASTTAB(fr)\t((fr > 0) ? ((fr - 1) / init_tabs) * init_tabs : -1)\n\nstatic int\nrelative_move(NCURSES_SP_DCLx\n\t      string_desc * target,\n\t      int from_y,\n\t      int from_x,\n\t      int to_y,\n\t      int to_x,\n\t      int ovw)\n/* move via local motions (cuu/cuu1/cud/cud1/cub1/cub/cuf1/cuf/vpa/hpa) */\n{\n    string_desc save;\n    int n, vcost = 0, hcost = 0;\n\n    (void) _nc_str_copy(&save, target);\n\n    if (to_y != from_y) {\n\tvcost = INFINITY;\n\n\tif (row_address != 0\n\t    && _nc_safe_strcat(target, TPARM_1(row_address, to_y))) {\n\t    vcost = SP_PARM->_vpa_cost;\n\t}\n\n\tif (to_y > from_y) {\n\t    n = (to_y - from_y);\n\n\t    if (parm_down_cursor\n\t\t&& SP_PARM->_cud_cost < vcost\n\t\t&& _nc_safe_strcat(_nc_str_copy(target, &save),\n\t\t\t\t   TPARM_1(parm_down_cursor, n))) {\n\t\tvcost = SP_PARM->_cud_cost;\n\t    }\n\n\t    if (cursor_down\n\t\t&& (*cursor_down != '\\n' || SP_PARM->_nl)\n\t\t&& (n * SP_PARM->_cud1_cost < vcost)) {\n\t\tvcost = repeated_append(_nc_str_copy(target, &save), 0,\n\t\t\t\t\tSP_PARM->_cud1_cost, n, cursor_down);\n\t    }\n\t} else {\t\t/* (to_y < from_y) */\n\t    n = (from_y - to_y);\n\n\t    if (parm_up_cursor\n\t\t&& SP_PARM->_cuu_cost < vcost\n\t\t&& _nc_safe_strcat(_nc_str_copy(target, &save),\n\t\t\t\t   TPARM_1(parm_up_cursor, n))) {\n\t\tvcost = SP_PARM->_cuu_cost;\n\t    }\n\n\t    if (cursor_up && (n * SP_PARM->_cuu1_cost < vcost)) {\n\t\tvcost = repeated_append(_nc_str_copy(target, &save), 0,\n\t\t\t\t\tSP_PARM->_cuu1_cost, n, cursor_up);\n\t    }\n\t}\n\n\tif (vcost == INFINITY)\n\t    return (INFINITY);\n    }\n\n    save = *target;\n\n    if (to_x != from_x) {\n\tchar str[OPT_SIZE];\n\tstring_desc check;\n\n\thcost = INFINITY;\n\n\tif (column_address\n\t    && _nc_safe_strcat(_nc_str_copy(target, &save),\n\t\t\t       TPARM_1(column_address, to_x))) {\n\t    hcost = SP_PARM->_hpa_cost;\n\t}\n\n\tif (to_x > from_x) {\n\t    n = to_x - from_x;\n\n\t    if (parm_right_cursor\n\t\t&& SP_PARM->_cuf_cost < hcost\n\t\t&& _nc_safe_strcat(_nc_str_copy(target, &save),\n\t\t\t\t   TPARM_1(parm_right_cursor, n))) {\n\t\thcost = SP_PARM->_cuf_cost;\n\t    }\n\n\t    if (cursor_right) {\n\t\tint lhcost = 0;\n\n\t\t(void) _nc_str_init(&check, str, sizeof(str));\n\n#if USE_HARD_TABS\n\t\t/* use hard tabs, if we have them, to do as much as possible */\n\t\tif (init_tabs > 0 && tab) {\n\t\t    int nxt, fr;\n\n\t\t    for (fr = from_x; (nxt = NEXTTAB(fr)) <= to_x; fr = nxt) {\n\t\t\tlhcost = repeated_append(&check, lhcost,\n\t\t\t\t\t\t SP_PARM->_ht_cost, 1, tab);\n\t\t\tif (lhcost == INFINITY)\n\t\t\t    break;\n\t\t    }\n\n\t\t    n = to_x - fr;\n\t\t    from_x = fr;\n\t\t}\n#endif /* USE_HARD_TABS */\n\n\t\tif (n <= 0 || n >= (int) check.s_size)\n\t\t    ovw = FALSE;\n#if BSD_TPUTS\n\t\t/*\n\t\t * If we're allowing BSD-style padding in tputs, don't generate\n\t\t * a string with a leading digit.  Otherwise, that will be\n\t\t * interpreted as a padding value rather than sent to the\n\t\t * screen.\n\t\t */\n\t\tif (ovw\n\t\t    && n > 0\n\t\t    && n < (int) check.s_size\n\t\t    && vcost == 0\n\t\t    && str[0] == '\\0') {\n\t\t    int wanted = CharOf(WANT_CHAR(SP_PARM, to_y, from_x));\n\t\t    if (is8bits(wanted) && isdigit(wanted))\n\t\t\tovw = FALSE;\n\t\t}\n#endif\n\t\t/*\n\t\t * If we have no attribute changes, overwrite is cheaper.\n\t\t * Note: must suppress this by passing in ovw = FALSE whenever\n\t\t * WANT_CHAR would return invalid data.  In particular, this\n\t\t * is true between the time a hardware scroll has been done\n\t\t * and the time the structure WANT_CHAR would access has been\n\t\t * updated.\n\t\t */\n\t\tif (ovw) {\n\t\t    int i;\n\n\t\t    for (i = 0; i < n; i++) {\n\t\t\tNCURSES_CH_T ch = WANT_CHAR(SP_PARM, to_y, from_x + i);\n\t\t\tif (!SameAttrOf(ch, SCREEN_ATTRS(SP_PARM))\n#if USE_WIDEC_SUPPORT\n\t\t\t    || !Charable(ch)\n#endif\n\t\t\t    ) {\n\t\t\t    ovw = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ovw) {\n\t\t    int i;\n\n\t\t    for (i = 0; i < n; i++)\n\t\t\t*check.s_tail++ = (char) CharOf(WANT_CHAR(SP_PARM, to_y,\n\t\t\t\t\t\t\t\t  from_x + i));\n\t\t    *check.s_tail = '\\0';\n\t\t    check.s_size -= (size_t) n;\n\t\t    lhcost += n * SP_PARM->_char_padding;\n\t\t} else {\n\t\t    lhcost = repeated_append(&check, lhcost, SP_PARM->_cuf1_cost,\n\t\t\t\t\t     n, cursor_right);\n\t\t}\n\n\t\tif (lhcost < hcost\n\t\t    && _nc_safe_strcat(_nc_str_copy(target, &save), str)) {\n\t\t    hcost = lhcost;\n\t\t}\n\t    }\n\t} else {\t\t/* (to_x < from_x) */\n\t    n = from_x - to_x;\n\n\t    if (parm_left_cursor\n\t\t&& SP_PARM->_cub_cost < hcost\n\t\t&& _nc_safe_strcat(_nc_str_copy(target, &save),\n\t\t\t\t   TPARM_1(parm_left_cursor, n))) {\n\t\thcost = SP_PARM->_cub_cost;\n\t    }\n\n\t    if (cursor_left) {\n\t\tint lhcost = 0;\n\n\t\t(void) _nc_str_init(&check, str, sizeof(str));\n\n#if USE_HARD_TABS\n\t\tif (init_tabs > 0 && back_tab) {\n\t\t    int nxt, fr;\n\n\t\t    for (fr = from_x; (nxt = LASTTAB(fr)) >= to_x; fr = nxt) {\n\t\t\tlhcost = repeated_append(&check, lhcost,\n\t\t\t\t\t\t SP_PARM->_cbt_cost,\n\t\t\t\t\t\t 1, back_tab);\n\t\t\tif (lhcost == INFINITY)\n\t\t\t    break;\n\t\t    }\n\n\t\t    n = fr - to_x;\n\t\t}\n#endif /* USE_HARD_TABS */\n\n\t\tlhcost = repeated_append(&check, lhcost,\n\t\t\t\t\t SP_PARM->_cub1_cost,\n\t\t\t\t\t n, cursor_left);\n\n\t\tif (lhcost < hcost\n\t\t    && _nc_safe_strcat(_nc_str_copy(target, &save), str)) {\n\t\t    hcost = lhcost;\n\t\t}\n\t    }\n\t}\n\n\tif (hcost == INFINITY)\n\t    return (INFINITY);\n    }\n\n    return (vcost + hcost);\n}\n#endif /* !NO_OPTIMIZE */\n\n/*\n * With the machinery set up above, it's conceivable that\n * onscreen_mvcur could be modified into a recursive function that does\n * an alpha-beta search of motion space, as though it were a chess\n * move tree, with the weight function being boolean and the search\n * depth equated to length of string.  However, this would jack up the\n * computation cost a lot, especially on terminals without a cup\n * capability constraining the search tree depth.  So we settle for\n * the simpler method below.\n */\n\nstatic NCURSES_INLINE int\nonscreen_mvcur(NCURSES_SP_DCLx\n\t       int yold, int xold,\n\t       int ynew, int xnew, int ovw,\n\t       NCURSES_SP_OUTC myOutCh)\n/* onscreen move from (yold, xold) to (ynew, xnew) */\n{\n    string_desc result;\n    char buffer[OPT_SIZE];\n    int tactic = 0, newcost, usecost = INFINITY;\n    int t5_cr_cost;\n\n#if defined(MAIN) || defined(NCURSES_TEST)\n    struct timeval before, after;\n\n    gettimeofday(&before, NULL);\n#endif /* MAIN */\n\n#define NullResult _nc_str_null(&result, sizeof(buffer))\n#define InitResult _nc_str_init(&result, buffer, sizeof(buffer))\n\n    /* tactic #0: use direct cursor addressing */\n    if (_nc_safe_strcpy(InitResult, TPARM_2(SP_PARM->_address_cursor, ynew, xnew))) {\n\ttactic = 0;\n\tusecost = SP_PARM->_cup_cost;\n\n#if defined(TRACE) || defined(NCURSES_TEST)\n\tif (!(_nc_optimize_enable & OPTIMIZE_MVCUR))\n\t    goto nonlocal;\n#endif /* TRACE */\n\n\t/*\n\t * We may be able to tell in advance that the full optimization\n\t * will probably not be worth its overhead.  Also, don't try to\n\t * use local movement if the current attribute is anything but\n\t * A_NORMAL...there are just too many ways this can screw up\n\t * (like, say, local-movement \\n getting mapped to some obscure\n\t * character because A_ALTCHARSET is on).\n\t */\n\tif (yold == -1 || xold == -1 || NOT_LOCAL(SP_PARM, yold, xold, ynew, xnew)) {\n#if defined(MAIN) || defined(NCURSES_TEST)\n\t    if (!profiling) {\n\t\t(void) fputs(\"nonlocal\\n\", stderr);\n\t\tgoto nonlocal;\t/* always run the optimizer if profiling */\n\t    }\n#else\n\t    goto nonlocal;\n#endif /* MAIN */\n\t}\n    }\n#ifndef NO_OPTIMIZE\n    /* tactic #1: use local movement */\n    if (yold != -1 && xold != -1\n\t&& ((newcost = relative_move(NCURSES_SP_ARGx\n\t\t\t\t     NullResult,\n\t\t\t\t     yold, xold,\n\t\t\t\t     ynew, xnew, ovw)) != INFINITY)\n\t&& newcost < usecost) {\n\ttactic = 1;\n\tusecost = newcost;\n    }\n\n    /* tactic #2: use carriage-return + local movement */\n    if (yold != -1 && carriage_return\n\t&& ((newcost = relative_move(NCURSES_SP_ARGx\n\t\t\t\t     NullResult,\n\t\t\t\t     yold, 0,\n\t\t\t\t     ynew, xnew, ovw)) != INFINITY)\n\t&& SP_PARM->_cr_cost + newcost < usecost) {\n\ttactic = 2;\n\tusecost = SP_PARM->_cr_cost + newcost;\n    }\n\n    /* tactic #3: use home-cursor + local movement */\n    if (cursor_home\n\t&& ((newcost = relative_move(NCURSES_SP_ARGx\n\t\t\t\t     NullResult,\n\t\t\t\t     0, 0,\n\t\t\t\t     ynew, xnew, ovw)) != INFINITY)\n\t&& SP_PARM->_home_cost + newcost < usecost) {\n\ttactic = 3;\n\tusecost = SP_PARM->_home_cost + newcost;\n    }\n\n    /* tactic #4: use home-down + local movement */\n    if (cursor_to_ll\n\t&& ((newcost = relative_move(NCURSES_SP_ARGx\n\t\t\t\t     NullResult,\n\t\t\t\t     screen_lines(SP_PARM) - 1, 0,\n\t\t\t\t     ynew, xnew, ovw)) != INFINITY)\n\t&& SP_PARM->_ll_cost + newcost < usecost) {\n\ttactic = 4;\n\tusecost = SP_PARM->_ll_cost + newcost;\n    }\n\n    /*\n     * tactic #5: use left margin for wrap to right-hand side,\n     * unless strange wrap behavior indicated by xenl might hose us.\n     */\n    t5_cr_cost = (xold > 0 ? SP_PARM->_cr_cost : 0);\n    if (auto_left_margin && !eat_newline_glitch\n\t&& yold > 0 && cursor_left\n\t&& ((newcost = relative_move(NCURSES_SP_ARGx\n\t\t\t\t     NullResult,\n\t\t\t\t     yold - 1, screen_columns(SP_PARM) - 1,\n\t\t\t\t     ynew, xnew, ovw)) != INFINITY)\n\t&& t5_cr_cost + SP_PARM->_cub1_cost + newcost < usecost) {\n\ttactic = 5;\n\tusecost = t5_cr_cost + SP_PARM->_cub1_cost + newcost;\n    }\n\n    /*\n     * These cases are ordered by estimated relative frequency.\n     */\n    if (tactic)\n\tInitResult;\n    switch (tactic) {\n    case 1:\n\t(void) relative_move(NCURSES_SP_ARGx\n\t\t\t     &result,\n\t\t\t     yold, xold,\n\t\t\t     ynew, xnew, ovw);\n\tbreak;\n    case 2:\n\t(void) _nc_safe_strcpy(&result, carriage_return);\n\t(void) relative_move(NCURSES_SP_ARGx\n\t\t\t     &result,\n\t\t\t     yold, 0,\n\t\t\t     ynew, xnew, ovw);\n\tbreak;\n    case 3:\n\t(void) _nc_safe_strcpy(&result, cursor_home);\n\t(void) relative_move(NCURSES_SP_ARGx\n\t\t\t     &result, 0, 0,\n\t\t\t     ynew, xnew, ovw);\n\tbreak;\n    case 4:\n\t(void) _nc_safe_strcpy(&result, cursor_to_ll);\n\t(void) relative_move(NCURSES_SP_ARGx\n\t\t\t     &result,\n\t\t\t     screen_lines(SP_PARM) - 1, 0,\n\t\t\t     ynew, xnew, ovw);\n\tbreak;\n    case 5:\n\tif (xold > 0)\n\t    (void) _nc_safe_strcat(&result, carriage_return);\n\t(void) _nc_safe_strcat(&result, cursor_left);\n\t(void) relative_move(NCURSES_SP_ARGx\n\t\t\t     &result,\n\t\t\t     yold - 1, screen_columns(SP_PARM) - 1,\n\t\t\t     ynew, xnew, ovw);\n\tbreak;\n    }\n#endif /* !NO_OPTIMIZE */\n\n  nonlocal:\n#if defined(MAIN) || defined(NCURSES_TEST)\n    gettimeofday(&after, NULL);\n    diff = after.tv_usec - before.tv_usec\n\t+ (after.tv_sec - before.tv_sec) * 1000000;\n    if (!profiling)\n\t(void) fprintf(stderr,\n\t\t       \"onscreen: %d microsec, %f 28.8Kbps char-equivalents\\n\",\n\t\t       (int) diff, diff / 288);\n#endif /* MAIN */\n\n    if (usecost != INFINITY) {\n\tTPUTS_TRACE(\"mvcur\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tbuffer, 1, myOutCh);\n\tSP_PARM->_cursrow = ynew;\n\tSP_PARM->_curscol = xnew;\n\treturn (OK);\n    } else\n\treturn (ERR);\n}\n\n/*\n * optimized cursor move from (yold, xold) to (ynew, xnew)\n */\nstatic int\n_nc_real_mvcur(NCURSES_SP_DCLx\n\t       int yold, int xold,\n\t       int ynew, int xnew,\n\t       NCURSES_SP_OUTC myOutCh,\n\t       int ovw)\n{\n    NCURSES_CH_T oldattr;\n    int code;\n\n    TR(TRACE_CALLS | TRACE_MOVE, (T_CALLED(\"_nc_tinfo_mvcur(%p,%d,%d,%d,%d)\"),\n\t\t\t\t  (void *) SP_PARM, yold, xold, ynew, xnew));\n\n    if (SP_PARM == 0) {\n\tcode = ERR;\n    } else if (yold == ynew && xold == xnew) {\n\tcode = OK;\n    } else {\n\n\t/*\n\t * Most work here is rounding for terminal boundaries getting the\n\t * column position implied by wraparound or the lack thereof and\n\t * rolling up the screen to get ynew on the screen.\n\t */\n\tif (xnew >= screen_columns(SP_PARM)) {\n\t    ynew += xnew / screen_columns(SP_PARM);\n\t    xnew %= screen_columns(SP_PARM);\n\t}\n\n\t/*\n\t * Force restore even if msgr is on when we're in an alternate\n\t * character set -- these have a strong tendency to screw up the CR &\n\t * LF used for local character motions!\n\t */\n\toldattr = SCREEN_ATTRS(SP_PARM);\n\tif ((AttrOf(oldattr) & A_ALTCHARSET)\n\t    || (AttrOf(oldattr) && !move_standout_mode)) {\n\t    TR(TRACE_CHARPUT, (\"turning off (%#lx) %s before move\",\n\t\t\t       (unsigned long) AttrOf(oldattr),\n\t\t\t       _traceattr(AttrOf(oldattr))));\n\t    (void) VIDATTR(SP_PARM, A_NORMAL, 0);\n\t}\n\n\tif (xold >= screen_columns(SP_PARM)) {\n\n\t    if (SP_PARM->_nl) {\n\t\tint l = (xold + 1) / screen_columns(SP_PARM);\n\n\t\tyold += l;\n\t\tif (yold >= screen_lines(SP_PARM))\n\t\t    l -= (yold - screen_lines(SP_PARM) - 1);\n\n\t\tif (l > 0) {\n\t\t    if (carriage_return) {\n\t\t\tNCURSES_PUTP2(\"carriage_return\", carriage_return);\n\t\t    } else {\n\t\t\tmyOutCh(NCURSES_SP_ARGx '\\r');\n\t\t    }\n\t\t    xold = 0;\n\n\t\t    while (l > 0) {\n\t\t\tif (newline) {\n\t\t\t    NCURSES_PUTP2(\"newline\", newline);\n\t\t\t} else {\n\t\t\t    myOutCh(NCURSES_SP_ARGx '\\n');\n\t\t\t}\n\t\t\tl--;\n\t\t    }\n\t\t}\n\t    } else {\n\t\t/*\n\t\t * If caller set nonl(), we cannot really use newlines to\n\t\t * position to the next row.\n\t\t */\n\t\txold = -1;\n\t\tyold = -1;\n\t    }\n\t}\n\n\tif (yold > screen_lines(SP_PARM) - 1)\n\t    yold = screen_lines(SP_PARM) - 1;\n\tif (ynew > screen_lines(SP_PARM) - 1)\n\t    ynew = screen_lines(SP_PARM) - 1;\n\n\t/* destination location is on screen now */\n\tcode = onscreen_mvcur(NCURSES_SP_ARGx yold, xold, ynew, xnew, ovw, myOutCh);\n\n\t/*\n\t * Restore attributes if we disabled them before moving.\n\t */\n\tif (!SameAttrOf(oldattr, SCREEN_ATTRS(SP_PARM))) {\n\t    TR(TRACE_CHARPUT, (\"turning on (%#lx) %s after move\",\n\t\t\t       (unsigned long) AttrOf(oldattr),\n\t\t\t       _traceattr(AttrOf(oldattr))));\n\t    (void) VIDATTR(SP_PARM, AttrOf(oldattr), GetPair(oldattr));\n\t}\n    }\n    returnCode(code);\n}\n\n/*\n * These entrypoints are used within the library.\n */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_mvcur) (NCURSES_SP_DCLx\n\t\t\t    int yold, int xold,\n\t\t\t    int ynew, int xnew)\n{\n    int rc;\n    rc = _nc_real_mvcur(NCURSES_SP_ARGx yold, xold, ynew, xnew,\n\t\t\tNCURSES_SP_NAME(_nc_outch),\n\t\t\tTRUE);\n    /*\n     * With the terminal-driver, we cannot distinguish between internal and\n     * external calls.  Flush the output if the screen has not been\n     * initialized, e.g., when used from low-level terminfo programs.\n     */\n    if ((SP_PARM != 0) && (SP_PARM->_endwin == ewInitial))\n\tNCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n    return rc;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_mvcur(int yold, int xold,\n\t  int ynew, int xnew)\n{\n    return NCURSES_SP_NAME(_nc_mvcur) (CURRENT_SCREEN, yold, xold, ynew, xnew);\n}\n#endif\n\n#if defined(USE_TERM_DRIVER)\n/*\n * The terminal driver does not support the external \"mvcur()\".\n */\nNCURSES_EXPORT(int)\nTINFO_MVCUR(NCURSES_SP_DCLx int yold, int xold, int ynew, int xnew)\n{\n    int rc;\n    rc = _nc_real_mvcur(NCURSES_SP_ARGx\n\t\t\tyold, xold,\n\t\t\tynew, xnew,\n\t\t\tNCURSES_SP_NAME(_nc_outch),\n\t\t\tTRUE);\n    if ((SP_PARM != 0) && (SP_PARM->_endwin == ewInitial))\n\tNCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n    NCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n    return rc;\n}\n\n#else /* !USE_TERM_DRIVER */\n\n/*\n * These entrypoints support users of the library.\n */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(mvcur) (NCURSES_SP_DCLx int yold, int xold, int ynew,\n\t\t\tint xnew)\n{\n    return _nc_real_mvcur(NCURSES_SP_ARGx\n\t\t\t  yold, xold,\n\t\t\t  ynew, xnew,\n\t\t\t  NCURSES_SP_NAME(_nc_putchar),\n\t\t\t  FALSE);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nmvcur(int yold, int xold, int ynew, int xnew)\n{\n    return NCURSES_SP_NAME(mvcur) (CURRENT_SCREEN, yold, xold, ynew, xnew);\n}\n#endif\n#endif /* USE_TERM_DRIVER */\n\n#if defined(TRACE) || defined(NCURSES_TEST)\nNCURSES_EXPORT_VAR(int) _nc_optimize_enable = OPTIMIZE_ALL;\n#endif\n\n#if defined(MAIN) || defined(NCURSES_TEST)\n/****************************************************************************\n *\n * Movement optimizer test code\n *\n ****************************************************************************/\n\n#include <tic.h>\n#include <dump_entry.h>\n#include <time.h>\n\nNCURSES_EXPORT_VAR(const char *) _nc_progname = \"mvcur\";\n\nstatic unsigned long xmits;\n\n/* these override lib_tputs.c */\nNCURSES_EXPORT(int)\ntputs(const char *string, int affcnt GCC_UNUSED, int (*outc) (int) GCC_UNUSED)\n/* stub tputs() that dumps sequences in a visible form */\n{\n    if (profiling)\n\txmits += strlen(string);\n    else\n\t(void) fputs(_nc_visbuf(string), stdout);\n    return (OK);\n}\n\nNCURSES_EXPORT(int)\nputp(const char *string)\n{\n    return (tputs(string, 1, _nc_outch));\n}\n\nNCURSES_EXPORT(int)\n_nc_outch(int ch)\n{\n    putc(ch, stdout);\n    return OK;\n}\n\nNCURSES_EXPORT(int)\ndelay_output(int ms GCC_UNUSED)\n{\n    return OK;\n}\n\nstatic char tname[PATH_MAX];\n\nstatic void\nload_term(void)\n{\n    (void) setupterm(tname, STDOUT_FILENO, NULL);\n}\n\nstatic int\nroll(int n)\n{\n    int i, j;\n\n    i = (RAND_MAX / n) * n;\n    while ((j = rand()) >= i)\n\tcontinue;\n    return (j % n);\n}\n\nint\nmain(int argc GCC_UNUSED, char *argv[]GCC_UNUSED)\n{\n    _nc_STRCPY(tname, getenv(\"TERM\"), sizeof(tname));\n    load_term();\n    _nc_setupscreen(lines, columns, stdout, FALSE, 0);\n    baudrate();\n\n    _nc_mvcur_init();\n\n    (void) puts(\"The mvcur tester.  Type ? for help\");\n\n    fputs(\"smcup:\", stdout);\n    putchar('\\n');\n\n    for (;;) {\n\tint fy, fx, ty, tx, n, i;\n\tchar buf[BUFSIZ], capname[BUFSIZ];\n\n\tif (fputs(\"> \", stdout) == EOF)\n\t    break;\n\tif (fgets(buf, sizeof(buf), stdin) == 0)\n\t    break;\n\n\tif (buf[0] == '?') {\n\t    (void) puts(\"?                -- display this help message\");\n\t    (void)\n\t\tputs(\"fy fx ty tx      -- (4 numbers) display (fy,fx)->(ty,tx) move\");\n\t    (void) puts(\"s[croll] n t b m -- display scrolling sequence\");\n\t    (void)\n\t\tprintf(\"r[eload]         -- reload terminal info for %s\\n\",\n\t\t       termname());\n\t    (void)\n\t\tputs(\"l[oad] <term>    -- load terminal info for type <term>\");\n\t    (void) puts(\"d[elete] <cap>   -- delete named capability\");\n\t    (void) puts(\"i[nspect]        -- display terminal capabilities\");\n\t    (void)\n\t\tputs(\"c[ost]           -- dump cursor-optimization cost table\");\n\t    (void) puts(\"o[optimize]      -- toggle movement optimization\");\n\t    (void)\n\t\tputs(\"t[orture] <num>  -- torture-test with <num> random moves\");\n\t    (void) puts(\"q[uit]           -- quit the program\");\n\t} else if (sscanf(buf, \"%d %d %d %d\", &fy, &fx, &ty, &tx) == 4) {\n\t    struct timeval before, after;\n\n\t    putchar('\"');\n\n\t    gettimeofday(&before, NULL);\n\t    mvcur(fy, fx, ty, tx);\n\t    gettimeofday(&after, NULL);\n\n\t    printf(\"\\\" (%ld msec)\\n\",\n\t\t   (long) (after.tv_usec - before.tv_usec\n\t\t\t   + (after.tv_sec - before.tv_sec)\n\t\t\t   * 1000000));\n\t} else if (sscanf(buf, \"s %d %d %d %d\", &fy, &fx, &ty, &tx) == 4) {\n\t    struct timeval before, after;\n\n\t    putchar('\"');\n\n\t    gettimeofday(&before, NULL);\n\t    _nc_scrolln(fy, fx, ty, tx);\n\t    gettimeofday(&after, NULL);\n\n\t    printf(\"\\\" (%ld msec)\\n\",\n\t\t   (long) (after.tv_usec - before.tv_usec + (after.tv_sec -\n\t\t\t\t\t\t\t     before.tv_sec)\n\t\t\t   * 1000000));\n\t} else if (buf[0] == 'r') {\n\t    _nc_STRCPY(tname, termname(), sizeof(tname));\n\t    load_term();\n\t} else if (sscanf(buf, \"l %s\", tname) == 1) {\n\t    load_term();\n\t} else if (sscanf(buf, \"d %s\", capname) == 1) {\n\t    struct name_table_entry const *np = _nc_find_entry(capname,\n\t\t\t\t\t\t\t       _nc_get_hash_table(FALSE));\n\n\t    if (np == NULL)\n\t\t(void) printf(\"No such capability as \\\"%s\\\"\\n\", capname);\n\t    else {\n\t\tswitch (np->nte_type) {\n\t\tcase BOOLEAN:\n\t\t    cur_term->type.Booleans[np->nte_index] = FALSE;\n\t\t    (void)\n\t\t\tprintf(\"Boolean capability `%s' (%d) turned off.\\n\",\n\t\t\t       np->nte_name, np->nte_index);\n\t\t    break;\n\n\t\tcase NUMBER:\n\t\t    cur_term->type.Numbers[np->nte_index] = ABSENT_NUMERIC;\n\t\t    (void) printf(\"Number capability `%s' (%d) set to -1.\\n\",\n\t\t\t\t  np->nte_name, np->nte_index);\n\t\t    break;\n\n\t\tcase STRING:\n\t\t    cur_term->type.Strings[np->nte_index] = ABSENT_STRING;\n\t\t    (void) printf(\"String capability `%s' (%d) deleted.\\n\",\n\t\t\t\t  np->nte_name, np->nte_index);\n\t\t    break;\n\t\t}\n\t    }\n\t} else if (buf[0] == 'i') {\n\t    dump_init(NULL, F_TERMINFO, S_TERMINFO,\n\t\t      FALSE, 70, 0, 0, FALSE, FALSE, 0);\n\t    dump_entry(&TerminalType(cur_term), FALSE, TRUE, 0, 0);\n\t    putchar('\\n');\n\t} else if (buf[0] == 'o') {\n\t    if (_nc_optimize_enable & OPTIMIZE_MVCUR) {\n\t\t_nc_optimize_enable &= ~OPTIMIZE_MVCUR;\n\t\t(void) puts(\"Optimization is now off.\");\n\t    } else {\n\t\t_nc_optimize_enable |= OPTIMIZE_MVCUR;\n\t\t(void) puts(\"Optimization is now on.\");\n\t    }\n\t}\n\t/*\n\t * You can use the `t' test to profile and tune the movement\n\t * optimizer.  Use iteration values in three digits or more.\n\t * At above 5000 iterations the profile timing averages are stable\n\t * to within a millisecond or three.\n\t *\n\t * The `overhead' field of the report will help you pick a\n\t * COMPUTE_OVERHEAD figure appropriate for your processor and\n\t * expected line speed.  The `total estimated time' is\n\t * computation time plus a character-transmission time\n\t * estimate computed from the number of transmits and the baud\n\t * rate.\n\t *\n\t * Use this together with the `o' command to get a read on the\n\t * optimizer's effectiveness.  Compare the total estimated times\n\t * for `t' runs of the same length in both optimized and un-optimized\n\t * modes.  As long as the optimized times are less, the optimizer\n\t * is winning.\n\t */\n\telse if (sscanf(buf, \"t %d\", &n) == 1) {\n\t    float cumtime = 0.0, perchar;\n\t    int speeds[] =\n\t    {2400, 9600, 14400, 19200, 28800, 38400, 0};\n\n\t    srand((unsigned) (getpid() + time((time_t *) 0)));\n\t    profiling = TRUE;\n\t    xmits = 0;\n\t    for (i = 0; i < n; i++) {\n\t\t/*\n\t\t * This does a move test between two random locations,\n\t\t * Random moves probably short-change the optimizer,\n\t\t * which will work better on the short moves probably\n\t\t * typical of doupdate()'s usage pattern.  Still,\n\t\t * until we have better data...\n\t\t */\n#ifdef FIND_COREDUMP\n\t\tint from_y = roll(lines);\n\t\tint to_y = roll(lines);\n\t\tint from_x = roll(columns);\n\t\tint to_x = roll(columns);\n\n\t\tprintf(\"(%d,%d) -> (%d,%d)\\n\", from_y, from_x, to_y, to_x);\n\t\tmvcur(from_y, from_x, to_y, to_x);\n#else\n\t\tmvcur(roll(lines), roll(columns), roll(lines), roll(columns));\n#endif /* FIND_COREDUMP */\n\t\tif (diff)\n\t\t    cumtime += diff;\n\t    }\n\t    profiling = FALSE;\n\n\t    /*\n\t     * Average milliseconds per character optimization time.\n\t     * This is the key figure to watch when tuning the optimizer.\n\t     */\n\t    perchar = cumtime / n;\n\n\t    (void) printf(\"%d moves (%ld chars) in %d msec, %f msec each:\\n\",\n\t\t\t  n, xmits, (int) cumtime, perchar);\n\n\t    for (i = 0; speeds[i]; i++) {\n\t\t/*\n\t\t * Total estimated time for the moves, computation and\n\t\t * transmission both. Transmission time is an estimate\n\t\t * assuming 9 bits/char, 8 bits + 1 stop bit.\n\t\t */\n\t\tfloat totalest = cumtime + xmits * 9 * 1e6 / speeds[i];\n\n\t\t/*\n\t\t * Per-character optimization overhead in character transmits\n\t\t * at the current speed.  Round this to the nearest integer\n\t\t * to figure COMPUTE_OVERHEAD for the speed.\n\t\t */\n\t\tfloat overhead = speeds[i] * perchar / 1e6;\n\n\t\t(void)\n\t\t    printf(\"%6d bps: %3.2f char-xmits overhead; total estimated time %15.2f\\n\",\n\t\t\t   speeds[i], overhead, totalest);\n\t    }\n\t} else if (buf[0] == 'c') {\n\t    (void) printf(\"char padding: %d\\n\", CURRENT_SCREEN->_char_padding);\n\t    (void) printf(\"cr cost: %d\\n\", CURRENT_SCREEN->_cr_cost);\n\t    (void) printf(\"cup cost: %d\\n\", CURRENT_SCREEN->_cup_cost);\n\t    (void) printf(\"home cost: %d\\n\", CURRENT_SCREEN->_home_cost);\n\t    (void) printf(\"ll cost: %d\\n\", CURRENT_SCREEN->_ll_cost);\n#if USE_HARD_TABS\n\t    (void) printf(\"ht cost: %d\\n\", CURRENT_SCREEN->_ht_cost);\n\t    (void) printf(\"cbt cost: %d\\n\", CURRENT_SCREEN->_cbt_cost);\n#endif /* USE_HARD_TABS */\n\t    (void) printf(\"cub1 cost: %d\\n\", CURRENT_SCREEN->_cub1_cost);\n\t    (void) printf(\"cuf1 cost: %d\\n\", CURRENT_SCREEN->_cuf1_cost);\n\t    (void) printf(\"cud1 cost: %d\\n\", CURRENT_SCREEN->_cud1_cost);\n\t    (void) printf(\"cuu1 cost: %d\\n\", CURRENT_SCREEN->_cuu1_cost);\n\t    (void) printf(\"cub cost: %d\\n\", CURRENT_SCREEN->_cub_cost);\n\t    (void) printf(\"cuf cost: %d\\n\", CURRENT_SCREEN->_cuf_cost);\n\t    (void) printf(\"cud cost: %d\\n\", CURRENT_SCREEN->_cud_cost);\n\t    (void) printf(\"cuu cost: %d\\n\", CURRENT_SCREEN->_cuu_cost);\n\t    (void) printf(\"hpa cost: %d\\n\", CURRENT_SCREEN->_hpa_cost);\n\t    (void) printf(\"vpa cost: %d\\n\", CURRENT_SCREEN->_vpa_cost);\n\t} else if (buf[0] == 'x' || buf[0] == 'q')\n\t    break;\n\telse\n\t    (void) puts(\"Invalid command.\");\n    }\n\n    (void) fputs(\"rmcup:\", stdout);\n    _nc_mvcur_wrap();\n    putchar('\\n');\n\n    return (0);\n}\n\n#endif /* MAIN */\n\n/* lib_mvcur.c ends here */\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n**\tlib_newterm.c\n**\n**\tThe newterm() function.\n**\n*/\n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\n#include <tic.h>\n\nMODULE_ID(\"$Id: lib_newterm.c,v 1.100 2017/07/22 23:19:00 tom Exp $\")\n\n#ifdef USE_TERM_DRIVER\n#define NumLabels      InfoOf(SP_PARM).numlabels\n#else\n#define NumLabels      num_labels\n#endif\n\n#ifndef ONLCR\t\t\t/* Allows compilation under the QNX 4.2 OS */\n#define ONLCR 0\n#endif\n\n/*\n * SVr4/XSI Curses specify that hardware echo is turned off in initscr, and not\n * restored during the curses session.  The library simulates echo in software.\n * (The behavior is unspecified if the application enables hardware echo).\n *\n * The newterm function also initializes terminal settings, and since initscr\n * is supposed to behave as if it calls newterm, we do it here.\n */\nstatic NCURSES_INLINE int\n_nc_initscr(NCURSES_SP_DCL0)\n{\n    int result = ERR;\n    TERMINAL *term = TerminalOf(SP_PARM);\n\n    /* for extended XPG4 conformance requires cbreak() at this point */\n    /* (SVr4 curses does this anyway) */\n    T((T_CALLED(\"_nc_initscr(%p) ->term %p\"), (void *) SP_PARM, (void *) term));\n    if (NCURSES_SP_NAME(cbreak) (NCURSES_SP_ARG) == OK) {\n\tTTY buf;\n\n\tbuf = term->Nttyb;\n#ifdef TERMIOS\n\tbuf.c_lflag &= (unsigned) ~(ECHO | ECHONL);\n\tbuf.c_iflag &= (unsigned) ~(ICRNL | INLCR | IGNCR);\n\tbuf.c_oflag &= (unsigned) ~(ONLCR);\n#elif HAVE_SGTTY_H\n\tbuf.sg_flags &= ~(ECHO | CRMOD);\n#else\n\tmemset(&buf, 0, sizeof(buf));\n#endif\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n\tif (result == OK)\n\t    term->Nttyb = buf;\n    }\n    returnCode(result);\n}\n\n/*\n * filter() has to be called before either initscr() or newterm(), so there is\n * apparently no way to make this flag apply to some terminals and not others,\n * aside from possibly delaying a filter() call until some terminals have been\n * initialized.\n */\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(filter) (NCURSES_SP_DCL0)\n{\n    START_TRACE();\n    T((T_CALLED(\"filter(%p)\"), (void *) SP_PARM));\n#if NCURSES_SP_FUNCS\n    if (IsPreScreen(SP_PARM)) {\n\tSP_PARM->_filtered = TRUE;\n    }\n#else\n    _nc_prescreen.filter_mode = TRUE;\n#endif\n    returnVoid;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\nfilter(void)\n{\n    START_TRACE();\n    T((T_CALLED(\"filter()\")));\n    _nc_prescreen.filter_mode = TRUE;\n    returnVoid;\n}\n#endif\n\n#if NCURSES_EXT_FUNCS\n/*\n * An extension, allowing the application to open a new screen without\n * requiring it to also be filtered.\n */\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(nofilter) (NCURSES_SP_DCL0)\n{\n    START_TRACE();\n    T((T_CALLED(\"nofilter(%p)\"), (void *) SP_PARM));\n#if NCURSES_SP_FUNCS\n    if (IsPreScreen(SP_PARM)) {\n\tSP_PARM->_filtered = FALSE;\n    }\n#else\n    _nc_prescreen.filter_mode = FALSE;\n#endif\n    returnVoid;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\nnofilter(void)\n{\n    START_TRACE();\n    T((T_CALLED(\"nofilter()\")));\n    _nc_prescreen.filter_mode = FALSE;\n    returnVoid;\n}\n#endif\n#endif /* NCURSES_EXT_FUNCS */\n\nNCURSES_EXPORT(SCREEN *)\nNCURSES_SP_NAME(newterm) (NCURSES_SP_DCLx\n\t\t\t  NCURSES_CONST char *name,\n\t\t\t  FILE *ofp,\n\t\t\t  FILE *ifp)\n{\n    int errret;\n    SCREEN *result = 0;\n    SCREEN *current;\n    TERMINAL *its_term;\n    FILE *_ofp = ofp ? ofp : stdout;\n    FILE *_ifp = ifp ? ifp : stdin;\n    TERMINAL *new_term = 0;\n\n    START_TRACE();\n    T((T_CALLED(\"newterm(%p, \\\"%s\\\", %p,%p)\"),\n       (void *) SP_PARM,\n       (name ? name : \"\"),\n       (void *) ofp,\n       (void *) ifp));\n\n#if NCURSES_SP_FUNCS\n    assert(SP_PARM != 0);\n    if (SP_PARM == 0)\n\treturnSP(SP_PARM);\n#endif\n\n    _nc_init_pthreads();\n    _nc_lock_global(curses);\n\n    current = CURRENT_SCREEN;\n    its_term = (current ? current->_term : 0);\n\n    INIT_TERM_DRIVER();\n    /* this loads the capability entry, then sets LINES and COLS */\n    if (\n\t   TINFO_SETUP_TERM(&new_term, name,\n\t\t\t    fileno(_ofp), &errret, FALSE) != ERR) {\n\tint slk_format;\n\tint filter_mode;\n\n\t_nc_set_screen(0);\n#ifdef USE_TERM_DRIVER\n\tassert(new_term != 0);\n#endif\n\n#if NCURSES_SP_FUNCS\n\tslk_format = SP_PARM->slk_format;\n\tfilter_mode = SP_PARM->_filtered;\n#else\n\tslk_format = _nc_globals.slk_format;\n\tfilter_mode = _nc_prescreen.filter_mode;\n#endif\n\n\t/*\n\t * This actually allocates the screen structure, and saves the original\n\t * terminal settings.\n\t */\n\tif (NCURSES_SP_NAME(_nc_setupscreen) (\n#if NCURSES_SP_FUNCS\n\t\t\t\t\t\t &SP_PARM,\n#endif\n\t\t\t\t\t\t *(ptrLines(SP_PARM)),\n\t\t\t\t\t\t *(ptrCols(SP_PARM)),\n\t\t\t\t\t\t _ofp,\n\t\t\t\t\t\t filter_mode,\n\t\t\t\t\t\t slk_format) == ERR) {\n\t    _nc_set_screen(current);\n\t    result = 0;\n\t} else {\n\t    int value;\n\t    int cols;\n\n#ifdef USE_TERM_DRIVER\n\t    TERMINAL_CONTROL_BLOCK *TCB;\n#elif !NCURSES_SP_FUNCS\n\t    _nc_set_screen(CURRENT_SCREEN);\n#endif\n\t    assert(SP_PARM != 0);\n\t    cols = *(ptrCols(SP_PARM));\n#ifdef USE_TERM_DRIVER\n\t    _nc_set_screen(SP_PARM);\n\t    TCB = (TERMINAL_CONTROL_BLOCK *) new_term;\n\t    TCB->csp = SP_PARM;\n#endif\n\t    /*\n\t     * In setupterm() we did a set_curterm(), but it was before we set\n\t     * CURRENT_SCREEN.  So the \"current\" screen's terminal pointer was\n\t     * overwritten with a different terminal.  Later, in\n\t     * _nc_setupscreen(), we set CURRENT_SCREEN and the terminal\n\t     * pointer in the new screen.\n\t     *\n\t     * Restore the terminal-pointer for the pre-existing screen, if\n\t     * any.\n\t     */\n\t    if (current)\n\t\tcurrent->_term = its_term;\n\n#ifdef USE_TERM_DRIVER\n\t    SP_PARM->_term = new_term;\n#else\n\t    new_term = SP_PARM->_term;\n#endif\n\n\t    /* allow user to set maximum escape delay from the environment */\n\t    if ((value = _nc_getenv_num(\"ESCDELAY\")) >= 0) {\n#if NCURSES_EXT_FUNCS\n\t\tNCURSES_SP_NAME(set_escdelay) (NCURSES_SP_ARGx value);\n#else\n\t\tESCDELAY = value;\n#endif\n\t    }\n\n\t    /* if the terminal type has real soft labels, set those up */\n\t    if (slk_format && NumLabels > 0 && SLK_STDFMT(slk_format))\n\t\t_nc_slk_initialize(StdScreen(SP_PARM), cols);\n\n\t    SP_PARM->_ifd = fileno(_ifp);\n\t    NCURSES_SP_NAME(typeahead) (NCURSES_SP_ARGx fileno(_ifp));\n#ifdef TERMIOS\n\t    SP_PARM->_use_meta = ((new_term->Ottyb.c_cflag & CSIZE) == CS8 &&\n\t\t\t\t  !(new_term->Ottyb.c_iflag & ISTRIP)) ||\n\t\tUSE_KLIBC_KBD;\n#else\n\t    SP_PARM->_use_meta = FALSE;\n#endif\n\t    SP_PARM->_endwin = ewInitial;\n#ifndef USE_TERM_DRIVER\n\t    /*\n\t     * Check whether we can optimize scrolling under dumb terminals in\n\t     * case we do not have any of these capabilities, scrolling\n\t     * optimization will be useless.\n\t     */\n\t    SP_PARM->_scrolling = ((scroll_forward && scroll_reverse) ||\n\t\t\t\t   ((parm_rindex ||\n\t\t\t\t     parm_insert_line ||\n\t\t\t\t     insert_line) &&\n\t\t\t\t    (parm_index ||\n\t\t\t\t     parm_delete_line ||\n\t\t\t\t     delete_line)));\n#endif\n\n\t    NCURSES_SP_NAME(baudrate) (NCURSES_SP_ARG);\t\t/* sets a field in the screen structure */\n\n\t    SP_PARM->_keytry = 0;\n\n\t    /* compute movement costs so we can do better move optimization */\n#ifdef USE_TERM_DRIVER\n\t    TCBOf(SP_PARM)->drv->td_scinit(SP_PARM);\n#else /* ! USE_TERM_DRIVER */\n\t    /*\n\t     * Check for mismatched graphic-rendition capabilities.  Most SVr4\n\t     * terminfo trees contain entries that have rmul or rmso equated to\n\t     * sgr0 (Solaris curses copes with those entries).  We do this only\n\t     * for curses, since many termcap applications assume that\n\t     * smso/rmso and smul/rmul are paired, and will not function\n\t     * properly if we remove rmso or rmul.  Curses applications\n\t     * shouldn't be looking at this detail.\n\t     */\n#define SGR0_TEST(mode) (mode != 0) && (exit_attribute_mode == 0 || strcmp(mode, exit_attribute_mode))\n\t    SP_PARM->_use_rmso = SGR0_TEST(exit_standout_mode);\n\t    SP_PARM->_use_rmul = SGR0_TEST(exit_underline_mode);\n#if USE_ITALIC\n\t    SP_PARM->_use_ritm = SGR0_TEST(exit_italics_mode);\n#endif\n\n\t    /* compute movement costs so we can do better move optimization */\n\t    _nc_mvcur_init();\n\n\t    /* initialize terminal to a sane state */\n\t    _nc_screen_init();\n#endif /* USE_TERM_DRIVER */\n\n\t    /* Initialize the terminal line settings. */\n\t    _nc_initscr(NCURSES_SP_ARG);\n\n\t    _nc_signal_handler(TRUE);\n\t    result = SP_PARM;\n\t}\n    }\n    _nc_unlock_global(curses);\n    returnSP(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(SCREEN *)\nnewterm(NCURSES_CONST char *name, FILE *ofp, FILE *ifp)\n{\n    SCREEN *rc;\n    _nc_lock_global(prescreen);\n    START_TRACE();\n    rc = NCURSES_SP_NAME(newterm) (CURRENT_SCREEN_PRE, name, ofp, ifp);\n    _nc_forget_prescr();\n    _nc_unlock_global(prescreen);\n    return rc;\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2008,2009 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n *\tnl.c\n *\n *\tRoutines:\n *\t\tnl()\n *\t\tnonl()\n *\n */\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_nl.c,v 1.12 2009/10/24 22:05:55 tom Exp $\")\n\n#ifdef __EMX__\n#include <io.h>\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(nl) (NCURSES_SP_DCL0)\n{\n    T((T_CALLED(\"nl(%p)\"), (void *) SP_PARM));\n    if (0 == SP_PARM)\n\treturnCode(ERR);\n    SP_PARM->_nl = TRUE;\n#ifdef __EMX__\n    _nc_flush();\n    _fsetmode(NC_OUTPUT(SP_PARM), \"t\");\n#endif\n    returnCode(OK);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nnl(void)\n{\n    return NCURSES_SP_NAME(nl) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(nonl) (NCURSES_SP_DCL0)\n{\n    T((T_CALLED(\"nonl(%p)\"), (void *) SP_PARM));\n    if (0 == SP_PARM)\n\treturnCode(ERR);\n    SP_PARM->_nl = FALSE;\n#ifdef __EMX__\n    _nc_flush();\n    _fsetmode(NC_OUTPUT(SP_PARM), \"b\");\n#endif\n    returnCode(OK);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nnonl(void)\n{\n    return NCURSES_SP_NAME(nonl) (CURRENT_SCREEN);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2010,2011 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                                                 *\n ****************************************************************************/\n\n/*\n *\tlib_refresh.c\n *\n *\tThe routines wrefresh() and wnoutrefresh().\n *\n */\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_refresh.c,v 1.45 2011/06/25 19:02:22 Vassili.Courzakis Exp $\")\n\nNCURSES_EXPORT(int)\nwrefresh(WINDOW *win)\n{\n    int code;\n#if NCURSES_SP_FUNCS\n    SCREEN *SP_PARM = _nc_screen_of(win);\n#endif\n\n    T((T_CALLED(\"wrefresh(%p)\"), (void *) win));\n\n    if (win == 0) {\n\tcode = ERR;\n    } else if (win == CurScreen(SP_PARM)) {\n\tCurScreen(SP_PARM)->_clear = TRUE;\n\tcode = NCURSES_SP_NAME(doupdate) (NCURSES_SP_ARG);\n    } else if ((code = wnoutrefresh(win)) == OK) {\n\tif (win->_clear)\n\t    NewScreen(SP_PARM)->_clear = TRUE;\n\tcode = NCURSES_SP_NAME(doupdate) (NCURSES_SP_ARG);\n\t/*\n\t * Reset the clearok() flag in case it was set for the special\n\t * case in hardscroll.c (if we don't reset it here, we'll get 2\n\t * refreshes because the flag is copied from stdscr to newscr).\n\t * Resetting the flag shouldn't do any harm, anyway.\n\t */\n\twin->_clear = FALSE;\n    }\n    returnCode(code);\n}\n\nNCURSES_EXPORT(int)\nwnoutrefresh(WINDOW *win)\n{\n    int limit_x;\n    int src_row, src_col;\n    int begx;\n    int begy;\n    int dst_row, dst_col;\n#if USE_SCROLL_HINTS\n    bool wide;\n#endif\n#if NCURSES_SP_FUNCS\n    SCREEN *SP_PARM = _nc_screen_of(win);\n#endif\n\n    T((T_CALLED(\"wnoutrefresh(%p)\"), (void *) win));\n\n    /*\n     * This function will break badly if we try to refresh a pad.\n     */\n    if ((win == 0)\n\t|| (win->_flags & _ISPAD))\n\treturnCode(ERR);\n\n#ifdef TRACE\n    if (USE_TRACEF(TRACE_UPDATE)) {\n\t_tracedump(\"...win\", win);\n\t_nc_unlock_global(tracef);\n    }\n#endif /* TRACE */\n\n    /* put them here so \"win == 0\" won't break our code */\n    begx = win->_begx;\n    begy = win->_begy;\n\n    NewScreen(SP_PARM)->_nc_bkgd = win->_nc_bkgd;\n    WINDOW_ATTRS(NewScreen(SP_PARM)) = WINDOW_ATTRS(win);\n\n    /* merge in change information from all subwindows of this window */\n    wsyncdown(win);\n\n#if USE_SCROLL_HINTS\n    /*\n     * For pure efficiency, we'd want to transfer scrolling information\n     * from the window to newscr whenever the window is wide enough that\n     * its update will dominate the cost of the update for the horizontal\n     * band of newscr that it occupies.  Unfortunately, this threshold\n     * tends to be complex to estimate, and in any case scrolling the\n     * whole band and rewriting the parts outside win's image would look\n     * really ugly.  So.  What we do is consider the window \"wide\" if it\n     * either (a) occupies the whole width of newscr, or (b) occupies\n     * all but at most one column on either vertical edge of the screen\n     * (this caters to fussy people who put boxes around full-screen\n     * windows).  Note that changing this formula will not break any code,\n     * merely change the costs of various update cases.\n     */\n    wide = (begx <= 1 && win->_maxx >= (NewScreen(SP_PARM)->_maxx - 1));\n#endif\n\n    win->_flags &= ~_HASMOVED;\n\n    /*\n     * Microtweaking alert!  This double loop is one of the genuine\n     * hot spots in the code.  Even gcc doesn't seem to do enough\n     * common-subexpression chunking to make it really tense,\n     * so we'll force the issue.\n     */\n\n    /* limit(dst_col) */\n    limit_x = win->_maxx;\n    /* limit(src_col) */\n    if (limit_x > NewScreen(SP_PARM)->_maxx - begx)\n\tlimit_x = NewScreen(SP_PARM)->_maxx - begx;\n\n    for (src_row = 0, dst_row = begy + win->_yoffset;\n\t src_row <= win->_maxy && dst_row <= NewScreen(SP_PARM)->_maxy;\n\t src_row++, dst_row++) {\n\tstruct ldat *nline = &(NewScreen(SP_PARM)->_line[dst_row]);\n\tstruct ldat *oline = &win->_line[src_row];\n\n\tif (oline->firstchar != _NOCHANGE) {\n\t    int last_src = oline->lastchar;\n\n\t    if (last_src > limit_x)\n\t\tlast_src = limit_x;\n\n\t    src_col = oline->firstchar;\n\t    dst_col = src_col + begx;\n\n\t    if_WIDEC({\n\t\tint j;\n\n\t\t/*\n\t\t * Ensure that we will copy complete multi-column characters\n\t\t * on the left-boundary.\n\t\t */\n\t\tif (isWidecExt(oline->text[src_col])) {\n\t\t    j = 1 + dst_col - WidecExt(oline->text[src_col]);\n\t\t    if (j < 0)\n\t\t\tj = 0;\n\t\t    if (dst_col > j) {\n\t\t\tsrc_col -= (dst_col - j);\n\t\t\tdst_col = j;\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Ensure that we will copy complete multi-column characters\n\t\t * on the right-boundary.\n\t\t */\n\t\tj = last_src;\n\t\tif (WidecExt(oline->text[j])) {\n\t\t    ++j;\n\t\t    while (j <= limit_x) {\n\t\t\tif (isWidecBase(oline->text[j])) {\n\t\t\t    break;\n\t\t\t} else {\n\t\t\t    last_src = j;\n\t\t\t}\n\t\t\t++j;\n\t\t    }\n\t\t}\n\t    });\n\n\t    if_WIDEC({\n\t\tstatic cchar_t blank = BLANK;\n\t\tint last_dst = begx + ((last_src < win->_maxx)\n\t\t\t\t       ? last_src\n\t\t\t\t       : win->_maxx);\n\t\tint fix_left = dst_col;\n\t\tint fix_right = last_dst;\n\t\tint j;\n\n\t\t/*\n\t\t * Check for boundary cases where we may overwrite part of a\n\t\t * multi-column character.  For those, wipe the remainder of\n\t\t * the character to blanks.\n\t\t */\n\t\tj = dst_col;\n\t\tif (isWidecExt(nline->text[j])) {\n\t\t    /*\n\t\t     * On the left, we only care about multi-column characters\n\t\t     * that extend into the changed region.\n\t\t     */\n\t\t    fix_left = 1 + j - WidecExt(nline->text[j]);\n\t\t    if (fix_left < 0)\n\t\t\tfix_left = 0;\t/* only if cell is corrupt */\n\t\t}\n\n\t\tj = last_dst;\n\t\tif (WidecExt(nline->text[j]) != 0) {\n\t\t    /*\n\t\t     * On the right, any multi-column character is a problem,\n\t\t     * unless it happens to be contained in the change, and\n\t\t     * ending at the right boundary of the change.  The\n\t\t     * computation for 'fix_left' accounts for the left-side of\n\t\t     * this character.  Find the end of the character.\n\t\t     */\n\t\t    ++j;\n\t\t    while (j <= NewScreen(SP_PARM)->_maxx &&\n\t\t\t   isWidecExt(nline->text[j])) {\n\t\t\tfix_right = j++;\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * The analysis is simpler if we do the clearing afterwards.\n\t\t * Do that now.\n\t\t */\n\t\tif (fix_left < dst_col || fix_right > last_dst) {\n\t\t    for (j = fix_left; j <= fix_right; ++j) {\n\t\t\tnline->text[j] = blank;\n\t\t\tCHANGED_CELL(nline, j);\n\t\t    }\n\t\t}\n\t    });\n\n\t    /*\n\t     * Copy the changed text.\n\t     */\n\t    for (; src_col <= last_src; src_col++, dst_col++) {\n\t\tif (!CharEq(oline->text[src_col], nline->text[dst_col])) {\n\t\t    nline->text[dst_col] = oline->text[src_col];\n\t\t    CHANGED_CELL(nline, dst_col);\n\t\t}\n\t    }\n\n\t}\n#if USE_SCROLL_HINTS\n\tif (wide) {\n\t    int oind = oline->oldindex;\n\n\t    nline->oldindex = ((oind == _NEWINDEX)\n\t\t\t       ? _NEWINDEX\n\t\t\t       : (begy + oind + win->_yoffset));\n\t}\n#endif /* USE_SCROLL_HINTS */\n\n\toline->firstchar = oline->lastchar = _NOCHANGE;\n\tif_USE_SCROLL_HINTS(oline->oldindex = src_row);\n    }\n\n    if (win->_clear) {\n\twin->_clear = FALSE;\n\tNewScreen(SP_PARM)->_clear = TRUE;\n    }\n\n    if (!win->_leaveok) {\n\tNewScreen(SP_PARM)->_cury = (NCURSES_SIZE_T) (win->_cury +\n\t\t\t\t\t\t      win->_begy + win->_yoffset);\n\tNewScreen(SP_PARM)->_curx = (NCURSES_SIZE_T) (win->_curx + win->_begx);\n    }\n    NewScreen(SP_PARM)->_leaveok = win->_leaveok;\n\n#ifdef TRACE\n    if (USE_TRACEF(TRACE_UPDATE)) {\n\t_tracedump(\"newscr\", NewScreen(SP_PARM));\n\t_nc_unlock_global(tracef);\n    }\n#endif /* TRACE */\n    returnCode(OK);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2010,2011 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey 1996-2003                                      *\n *     and: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n ****************************************************************************/\n\n/*\n**\tlib_scroll.c\n**\n**\tThe routine wscrl(win, n).\n**  positive n scroll the window up (ie. move lines down)\n**  negative n scroll the window down (ie. move lines up)\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_scroll.c,v 1.29 2011/10/22 16:34:50 tom Exp $\")\n\nNCURSES_EXPORT(void)\n_nc_scroll_window(WINDOW *win,\n\t\t  int const n,\n\t\t  int const top,\n\t\t  int const bottom,\n\t\t  NCURSES_CH_T blank)\n{\n    int limit;\n    int line;\n    int j;\n    size_t to_copy = (sizeof(NCURSES_CH_T) * (size_t) (win->_maxx + 1));\n\n    TR(TRACE_MOVE, (\"_nc_scroll_window(%p, %d, %ld, %ld)\",\n\t\t    (void *) win, n, (long) top, (long) bottom));\n\n    if (top < 0\n\t|| bottom < top\n\t|| bottom > win->_maxy) {\n\tTR(TRACE_MOVE, (\"nothing to scroll\"));\n\treturn;\n    }\n\n    /*\n     * This used to do a line-text pointer-shuffle instead of text copies.\n     * That (a) doesn't work when the window is derived and doesn't have\n     * its own storage, (b) doesn't save you a lot on modern machines\n     * anyway.  Your typical memcpy implementations are coded in\n     * assembler using a tight BLT loop; for the size of copies we're\n     * talking here, the total execution time is dominated by the one-time\n     * setup cost.  So there is no point in trying to be excessively\n     * clever -- esr.\n     */\n\n    /* shift n lines downwards */\n    if (n < 0) {\n\tlimit = top - n;\n\tfor (line = bottom; line >= limit && line >= 0; line--) {\n\t    TR(TRACE_MOVE, (\"...copying %d to %d\", line + n, line));\n\t    memcpy(win->_line[line].text,\n\t\t   win->_line[line + n].text,\n\t\t   to_copy);\n\t    if_USE_SCROLL_HINTS(win->_line[line].oldindex =\n\t\t\t\twin->_line[line + n].oldindex);\n\t}\n\tfor (line = top; line < limit && line <= win->_maxy; line++) {\n\t    TR(TRACE_MOVE, (\"...filling %d\", line));\n\t    for (j = 0; j <= win->_maxx; j++)\n\t\twin->_line[line].text[j] = blank;\n\t    if_USE_SCROLL_HINTS(win->_line[line].oldindex = _NEWINDEX);\n\t}\n    }\n\n    /* shift n lines upwards */\n    if (n > 0) {\n\tlimit = bottom - n;\n\tfor (line = top; line <= limit && line <= win->_maxy; line++) {\n\t    memcpy(win->_line[line].text,\n\t\t   win->_line[line + n].text,\n\t\t   to_copy);\n\t    if_USE_SCROLL_HINTS(win->_line[line].oldindex =\n\t\t\t\twin->_line[line + n].oldindex);\n\t}\n\tfor (line = bottom; line > limit && line >= 0; line--) {\n\t    for (j = 0; j <= win->_maxx; j++)\n\t\twin->_line[line].text[j] = blank;\n\t    if_USE_SCROLL_HINTS(win->_line[line].oldindex = _NEWINDEX);\n\t}\n    }\n    touchline(win, top, bottom - top + 1);\n\n    if_WIDEC({\n\tif (WINDOW_EXT(win, addch_used) != 0) {\n\t    int next = WINDOW_EXT(win, addch_y) + n;\n\t    if (next < 0 || next > win->_maxy) {\n\t\tTR(TRACE_VIRTPUT,\n\t\t   (\"Alert discarded multibyte on scroll\"));\n\t\tWINDOW_EXT(win, addch_y) = 0;\n\t    } else {\n\t\tTR(TRACE_VIRTPUT, (\"scrolled working position to %d,%d\",\n\t\t\t\t   WINDOW_EXT(win, addch_y),\n\t\t\t\t   WINDOW_EXT(win, addch_x)));\n\t\tWINDOW_EXT(win, addch_y) = next;\n\t    }\n\t}\n    })\n}\n\nNCURSES_EXPORT(int)\nwscrl(WINDOW *win, int n)\n{\n    T((T_CALLED(\"wscrl(%p,%d)\"), (void *) win, n));\n\n    if (!win || !win->_scroll) {\n\tTR(TRACE_MOVE, (\"...scrollok is false\"));\n\treturnCode(ERR);\n    }\n\n    if (n != 0) {\n\t_nc_scroll_window(win, n, win->_regtop, win->_regbottom, win->_nc_bkgd);\n\t_nc_synchook(win);\n    }\n    returnCode(OK);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n**\tlib_set_term.c\n**\n**\tThe routine set_term().\n**\n*/\n\n#include <curses.priv.h>\n#include <tic.h>\n\n#undef CUR\n#define CUR SP_TERMTYPE\n\nMODULE_ID(\"$Id: lib_set_term.c,v 1.167 2017/09/10 21:09:16 tom Exp $\")\n\n#ifdef USE_TERM_DRIVER\n#define MaxColors      InfoOf(sp).maxcolors\n#define NumLabels      InfoOf(sp).numlabels\n#else\n#define MaxColors      max_colors\n#define NumLabels      num_labels\n#endif\n\nNCURSES_EXPORT(SCREEN *)\nset_term(SCREEN *screenp)\n{\n    SCREEN *oldSP;\n    SCREEN *newSP;\n\n    T((T_CALLED(\"set_term(%p)\"), (void *) screenp));\n\n    _nc_lock_global(curses);\n\n    oldSP = CURRENT_SCREEN;\n    _nc_set_screen(screenp);\n    newSP = screenp;\n\n    if (newSP != 0) {\n\tTINFO_SET_CURTERM(newSP, newSP->_term);\n#if !USE_REENTRANT\n\tcurscr = CurScreen(newSP);\n\tnewscr = NewScreen(newSP);\n\tstdscr = StdScreen(newSP);\n\tCOLORS = newSP->_color_count;\n\tCOLOR_PAIRS = newSP->_pair_count;\n#endif\n    } else {\n\tTINFO_SET_CURTERM(oldSP, 0);\n#if !USE_REENTRANT\n\tcurscr = 0;\n\tnewscr = 0;\n\tstdscr = 0;\n\tCOLORS = 0;\n\tCOLOR_PAIRS = 0;\n#endif\n    }\n\n    _nc_unlock_global(curses);\n\n    T((T_RETURN(\"%p\"), (void *) oldSP));\n    return (oldSP);\n}\n\nstatic void\n_nc_free_keytry(TRIES * kt)\n{\n    if (kt != 0) {\n\t_nc_free_keytry(kt->child);\n\t_nc_free_keytry(kt->sibling);\n\tfree(kt);\n    }\n}\n\nstatic bool\ndelink_screen(SCREEN *sp)\n{\n    SCREEN *last = 0;\n    SCREEN *temp;\n    bool result = FALSE;\n\n    for (each_screen(temp)) {\n\tif (temp == sp) {\n\t    if (last)\n\t\tlast->_next_screen = sp->_next_screen;\n\t    else\n\t\t_nc_screen_chain = sp->_next_screen;\n\t    result = TRUE;\n\t    break;\n\t}\n\tlast = temp;\n    }\n    return result;\n}\n\n/*\n * Free the storage associated with the given SCREEN sp.\n */\nNCURSES_EXPORT(void)\ndelscreen(SCREEN *sp)\n{\n\n    T((T_CALLED(\"delscreen(%p)\"), (void *) sp));\n\n    _nc_lock_global(curses);\n    if (delink_screen(sp)) {\n#ifdef USE_SP_RIPOFF\n\tripoff_t *rop;\n\tif (safe_ripoff_sp && safe_ripoff_sp != safe_ripoff_stack) {\n\t    for (rop = safe_ripoff_stack;\n\t\t rop != safe_ripoff_sp && (rop - safe_ripoff_stack) < N_RIPS;\n\t\t rop++) {\n\t\tif (rop->win) {\n\t\t    (void) delwin(rop->win);\n\t\t    rop->win = 0;\n\t\t}\n\t    }\n\t}\n#endif\n\n\t(void) _nc_freewin(CurScreen(sp));\n\t(void) _nc_freewin(NewScreen(sp));\n\t(void) _nc_freewin(StdScreen(sp));\n\n\tif (sp->_slk != 0) {\n\n\t    if (sp->_slk->ent != 0) {\n\t\tint i;\n\n\t\tfor (i = 0; i < sp->_slk->labcnt; ++i) {\n\t\t    FreeIfNeeded(sp->_slk->ent[i].ent_text);\n\t\t    FreeIfNeeded(sp->_slk->ent[i].form_text);\n\t\t}\n\t\tfree(sp->_slk->ent);\n\t    }\n\t    free(sp->_slk);\n\t    sp->_slk = 0;\n\t}\n\n\t_nc_free_keytry(sp->_keytry);\n\tsp->_keytry = 0;\n\n\t_nc_free_keytry(sp->_key_ok);\n\tsp->_key_ok = 0;\n\n\tFreeIfNeeded(sp->_current_attr);\n\n\tFreeIfNeeded(sp->_color_table);\n\tFreeIfNeeded(sp->_color_pairs);\n\n\tFreeIfNeeded(sp->_oldnum_list);\n\tFreeIfNeeded(sp->oldhash);\n\tFreeIfNeeded(sp->newhash);\n\tFreeIfNeeded(sp->hashtab);\n\n\tFreeIfNeeded(sp->_acs_map);\n\tFreeIfNeeded(sp->_screen_acs_map);\n\n\tNCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n\tNCURSES_SP_NAME(del_curterm) (NCURSES_SP_ARGx sp->_term);\n\tFreeIfNeeded(sp->out_buffer);\n\tif (_nc_find_prescr() == sp) {\n\t    _nc_forget_prescr();\n\t}\n\tfree(sp);\n\n\t/*\n\t * If this was the current screen, reset everything that the\n\t * application might try to use (except cur_term, which may have\n\t * multiple references in different screens).\n\t */\n\tif (sp == CURRENT_SCREEN) {\n#if !USE_REENTRANT\n\t    curscr = 0;\n\t    newscr = 0;\n\t    stdscr = 0;\n\t    COLORS = 0;\n\t    COLOR_PAIRS = 0;\n#endif\n\t    _nc_set_screen(0);\n#if USE_WIDEC_SUPPORT\n\t    if (SP == 0) {\n\t\tFreeIfNeeded(_nc_wacs);\n\t\t_nc_wacs = 0;\n\t    }\n#endif\n\t}\n    }\n    _nc_unlock_global(curses);\n\n    returnVoid;\n}\n\nstatic bool\nno_mouse_event(SCREEN *sp GCC_UNUSED)\n{\n    return FALSE;\n}\n\nstatic bool\nno_mouse_inline(SCREEN *sp GCC_UNUSED)\n{\n    return FALSE;\n}\n\nstatic bool\nno_mouse_parse(SCREEN *sp GCC_UNUSED, int code GCC_UNUSED)\n{\n    return TRUE;\n}\n\nstatic void\nno_mouse_resume(SCREEN *sp GCC_UNUSED)\n{\n}\n\nstatic void\nno_mouse_wrap(SCREEN *sp GCC_UNUSED)\n{\n}\n\n#if NCURSES_EXT_FUNCS && USE_COLORFGBG\nstatic const char *\nextract_fgbg(const char *src, int *result)\n{\n    const char *dst = 0;\n    char *tmp = 0;\n    long value = strtol(src, &tmp, 0);\n\n    if ((dst = tmp) == 0) {\n\tdst = src;\n    } else if (value >= 0) {\n\t*result = (int) value;\n    }\n    while (*dst != 0 && *dst != ';')\n\tdst++;\n    if (*dst == ';')\n\tdst++;\n    return dst;\n}\n#endif\n\n#define ReturnScreenError() do { _nc_set_screen(0); \\\n                            returnCode(ERR); } while (0)\n\n/* OS-independent screen initializations */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_setupscreen) (\n#if NCURSES_SP_FUNCS\n\t\t\t\t     SCREEN **spp,\n#endif\n\t\t\t\t     int slines,\n\t\t\t\t     int scolumns,\n\t\t\t\t     FILE *output,\n\t\t\t\t     int filtered,\n\t\t\t\t     int slk_format)\n{\n#ifndef USE_TERM_DRIVER\n    static const TTY null_TTY;\t/* all zeros iff uninitialized */\n#endif\n    char *env;\n    int bottom_stolen = 0;\n    SCREEN *sp;\n#ifndef USE_TERM_DRIVER\n    bool support_cookies = USE_XMC_SUPPORT;\n#endif\n\n    T((T_CALLED(\"_nc_setupscreen(%d, %d, %p, %d, %d)\"),\n       slines, scolumns, (void *) output, filtered, slk_format));\n\n    assert(CURRENT_SCREEN == 0);\t/* has been reset in newterm() ! */\n\n#if NCURSES_SP_FUNCS\n    assert(spp != 0);\n    sp = *spp;\n\n    if (!sp) {\n\tsp = _nc_alloc_screen_sp();\n\tT((\"_nc_alloc_screen_sp %p\", (void *) sp));\n\t*spp = sp;\n    }\n    if (!sp\n\t|| ((sp->_acs_map = typeCalloc(chtype, ACS_LEN)) == 0)\n\t|| ((sp->_screen_acs_map = typeCalloc(bool, ACS_LEN)) == 0)) {\n\tReturnScreenError();\n    }\n\n    T((\"created SP %p\", (void *) sp));\n    sp->_next_screen = _nc_screen_chain;\n    _nc_screen_chain = sp;\n\n    if ((sp->_current_attr = typeCalloc(NCURSES_CH_T, 1)) == 0) {\n\tReturnScreenError();\n    }\n#else\n    if (!_nc_alloc_screen()\n\t|| ((SP->_acs_map = typeCalloc(chtype, ACS_LEN)) == 0)\n\t|| ((SP->_screen_acs_map = typeCalloc(bool, ACS_LEN)) == 0)) {\n\treturnCode(ERR);\n    }\n\n    T((\"created SP %p\", (void *) SP));\n\n    sp = SP;\t\t\t/* fixup so SET_LINES and SET_COLS works */\n    sp->_next_screen = _nc_screen_chain;\n    _nc_screen_chain = sp;\n\n    if ((sp->_current_attr = typeCalloc(NCURSES_CH_T, 1)) == 0)\n\treturnCode(ERR);\n#endif\n\n    /*\n     * We should always check the screensize, just in case.\n     */\n    _nc_set_screen(sp);\n    sp->_term = cur_term;\n#ifdef USE_TERM_DRIVER\n    TCBOf(sp)->csp = sp;\n    _nc_get_screensize(sp, sp->_term, &slines, &scolumns);\n#else\n    _nc_get_screensize(sp, &slines, &scolumns);\n#endif\n    SET_LINES(slines);\n    SET_COLS(scolumns);\n\n    T((T_CREATE(\"screen %s %dx%d\"),\n       NCURSES_SP_NAME(termname) (NCURSES_SP_ARG), slines, scolumns));\n\n    sp->_filtered = filtered;\n\n    /* implement filter mode */\n    if (filtered) {\n\tslines = 1;\n\tSET_LINES(slines);\n#ifdef USE_TERM_DRIVER\n\tCallDriver(sp, td_setfilter);\n#else\n\t/* *INDENT-EQLS* */\n\tclear_screen     = ABSENT_STRING;\n\tcursor_address   = ABSENT_STRING;\n\tcursor_down      = ABSENT_STRING;\n\tcursor_up        = ABSENT_STRING;\n\tparm_down_cursor = ABSENT_STRING;\n\tparm_up_cursor   = ABSENT_STRING;\n\trow_address      = ABSENT_STRING;\n\tcursor_home      = carriage_return;\n\n\tif (back_color_erase)\n\t    clr_eos = ABSENT_STRING;\n\n#endif\n\tT((\"filter screensize %dx%d\", slines, scolumns));\n    }\n#ifdef __DJGPP__\n    T((\"setting output mode to binary\"));\n    fflush(output);\n    setmode(output, O_BINARY);\n#endif\n    NCURSES_SP_NAME(_nc_set_buffer) (NCURSES_SP_ARGx output, TRUE);\n    sp->_lines = (NCURSES_SIZE_T) slines;\n    sp->_lines_avail = (NCURSES_SIZE_T) slines;\n    sp->_columns = (NCURSES_SIZE_T) scolumns;\n\n    fflush(output);\n    sp->_ofd = output ? fileno(output) : -1;\n    sp->_ofp = output;\n    sp->out_limit = (size_t) ((2 + slines) * (6 + scolumns));\n    if ((sp->out_buffer = malloc(sp->out_limit)) == 0)\n\tsp->out_limit = 0;\n    sp->out_inuse = 0;\n\n    SP_PRE_INIT(sp);\n    SetNoPadding(sp);\n\n#if NCURSES_EXT_FUNCS\n    sp->_default_color = FALSE;\n    sp->_has_sgr_39_49 = FALSE;\n\n    /*\n     * Set our assumption of the terminal's default foreground and background\n     * colors.  The curs_color man-page states that we can assume that the\n     * background is black.  The origin of this assumption appears to be\n     * terminals that displayed colored text, but no colored backgrounds, e.g.,\n     * the first colored terminals around 1980.  More recent ones with better\n     * technology can display not only colored backgrounds, but all\n     * combinations.  So a terminal might be something other than \"white\" on\n     * black (green/black looks monochrome too), but black on white or even\n     * on ivory.\n     *\n     * White-on-black is the simplest thing to use for monochrome.  Almost\n     * all applications that use color paint both text and background, so\n     * the distinction is moot.  But a few do not - which is why we leave this\n     * configurable (a better solution is to use assume_default_colors() for\n     * the rare applications that do require that sort of appearance, since\n     * is appears that more users expect to be able to make a white-on-black\n     * or black-on-white display under control of the application than not).\n     */\n#ifdef USE_ASSUMED_COLOR\n    sp->_default_fg = COLOR_WHITE;\n    sp->_default_bg = COLOR_BLACK;\n#else\n    sp->_default_fg = COLOR_DEFAULT;\n    sp->_default_bg = COLOR_DEFAULT;\n#endif\n\n    /*\n     * Allow those assumed/default color assumptions to be overridden at\n     * runtime:\n     */\n    if ((env = getenv(\"NCURSES_ASSUMED_COLORS\")) != 0) {\n\tint fg, bg;\n\tchar sep1, sep2;\n\tint count = sscanf(env, \"%d%c%d%c\", &fg, &sep1, &bg, &sep2);\n\tif (count >= 1) {\n\t    sp->_default_fg = ((fg >= 0 && fg < MaxColors) ? fg : COLOR_DEFAULT);\n\t    if (count >= 3) {\n\t\tsp->_default_bg = ((bg >= 0 && bg < MaxColors) ? bg : COLOR_DEFAULT);\n\t    }\n\t    TR(TRACE_CHARPUT | TRACE_MOVE,\n\t       (\"from environment assumed fg=%d, bg=%d\",\n\t\tsp->_default_fg,\n\t\tsp->_default_bg));\n\t}\n    }\n#if USE_COLORFGBG\n    /*\n     * If rxvt's $COLORFGBG variable is set, use it to specify the assumed\n     * default colors.  Note that rxvt (mis)uses bold colors, equating a bold\n     * color to that value plus 8.  We'll only use the non-bold color for now -\n     * decide later if it is worth having default attributes as well.\n     */\n    if (getenv(\"COLORFGBG\") != 0) {\n\tconst char *p = getenv(\"COLORFGBG\");\n\tTR(TRACE_CHARPUT | TRACE_MOVE, (\"decoding COLORFGBG %s\", p));\n\tp = extract_fgbg(p, &(sp->_default_fg));\n\tp = extract_fgbg(p, &(sp->_default_bg));\n\tif (*p)\t\t\t/* assume rxvt was compiled with xpm support */\n\t    p = extract_fgbg(p, &(sp->_default_bg));\n\tTR(TRACE_CHARPUT | TRACE_MOVE, (\"decoded fg=%d, bg=%d\",\n\t\t\t\t\tsp->_default_fg, sp->_default_bg));\n\tif (sp->_default_fg >= MaxColors) {\n\t    if (set_a_foreground != ABSENT_STRING\n\t\t&& !strcmp(set_a_foreground, \"\\033[3%p1%dm\")) {\n\t\tset_a_foreground = strdup(\"\\033[3%?%p1%{8}%>%t9%e%p1%d%;m\");\n\t    } else {\n\t\tsp->_default_fg %= MaxColors;\n\t    }\n\t}\n\tif (sp->_default_bg >= MaxColors) {\n\t    if (set_a_background != ABSENT_STRING\n\t\t&& !strcmp(set_a_background, \"\\033[4%p1%dm\")) {\n\t\tset_a_background = strdup(\"\\033[4%?%p1%{8}%>%t9%e%p1%d%;m\");\n\t    } else {\n\t\tsp->_default_bg %= MaxColors;\n\t    }\n\t}\n    }\n#endif\n#endif /* NCURSES_EXT_FUNCS */\n\n    sp->_maxclick = DEFAULT_MAXCLICK;\n    sp->_mouse_event = no_mouse_event;\n    sp->_mouse_inline = no_mouse_inline;\n    sp->_mouse_parse = no_mouse_parse;\n    sp->_mouse_resume = no_mouse_resume;\n    sp->_mouse_wrap = no_mouse_wrap;\n    sp->_mouse_fd = -1;\n\n    /*\n     * If we've no magic cookie support, we suppress attributes that xmc would\n     * affect, i.e., the attributes that affect the rendition of a space.\n     */\n    sp->_ok_attributes = NCURSES_SP_NAME(termattrs) (NCURSES_SP_ARG);\n    if (NCURSES_SP_NAME(has_colors) (NCURSES_SP_ARG)) {\n\tsp->_ok_attributes |= A_COLOR;\n    }\n#ifdef USE_TERM_DRIVER\n    _nc_cookie_init(sp);\n#else\n#if USE_XMC_SUPPORT\n    /*\n     * If we have no magic-cookie support compiled-in, or if it is suppressed\n     * in the environment, reset the support-flag.\n     */\n    if (magic_cookie_glitch >= 0) {\n\tif (getenv(\"NCURSES_NO_MAGIC_COOKIE\") != 0) {\n\t    support_cookies = FALSE;\n\t}\n    }\n#endif\n\n    if (!support_cookies && magic_cookie_glitch >= 0) {\n\tT((\"will disable attributes to work w/o magic cookies\"));\n    }\n\n    if (magic_cookie_glitch > 0) {\t/* tvi, wyse */\n\n\tsp->_xmc_triggers = sp->_ok_attributes & XMC_CONFLICT;\n#if 0\n\t/*\n\t * We \"should\" treat colors as an attribute.  The wyse350 (and its\n\t * clones) appear to be the only ones that have both colors and magic\n\t * cookies.\n\t */\n\tif (has_colors()) {\n\t    sp->_xmc_triggers |= A_COLOR;\n\t}\n#endif\n\tsp->_xmc_suppress = sp->_xmc_triggers & (chtype) ~(A_BOLD);\n\n\tT((\"magic cookie attributes %s\", _traceattr(sp->_xmc_suppress)));\n\t/*\n\t * Supporting line-drawing may be possible.  But make the regular\n\t * video attributes work first.\n\t */\n\tacs_chars = ABSENT_STRING;\n\tena_acs = ABSENT_STRING;\n\tenter_alt_charset_mode = ABSENT_STRING;\n\texit_alt_charset_mode = ABSENT_STRING;\n#if USE_XMC_SUPPORT\n\t/*\n\t * To keep the cookie support simple, suppress all of the optimization\n\t * hooks except for clear_screen and the cursor addressing.\n\t */\n\tif (support_cookies) {\n\t    clr_eol = ABSENT_STRING;\n\t    clr_eos = ABSENT_STRING;\n\t    set_attributes = ABSENT_STRING;\n\t}\n#endif\n    } else if (magic_cookie_glitch == 0) {\t/* hpterm */\n    }\n\n    /*\n     * If magic cookies are not supported, cancel the strings that set\n     * video attributes.\n     */\n    if (!support_cookies && magic_cookie_glitch >= 0) {\n\tmagic_cookie_glitch = ABSENT_NUMERIC;\n\tset_attributes = ABSENT_STRING;\n\tenter_blink_mode = ABSENT_STRING;\n\tenter_bold_mode = ABSENT_STRING;\n\tenter_dim_mode = ABSENT_STRING;\n\tenter_reverse_mode = ABSENT_STRING;\n\tenter_standout_mode = ABSENT_STRING;\n\tenter_underline_mode = ABSENT_STRING;\n    }\n\n    /* initialize normal acs before wide, since we use mapping in the latter */\n#if !USE_WIDEC_SUPPORT\n    if (_nc_unicode_locale() && _nc_locale_breaks_acs(sp->_term)) {\n\tacs_chars = NULL;\n\tena_acs = NULL;\n\tenter_alt_charset_mode = NULL;\n\texit_alt_charset_mode = NULL;\n\tset_attributes = NULL;\n    }\n#endif\n#endif\n\n    NCURSES_SP_NAME(_nc_init_acs) (NCURSES_SP_ARG);\n#if USE_WIDEC_SUPPORT\n    sp->_screen_unicode = _nc_unicode_locale();\n    if (_nc_wacs == 0) {\n\t_nc_init_wacs();\n    }\n    if (_nc_wacs == 0) {\n\tReturnScreenError();\n    }\n\n    sp->_screen_acs_fix = (sp->_screen_unicode\n\t\t\t   && _nc_locale_breaks_acs(sp->_term));\n#endif\n    env = _nc_get_locale();\n    sp->_legacy_coding = ((env == 0)\n\t\t\t  || !strcmp(env, \"C\")\n\t\t\t  || !strcmp(env, \"POSIX\"));\n    T((\"legacy-coding %d\", sp->_legacy_coding));\n\n    sp->_nc_sp_idcok = TRUE;\n    sp->_nc_sp_idlok = FALSE;\n\n    sp->oldhash = 0;\n    sp->newhash = 0;\n\n    T((\"creating newscr\"));\n    NewScreen(sp) = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx slines, scolumns,\n\t\t\t\t\t     0, 0);\n    if (NewScreen(sp) == 0) {\n\tReturnScreenError();\n    }\n    T((\"creating curscr\"));\n    CurScreen(sp) = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx slines, scolumns,\n\t\t\t\t\t     0, 0);\n    if (CurScreen(sp) == 0) {\n\tReturnScreenError();\n    }\n#if !USE_REENTRANT\n    newscr = NewScreen(sp);\n    curscr = CurScreen(sp);\n#endif\n#if USE_SIZECHANGE\n    sp->_resize = NCURSES_SP_NAME(resizeterm);\n    sp->_ungetch = safe_ungetch;\n#endif\n\n    NewScreen(sp)->_clear = TRUE;\n    CurScreen(sp)->_clear = FALSE;\n\n    /*\n     * Get the current tty-modes. setupterm() may already have done this,\n     * unless we use the term-driver.\n     */\n#ifndef USE_TERM_DRIVER\n    if (cur_term != 0 &&\n\t!memcmp(&cur_term->Ottyb, &null_TTY, sizeof(TTY)))\n#endif\n    {\n\tNCURSES_SP_NAME(def_shell_mode) (NCURSES_SP_ARG);\n\tNCURSES_SP_NAME(def_prog_mode) (NCURSES_SP_ARG);\n    }\n\n    if (safe_ripoff_sp && safe_ripoff_sp != safe_ripoff_stack) {\n\tripoff_t *rop;\n\n\tfor (rop = safe_ripoff_stack;\n\t     rop != safe_ripoff_sp && (rop - safe_ripoff_stack) < N_RIPS;\n\t     rop++) {\n\n\t    /* If we must simulate soft labels, grab off the line to be used.\n\t       We assume that we must simulate, if it is none of the standard\n\t       formats (4-4 or 3-2-3) for which there may be some hardware\n\t       support. */\n\t    if (rop->hook == _nc_slk_initialize) {\n\t\tif (!(NumLabels <= 0 || !SLK_STDFMT(slk_format))) {\n\t\t    continue;\n\t\t}\n\t    }\n\t    if (rop->hook) {\n\t\tint count;\n\t\tWINDOW *w;\n\n\t\tcount = (rop->line < 0) ? -rop->line : rop->line;\n\t\tT((\"ripping off %i lines at %s\", count,\n\t\t   ((rop->line < 0)\n\t\t    ? \"bottom\"\n\t\t    : \"top\")));\n\n\t\tw = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx\n\t\t\t\t\t     count, scolumns,\n\t\t\t\t\t     ((rop->line < 0)\n\t\t\t\t\t      ? sp->_lines_avail - count\n\t\t\t\t\t      : 0),\n\t\t\t\t\t     0);\n\t\tif (w) {\n\t\t    rop->win = w;\n\t\t    rop->hook(w, scolumns);\n\t\t} else {\n\t\t    ReturnScreenError();\n\t\t}\n\t\tif (rop->line < 0) {\n\t\t    bottom_stolen += count;\n\t\t} else {\n\t\t    sp->_topstolen = (NCURSES_SIZE_T) (sp->_topstolen + count);\n\t\t}\n\t\tsp->_lines_avail = (NCURSES_SIZE_T) (sp->_lines_avail - count);\n\t    }\n\t}\n\t/* reset the stack */\n\tsafe_ripoff_sp = safe_ripoff_stack;\n    }\n\n    T((\"creating stdscr\"));\n    assert((sp->_lines_avail + sp->_topstolen + bottom_stolen) == slines);\n    if ((StdScreen(sp) = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx\n\t\t\t\t\t\t  sp->_lines_avail,\n\t\t\t\t\t\t  scolumns, 0, 0)) == 0) {\n\tReturnScreenError();\n    }\n    SET_LINES(sp->_lines_avail);\n#if !USE_REENTRANT\n    stdscr = StdScreen(sp);\n#endif\n    sp->_prescreen = FALSE;\n    returnCode(OK);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_setupscreen(int slines GCC_UNUSED,\n\t\tint scolumns GCC_UNUSED,\n\t\tFILE *output,\n\t\tint filtered,\n\t\tint slk_format)\n{\n    SCREEN *sp = 0;\n    int rc = NCURSES_SP_NAME(_nc_setupscreen) (&sp,\n\t\t\t\t\t       slines,\n\t\t\t\t\t       scolumns,\n\t\t\t\t\t       output,\n\t\t\t\t\t       filtered,\n\t\t\t\t\t       slk_format);\n    if (rc != OK)\n\t_nc_set_screen(0);\n    return rc;\n}\n#endif\n\n/*\n * The internal implementation interprets line as the number of lines to rip\n * off from the top or bottom.\n */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_ripoffline) (NCURSES_SP_DCLx\n\t\t\t\t int line,\n\t\t\t\t int (*init) (WINDOW *, int))\n{\n    int code = ERR;\n\n    START_TRACE();\n    T((T_CALLED(\"ripoffline(%p,%d,%p)\"), (void *) SP_PARM, line, TR_FUNC(init)));\n\n#if NCURSES_SP_FUNCS\n    if (SP_PARM != 0 && SP_PARM->_prescreen)\n#endif\n    {\n\tif (line == 0) {\n\t    code = OK;\n\t} else {\n\t    if (safe_ripoff_sp == 0) {\n\t\tsafe_ripoff_sp = safe_ripoff_stack;\n\t    }\n\t    if (safe_ripoff_sp < safe_ripoff_stack + N_RIPS) {\n\t\tsafe_ripoff_sp->line = line;\n\t\tsafe_ripoff_sp->hook = init;\n\t\t(safe_ripoff_sp)++;\n\t\tT((\"ripped-off %d:%d chunks\",\n\t\t   (int) (safe_ripoff_sp - safe_ripoff_stack), N_RIPS));\n\t\tcode = OK;\n\t    }\n\t}\n    }\n\n    returnCode(code);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_ripoffline(int line, int (*init) (WINDOW *, int))\n{\n    int rc;\n    _nc_lock_global(prescreen);\n    START_TRACE();\n    rc = NCURSES_SP_NAME(_nc_ripoffline) (CURRENT_SCREEN_PRE, line, init);\n    _nc_unlock_global(prescreen);\n    return rc;\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(ripoffline) (NCURSES_SP_DCLx\n\t\t\t     int line,\n\t\t\t     int (*init) (WINDOW *, int))\n{\n    START_TRACE();\n    return NCURSES_SP_NAME(_nc_ripoffline) (NCURSES_SP_ARGx\n\t\t\t\t\t    (line < 0) ? -1 : 1,\n\t\t\t\t\t    init);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nripoffline(int line, int (*init) (WINDOW *, int))\n{\n    int rc;\n    _nc_lock_global(prescreen);\n    START_TRACE();\n    rc = NCURSES_SP_NAME(ripoffline) (CURRENT_SCREEN_PRE, line, init);\n    _nc_unlock_global(prescreen);\n    return rc;\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2010,2011 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Authors:                                                                *\n *          Gerhard Fuernkranz                      1993 (original)         *\n *          Zeyd M. Ben-Halim                       1992,1995 (sic)         *\n *          Eric S. Raymond                                                 *\n *          Juergen Pfeifer                         1996-on                 *\n *          Thomas E. Dickey                                                *\n ****************************************************************************/\n\n/*\n *\tlib_slk.c\n *\tSoft key routines.\n */\n\n#include <curses.priv.h>\n#include <ctype.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_slk.c,v 1.48 2011/03/05 21:21:52 tom Exp $\")\n\n#ifdef USE_TERM_DRIVER\n#define NumLabels    InfoOf(SP_PARM).numlabels\n#define NoColorVideo InfoOf(SP_PARM).nocolorvideo\n#define LabelWidth   InfoOf(SP_PARM).labelwidth\n#define LabelHeight  InfoOf(SP_PARM).labelheight\n#else\n#define NumLabels    num_labels\n#define NoColorVideo no_color_video\n#define LabelWidth   label_width\n#define LabelHeight  label_height\n#endif\n\n/*\n * Free any memory related to soft labels, return an error.\n */\nstatic int\nslk_failed(NCURSES_SP_DCL0)\n{\n    if ((0 != SP_PARM) && SP_PARM->_slk) {\n\tFreeIfNeeded(SP_PARM->_slk->ent);\n\tfree(SP_PARM->_slk);\n\tSP_PARM->_slk = (SLK *) 0;\n    }\n    return ERR;\n}\n\nNCURSES_EXPORT(int)\n_nc_format_slks(NCURSES_SP_DCLx int cols)\n{\n    int gap, i, x;\n    int max_length;\n\n    if (!SP_PARM || !SP_PARM->_slk)\n\treturn ERR;\n\n    max_length = SP_PARM->_slk->maxlen;\n    if (SP_PARM->slk_format >= 3) {\t/* PC style */\n\tgap = (cols - 3 * (3 + 4 * max_length)) / 2;\n\n\tif (gap < 1)\n\t    gap = 1;\n\n\tfor (i = x = 0; i < SP_PARM->_slk->maxlab; i++) {\n\t    SP_PARM->_slk->ent[i].ent_x = x;\n\t    x += max_length;\n\t    x += (i == 3 || i == 7) ? gap : 1;\n\t}\n    } else {\n\tif (SP_PARM->slk_format == 2) {\t\t/* 4-4 */\n\t    gap = cols - (int) (SP_PARM->_slk->maxlab * max_length) - 6;\n\n\t    if (gap < 1)\n\t\tgap = 1;\n\t    for (i = x = 0; i < SP_PARM->_slk->maxlab; i++) {\n\t\tSP_PARM->_slk->ent[i].ent_x = x;\n\t\tx += max_length;\n\t\tx += (i == 3) ? gap : 1;\n\t    }\n\t} else {\n\t    if (SP_PARM->slk_format == 1) {\t/* 1 -> 3-2-3 */\n\t\tgap = (cols - (SP_PARM->_slk->maxlab * max_length) - 5)\n\t\t    / 2;\n\n\t\tif (gap < 1)\n\t\t    gap = 1;\n\t\tfor (i = x = 0; i < SP_PARM->_slk->maxlab; i++) {\n\t\t    SP_PARM->_slk->ent[i].ent_x = x;\n\t\t    x += max_length;\n\t\t    x += (i == 2 || i == 4) ? gap : 1;\n\t\t}\n\t    } else {\n\t\treturn slk_failed(NCURSES_SP_ARG);\n\t    }\n\t}\n    }\n    SP_PARM->_slk->dirty = TRUE;\n\n    return OK;\n}\n\n/*\n * Initialize soft labels.\n * Called from newterm()\n */\nNCURSES_EXPORT(int)\n_nc_slk_initialize(WINDOW *stwin, int cols)\n{\n    int i;\n    int res = OK;\n    size_t max_length;\n    SCREEN *sp;\n    int numlab;\n\n    T((T_CALLED(\"_nc_slk_initialize()\")));\n\n    assert(stwin);\n\n    sp = _nc_screen_of(stwin);\n    if (0 == sp)\n\treturnCode(ERR);\n\n    assert(TerminalOf(SP_PARM));\n\n    numlab = NumLabels;\n\n    if (SP_PARM->_slk) {\t/* we did this already, so simply return */\n\treturnCode(OK);\n    } else if ((SP_PARM->_slk = typeCalloc(SLK, 1)) == 0)\n\treturnCode(ERR);\n\n    if (!SP_PARM->slk_format)\n\tSP_PARM->slk_format = _nc_globals.slk_format;\n\n    /*\n     * If we use colors, vidputs() will suppress video attributes that conflict\n     * with colors.  In that case, we're still guaranteed that \"reverse\" would\n     * work.\n     */\n    if ((NoColorVideo & 1) == 0)\n\tSetAttr(SP_PARM->_slk->attr, A_STANDOUT);\n    else\n\tSetAttr(SP_PARM->_slk->attr, A_REVERSE);\n\n    SP_PARM->_slk->maxlab = (short) ((numlab > 0)\n\t\t\t\t     ? numlab\n\t\t\t\t     : MAX_SKEY(SP_PARM->slk_format));\n    SP_PARM->_slk->maxlen = (short) ((numlab > 0)\n\t\t\t\t     ? LabelWidth * LabelHeight\n\t\t\t\t     : MAX_SKEY_LEN(SP_PARM->slk_format));\n    SP_PARM->_slk->labcnt = (short) ((SP_PARM->_slk->maxlab < MAX_SKEY(SP_PARM->slk_format))\n\t\t\t\t     ? MAX_SKEY(SP_PARM->slk_format)\n\t\t\t\t     : SP_PARM->_slk->maxlab);\n\n    if (SP_PARM->_slk->maxlen <= 0\n\t|| SP_PARM->_slk->labcnt <= 0\n\t|| (SP_PARM->_slk->ent = typeCalloc(slk_ent,\n\t\t\t\t\t    (size_t) SP_PARM->_slk->labcnt))\n\t== NULL)\n\treturnCode(slk_failed(NCURSES_SP_ARG));\n\n    max_length = (size_t) SP_PARM->_slk->maxlen;\n    for (i = 0; i < SP_PARM->_slk->labcnt; i++) {\n\tsize_t used = max_length + 1;\n\n\tSP_PARM->_slk->ent[i].ent_text = (char *) _nc_doalloc(0, used);\n\tif (SP_PARM->_slk->ent[i].ent_text == 0)\n\t    returnCode(slk_failed(NCURSES_SP_ARG));\n\tmemset(SP_PARM->_slk->ent[i].ent_text, 0, used);\n\n\tSP_PARM->_slk->ent[i].form_text = (char *) _nc_doalloc(0, used);\n\tif (SP_PARM->_slk->ent[i].form_text == 0)\n\t    returnCode(slk_failed(NCURSES_SP_ARG));\n\n\tif (used > 1) {\n\t    memset(SP_PARM->_slk->ent[i].form_text, ' ', used - 1);\n\t}\n\tSP_PARM->_slk->ent[i].form_text[used - 1] = '\\0';\n\n\tSP_PARM->_slk->ent[i].visible = (char) (i < SP_PARM->_slk->maxlab);\n    }\n\n    res = _nc_format_slks(NCURSES_SP_ARGx cols);\n\n    if ((SP_PARM->_slk->win = stwin) == NULL) {\n\treturnCode(slk_failed(NCURSES_SP_ARG));\n    }\n\n    /* We now reset the format so that the next newterm has again\n     * per default no SLK keys and may call slk_init again to\n     * define a new layout. (juergen 03-Mar-1999)\n     */\n    _nc_globals.slk_format = 0;\n    returnCode(res);\n}\n\n/*\n * Restore the soft labels on the screen.\n */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(slk_restore) (NCURSES_SP_DCL0)\n{\n    T((T_CALLED(\"slk_restore(%p)\"), (void *) SP_PARM));\n\n    if (0 == SP_PARM)\n\treturnCode(ERR);\n    if (SP_PARM->_slk == NULL)\n\treturnCode(ERR);\n    SP_PARM->_slk->hidden = FALSE;\n    SP_PARM->_slk->dirty = TRUE;\n\n    returnCode(NCURSES_SP_NAME(slk_refresh) (NCURSES_SP_ARG));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nslk_restore(void)\n{\n    return NCURSES_SP_NAME(slk_restore) (CURRENT_SCREEN);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2013,2014 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Juergen Pfeifer                         1996-on                 *\n *     and: Thomas E. Dickey                                                *\n ****************************************************************************/\n\n/*\n *\tlib_slkrefr.c\n *\tWrite SLK window to the (virtual) screen.\n */\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_slkrefr.c,v 1.30 2014/03/08 20:32:59 tom Exp $\")\n\n#ifdef USE_TERM_DRIVER\n#define NumLabels    InfoOf(SP_PARM).numlabels\n#else\n#define NumLabels    num_labels\n#endif\n\n/*\n * Paint the info line for the PC style SLK emulation.\n */\nstatic void\nslk_paint_info(WINDOW *win)\n{\n    SCREEN *sp = _nc_screen_of(win);\n\n    if (win && sp && (sp->slk_format == 4)) {\n\tint i;\n\n\t(void) mvwhline(win, 0, 0, 0, getmaxx(win));\n\twmove(win, 0, 0);\n\n\tfor (i = 0; i < sp->_slk->maxlab; i++) {\n\t    mvwprintw(win, 0, sp->_slk->ent[i].ent_x, \"F%d\", i + 1);\n\t}\n    }\n}\n\n/*\n * Write the soft labels to the soft-key window.\n */\nstatic void\nslk_intern_refresh(SCREEN *sp)\n{\n    int i;\n    int fmt;\n    SLK *slk;\n    int numlab;\n\n    if (sp == 0)\n\treturn;\n\n    slk = sp->_slk;\n    fmt = sp->slk_format;\n    numlab = NumLabels;\n\n    if (slk->hidden)\n\treturn;\n\n    for (i = 0; i < slk->labcnt; i++) {\n\tif (slk->dirty || slk->ent[i].dirty) {\n\t    if (slk->ent[i].visible) {\n\t\tif (numlab > 0 && SLK_STDFMT(fmt)) {\n#ifdef USE_TERM_DRIVER\n\t\t    CallDriver_2(sp, td_hwlabel, i + 1, slk->ent[i].form_text);\n#else\n\t\t    if (i < num_labels) {\n\t\t\tNCURSES_PUTP2(\"plab_norm\",\n\t\t\t\t      TPARM_2(plab_norm,\n\t\t\t\t\t      i + 1,\n\t\t\t\t\t      slk->ent[i].form_text));\n\t\t    }\n#endif\n\t\t} else {\n\t\t    if (fmt == 4)\n\t\t\tslk_paint_info(slk->win);\n\t\t    wmove(slk->win, SLK_LINES(fmt) - 1, slk->ent[i].ent_x);\n\t\t    (void) wattrset(slk->win, (int) AttrOf(slk->attr));\n\t\t    waddstr(slk->win, slk->ent[i].form_text);\n\t\t    /* if we simulate SLK's, it's looking much more\n\t\t       natural to use the current ATTRIBUTE also\n\t\t       for the label window */\n\t\t    (void) wattrset(slk->win, (int) WINDOW_ATTRS(StdScreen(sp)));\n\t\t}\n\t    }\n\t    slk->ent[i].dirty = FALSE;\n\t}\n    }\n    slk->dirty = FALSE;\n\n    if (numlab > 0) {\n#ifdef USE_TERM_DRIVER\n\tCallDriver_1(sp, td_hwlabelOnOff, slk->hidden ? FALSE : TRUE);\n#else\n\tif (slk->hidden) {\n\t    NCURSES_PUTP2(\"label_off\", label_off);\n\t} else {\n\t    NCURSES_PUTP2(\"label_on\", label_on);\n\t}\n#endif\n    }\n}\n\n/*\n * Refresh the soft labels.\n */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(slk_noutrefresh) (NCURSES_SP_DCL0)\n{\n    T((T_CALLED(\"slk_noutrefresh(%p)\"), (void *) SP_PARM));\n\n    if (SP_PARM == 0 || SP_PARM->_slk == 0)\n\treturnCode(ERR);\n    if (SP_PARM->_slk->hidden)\n\treturnCode(OK);\n    slk_intern_refresh(SP_PARM);\n\n    returnCode(wnoutrefresh(SP_PARM->_slk->win));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nslk_noutrefresh(void)\n{\n    return NCURSES_SP_NAME(slk_noutrefresh) (CURRENT_SCREEN);\n}\n#endif\n\n/*\n * Refresh the soft labels.\n */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(slk_refresh) (NCURSES_SP_DCL0)\n{\n    T((T_CALLED(\"slk_refresh(%p)\"), (void *) SP_PARM));\n\n    if (SP_PARM == 0 || SP_PARM->_slk == 0)\n\treturnCode(ERR);\n    if (SP_PARM->_slk->hidden)\n\treturnCode(OK);\n    slk_intern_refresh(SP_PARM);\n\n    returnCode(wrefresh(SP_PARM->_slk->win));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nslk_refresh(void)\n{\n    return NCURSES_SP_NAME(slk_refresh) (CURRENT_SCREEN);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n ****************************************************************************/\n\n/*\n**\tlib_touch.c\n**\n**\t   The routines\tuntouchwin(),\n**\t\t\twtouchln(),\n**\t\t\tis_linetouched()\n**\t\t\tis_wintouched().\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_touch.c,v 1.15 2017/11/21 00:14:26 tom Exp $\")\n\n#undef is_linetouched\n\nNCURSES_EXPORT(bool)\nis_linetouched(WINDOW *win, int line)\n{\n    T((T_CALLED(\"is_linetouched(%p,%d)\"), (void *) win, line));\n\n    /* XSI doesn't define any error, and gcc ultimately made it impossible */\n    if (!win || (line > win->_maxy) || (line < 0)) {\n\treturnCode(FALSE);\n    }\n\n    returnCode(win->_line[line].firstchar != _NOCHANGE ? TRUE : FALSE);\n}\n\nNCURSES_EXPORT(bool)\nis_wintouched(WINDOW *win)\n{\n    T((T_CALLED(\"is_wintouched(%p)\"), (void *) win));\n\n    if (win) {\n\tint i;\n\n\tfor (i = 0; i <= win->_maxy; i++)\n\t    if (win->_line[i].firstchar != _NOCHANGE)\n\t\treturnCode(TRUE);\n    }\n    returnCode(FALSE);\n}\n\nNCURSES_EXPORT(int)\nwtouchln(WINDOW *win, int y, int n, int changed)\n{\n    int i;\n\n    T((T_CALLED(\"wtouchln(%p,%d,%d,%d)\"), (void *) win, y, n, changed));\n\n    if (!win || (n < 0) || (y < 0) || (y > win->_maxy))\n\treturnCode(ERR);\n\n    for (i = y; i < y + n; i++) {\n\tif (i > win->_maxy)\n\t    break;\n\twin->_line[i].firstchar = (NCURSES_SIZE_T) (changed ? 0 : _NOCHANGE);\n\twin->_line[i].lastchar = (NCURSES_SIZE_T) (changed\n\t\t\t\t\t\t   ? win->_maxx\n\t\t\t\t\t\t   : _NOCHANGE);\n    }\n    returnCode(OK);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2012,2016 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey 1996-on                                        *\n *     and: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n ****************************************************************************/\n\n/*\n *\tlib_tracedmp.c - Tracing/Debugging routines\n */\n\n#include <curses.priv.h>\n#include <ctype.h>\n\nMODULE_ID(\"$Id: lib_tracedmp.c,v 1.35 2016/05/28 23:30:01 tom Exp $\")\n\n#ifdef TRACE\n\n#define my_buffer _nc_globals.tracedmp_buf\n#define my_length _nc_globals.tracedmp_used\n\nNCURSES_EXPORT(void)\n_tracedump(const char *name, WINDOW *win)\n{\n    int i, j, n, width;\n\n    /* compute narrowest possible display width */\n    for (width = i = 0; i <= win->_maxy; ++i) {\n\tn = 0;\n\tfor (j = 0; j <= win->_maxx; ++j) {\n\t    if (CharOf(win->_line[i].text[j]) != L(' ')\n\t\t|| AttrOf(win->_line[i].text[j]) != A_NORMAL\n\t\t|| GetPair(win->_line[i].text[j]) != 0) {\n\t\tn = j;\n\t    }\n\t}\n\n\tif (n > width)\n\t    width = n;\n    }\n    if (width < win->_maxx)\n\t++width;\n    if (++width + 1 > (int) my_length) {\n\tmy_length = (unsigned) (2 * (width + 1));\n\tmy_buffer = typeRealloc(char, my_length, my_buffer);\n\tif (my_buffer == 0)\n\t    return;\n    }\n\n    for (n = 0; n <= win->_maxy; ++n) {\n\tchar *ep = my_buffer;\n\tbool havecolors;\n\n\t/*\n\t * Dump A_CHARTEXT part.  It is more important to make the grid line up\n\t * in the trace file than to represent control- and wide-characters, so\n\t * we map those to '.' and '?' respectively.\n\t */\n\tfor (j = 0; j < width; ++j) {\n\t    chtype test = (chtype) CharOf(win->_line[n].text[j]);\n\t    ep[j] = (char) ((UChar(test) == test\n#if USE_WIDEC_SUPPORT\n\t\t\t     && (win->_line[n].text[j].chars[1] == 0)\n#endif\n\t\t\t    )\n\t\t\t    ? (iscntrl(UChar(test))\n\t\t\t       ? '.'\n\t\t\t       : UChar(test))\n\t\t\t    : '?');\n\t}\n\tep[j] = '\\0';\n\t_tracef(\"%s[%2d] %3ld%3ld ='%s'\",\n\t\tname, n,\n\t\t(long) win->_line[n].firstchar,\n\t\t(long) win->_line[n].lastchar,\n\t\tep);\n\n\t/* if there are multi-column characters on the line, print them now */\n\tif_WIDEC({\n\t    bool multicolumn = FALSE;\n\t    for (j = 0; j < width; ++j)\n\t\tif (WidecExt(win->_line[n].text[j]) != 0) {\n\t\t    multicolumn = TRUE;\n\t\t    break;\n\t\t}\n\t    if (multicolumn) {\n\t\tep = my_buffer;\n\t\tfor (j = 0; j < width; ++j) {\n\t\t    int test = WidecExt(win->_line[n].text[j]);\n\t\t    if (test) {\n\t\t\tep[j] = (char) (test + '0');\n\t\t    } else {\n\t\t\tep[j] = ' ';\n\t\t    }\n\t\t}\n\t\tep[j] = '\\0';\n\t\t_tracef(\"%*s[%2d]%*s='%s'\", (int) strlen(name),\n\t\t\t\"widec\", n, 8, \" \", my_buffer);\n\t    }\n\t});\n\n\t/* dump A_COLOR part, will screw up if there are more than 96 */\n\thavecolors = FALSE;\n\tfor (j = 0; j < width; ++j)\n\t    if (GetPair(win->_line[n].text[j]) != 0) {\n\t\thavecolors = TRUE;\n\t\tbreak;\n\t    }\n\tif (havecolors) {\n\t    ep = my_buffer;\n\t    for (j = 0; j < width; ++j) {\n\t\tint pair = GetPair(win->_line[n].text[j]);\n\t\tif (pair >= 52)\n\t\t    ep[j] = '?';\n\t\telse if (pair >= 36)\n\t\t    ep[j] = (char) (pair + 'A');\n\t\telse if (pair >= 10)\n\t\t    ep[j] = (char) (pair + 'a');\n\t\telse if (pair >= 1)\n\t\t    ep[j] = (char) (pair + '0');\n\t\telse\n\t\t    ep[j] = ' ';\n\t    }\n\t    ep[j] = '\\0';\n\t    _tracef(\"%*s[%2d]%*s='%s'\", (int) strlen(name),\n\t\t    \"colors\", n, 8, \" \", my_buffer);\n\t}\n\n\tfor (i = 0; i < 4; ++i) {\n\t    const char *hex = \" 123456789ABCDEF\";\n\t    attr_t mask = (attr_t) (0xf << ((i + 4) * 4));\n\t    bool haveattrs = FALSE;\n\n\t    for (j = 0; j < width; ++j)\n\t\tif (AttrOf(win->_line[n].text[j]) & mask) {\n\t\t    haveattrs = TRUE;\n\t\t    break;\n\t\t}\n\t    if (haveattrs) {\n\t\tep = my_buffer;\n\t\tfor (j = 0; j < width; ++j)\n\t\t    ep[j] = hex[(AttrOf(win->_line[n].text[j]) & mask) >>\n\t\t\t\t((i + 4) * 4)];\n\t\tep[j] = '\\0';\n\t\t_tracef(\"%*s%d[%2d]%*s='%s'\", (int) strlen(name) -\n\t\t\t1, \"attrs\", i, n, 8, \" \", my_buffer);\n\t    }\n\t}\n    }\n#if NO_LEAKS\n    free(my_buffer);\n    my_buffer = 0;\n    my_length = 0;\n#endif\n}\n\n#else\nEMPTY_MODULE(_nc_lib_tracedmp)\n#endif /* TRACE */\n","/****************************************************************************\n * Copyright (c) 1998-2014,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1995-on                 *\n ****************************************************************************/\n\n/*\n**\tlib_tstp.c\n**\n**\tThe routine _nc_signal_handler().\n**\n*/\n#include <curses.priv.h>\n\n#include <SigAction.h>\n\nMODULE_ID(\"$Id: lib_tstp.c,v 1.49 2017/07/22 23:29:58 tom Exp $\")\n\n#if defined(SIGTSTP) && (HAVE_SIGACTION || HAVE_SIGVEC)\n#define USE_SIGTSTP 1\n#else\n#define USE_SIGTSTP 0\n#endif\n\n#ifdef TRACE\nstatic const char *\nsignal_name(int sig)\n{\n    switch (sig) {\n#ifdef SIGALRM\n    case SIGALRM:\n\treturn \"SIGALRM\";\n#endif\n#ifdef SIGCONT\n    case SIGCONT:\n\treturn \"SIGCONT\";\n#endif\n    case SIGINT:\n\treturn \"SIGINT\";\n#ifdef SIGQUIT\n    case SIGQUIT:\n\treturn \"SIGQUIT\";\n#endif\n    case SIGTERM:\n\treturn \"SIGTERM\";\n#ifdef SIGTSTP\n    case SIGTSTP:\n\treturn \"SIGTSTP\";\n#endif\n#ifdef SIGTTOU\n    case SIGTTOU:\n\treturn \"SIGTTOU\";\n#endif\n#ifdef SIGWINCH\n    case SIGWINCH:\n\treturn \"SIGWINCH\";\n#endif\n    default:\n\treturn \"unknown signal\";\n    }\n}\n#endif\n\n/*\n * Note: This code is fragile!  Its problem is that different OSs\n * handle restart of system calls interrupted by signals differently.\n * The ncurses code needs signal-call restart to happen -- otherwise,\n * interrupted wgetch() calls will return FAIL, probably making the\n * application think the input stream has ended and it should\n * terminate.  In particular, you know you have this problem if, when\n * you suspend an ncurses-using lynx with ^Z and resume, it dies\n * immediately.\n *\n * Default behavior of POSIX sigaction(2) is not to restart\n * interrupted system calls, but Linux's sigaction does it anyway (at\n * least, on and after the 1.1.47 I (esr) use).  Thus this code works\n * OK under Linux.  The 4.4BSD sigaction(2) supports a (non-portable)\n * SA_RESTART flag that forces the right behavior.  Thus, this code\n * should work OK under BSD/OS, NetBSD, and FreeBSD (let us know if it\n * does not).\n *\n * Stock System Vs (and anything else using a strict-POSIX\n * sigaction(2) without SA_RESTART) may have a problem.  Possible\n * solutions:\n *\n *    sigvec      restarts by default (SV_INTERRUPT flag to not restart)\n *    signal      restarts by default in SVr4 (assuming you link with -lucb)\n *                and BSD, but not SVr3.\n *    sigset      restarts, but is only available under SVr4/Solaris.\n *\n * The signal(3) call is mandated by the ANSI standard, and its\n * interaction with sigaction(2) is described in the POSIX standard\n * (3.3.4.2, page 72,line 934).  According to section 8.1, page 191,\n * however, signal(3) itself is not required by POSIX.1.  And POSIX is\n * silent on whether it is required to restart signals.\n *\n * So.  The present situation is, we use sigaction(2) with no\n * guarantee of restart anywhere but on Linux and BSD.  We could\n * switch to signal(3) and collar Linux, BSD, and SVr4.  Any way\n * we slice it, System V UNIXes older than SVr4 will probably lose\n * (this may include XENIX).\n *\n * This implementation will probably be changed to use signal(3) in\n * the future.  If nothing else, it's simpler...\n */\n\n#if USE_SIGTSTP\nstatic void\nhandle_SIGTSTP(int dummy GCC_UNUSED)\n{\n    SCREEN *sp = CURRENT_SCREEN;\n    sigset_t mask, omask;\n    sigaction_t act, oact;\n\n#ifdef SIGTTOU\n    int sigttou_blocked;\n#endif\n\n    _nc_globals.have_sigtstp = 1;\n    T((\"handle_SIGTSTP() called\"));\n\n    /*\n     * The user may have changed the prog_mode tty bits, so save them.\n     *\n     * But first try to detect whether we still are in the foreground\n     * process group - if not, an interactive shell may already have\n     * taken ownership of the tty and modified the settings when our\n     * parent was stopped before us, and we would likely pick up the\n     * settings already modified by the shell.\n     *\n     * Don't do this if we're not in curses -\n     */\n    if (sp != 0 && (sp->_endwin == ewRunning))\n#if HAVE_TCGETPGRP\n\tif (tcgetpgrp(STDIN_FILENO) == getpgrp())\n#endif\n\t    NCURSES_SP_NAME(def_prog_mode) (NCURSES_SP_ARG);\n\n    /*\n     * Block window change and timer signals.  The latter\n     * is because applications use timers to decide when\n     * to repaint the screen.\n     */\n    (void) sigemptyset(&mask);\n#ifdef SIGALRM\n    (void) sigaddset(&mask, SIGALRM);\n#endif\n#if USE_SIGWINCH\n    (void) sigaddset(&mask, SIGWINCH);\n#endif\n    (void) sigprocmask(SIG_BLOCK, &mask, &omask);\n\n#ifdef SIGTTOU\n    sigttou_blocked = sigismember(&omask, SIGTTOU);\n    if (!sigttou_blocked) {\n\t(void) sigemptyset(&mask);\n\t(void) sigaddset(&mask, SIGTTOU);\n\t(void) sigprocmask(SIG_BLOCK, &mask, NULL);\n    }\n#endif\n\n    /*\n     * End window mode, which also resets the terminal state to the\n     * original (pre-curses) modes.\n     */\n    NCURSES_SP_NAME(endwin) (NCURSES_SP_ARG);\n\n    /* Unblock SIGTSTP. */\n    (void) sigemptyset(&mask);\n    (void) sigaddset(&mask, SIGTSTP);\n#ifdef SIGTTOU\n    if (!sigttou_blocked) {\n\t/* Unblock this too if it wasn't blocked on entry */\n\t(void) sigaddset(&mask, SIGTTOU);\n    }\n#endif\n    (void) sigprocmask(SIG_UNBLOCK, &mask, NULL);\n\n    /* Now we want to resend SIGSTP to this process and suspend it */\n    act.sa_handler = SIG_DFL;\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n#ifdef SA_RESTART\n    act.sa_flags |= SA_RESTART;\n#endif /* SA_RESTART */\n    sigaction(SIGTSTP, &act, &oact);\n    kill(getpid(), SIGTSTP);\n\n    /* Process gets suspended...time passes...process resumes */\n\n    T((\"SIGCONT received\"));\n    sigaction(SIGTSTP, &oact, NULL);\n    NCURSES_SP_NAME(flushinp) (NCURSES_SP_ARG);\n\n    /*\n     * If the user modified the tty state while suspended, he wants\n     * those changes to stick.  So save the new \"default\" terminal state.\n     */\n    NCURSES_SP_NAME(def_shell_mode) (NCURSES_SP_ARG);\n\n    /*\n     * This relies on the fact that doupdate() will restore the\n     * program-mode tty state, and issue enter_ca_mode if need be.\n     */\n    NCURSES_SP_NAME(doupdate) (NCURSES_SP_ARG);\n\n    /* Reset the signals. */\n    (void) sigprocmask(SIG_SETMASK, &omask, NULL);\n}\n#endif /* USE_SIGTSTP */\n\nstatic void\nhandle_SIGINT(int sig)\n{\n    SCREEN *sp = CURRENT_SCREEN;\n\n    /*\n     * Much of this is unsafe from a signal handler.  But we'll _try_ to clean\n     * up the screen and terminal settings on the way out.\n     *\n     * There are at least the following problems:\n     * 1) Walking the SCREEN list is unsafe, since all list management\n     *    is done without any signal blocking.\n     * 2) On systems which have REENTRANT turned on, set_term() uses\n     *    _nc_lock_global() which could deadlock or misbehave in other ways.\n     * 3) endwin() calls all sorts of stuff, many of which use stdio or\n     *    other library functions which are clearly unsafe.\n     */\n    if (!_nc_globals.cleanup_nested++\n\t&& (sig == SIGINT || sig == SIGTERM)) {\n#if HAVE_SIGACTION || HAVE_SIGVEC\n\tsigaction_t act;\n\tsigemptyset(&act.sa_mask);\n\tact.sa_flags = 0;\n\tact.sa_handler = SIG_IGN;\n\tif (sigaction(sig, &act, NULL) == 0)\n#else\n\tif (signal(sig, SIG_IGN) != SIG_ERR)\n#endif\n\t{\n\t    SCREEN *scan;\n\t    for (each_screen(scan)) {\n\t\tif (scan->_ofp != 0\n\t\t    && NC_ISATTY(fileno(scan->_ofp))) {\n\t\t    scan->_outch = NCURSES_SP_NAME(_nc_outch);\n\t\t}\n\t\tset_term(scan);\n\t\tNCURSES_SP_NAME(endwin) (NCURSES_SP_ARG);\n\t\tif (sp)\n\t\t    sp->_endwin = ewInitial;\t/* in case of reuse */\n\t    }\n\t}\n    }\n    _exit(EXIT_FAILURE);\n}\n\n#if USE_SIGWINCH\nstatic void\nhandle_SIGWINCH(int sig GCC_UNUSED)\n{\n    _nc_globals.have_sigwinch = 1;\n# if USE_PTHREADS_EINTR\n    if (_nc_globals.read_thread) {\n\tif (!pthread_equal(pthread_self(), _nc_globals.read_thread))\n\t    pthread_kill(_nc_globals.read_thread, SIGWINCH);\n\t_nc_globals.read_thread = 0;\n    }\n# endif\n}\n#endif /* USE_SIGWINCH */\n\n/*\n * If the given signal is still in its default state, set it to the given\n * handler.\n */\nstatic int\nCatchIfDefault(int sig, void (*handler) (int))\n{\n    int result;\n#if HAVE_SIGACTION || HAVE_SIGVEC\n    sigaction_t old_act;\n    sigaction_t new_act;\n\n    memset(&new_act, 0, sizeof(new_act));\n    sigemptyset(&new_act.sa_mask);\n#ifdef SA_RESTART\n#ifdef SIGWINCH\n    if (sig != SIGWINCH)\n#endif\n\tnew_act.sa_flags |= SA_RESTART;\n#endif /* SA_RESTART */\n    new_act.sa_handler = handler;\n\n    if (sigaction(sig, NULL, &old_act) == 0\n\t&& (old_act.sa_handler == SIG_DFL\n\t    || old_act.sa_handler == handler\n#if USE_SIGWINCH\n\t    || (sig == SIGWINCH && old_act.sa_handler == SIG_IGN)\n#endif\n\t)) {\n\t(void) sigaction(sig, &new_act, NULL);\n\tresult = TRUE;\n    } else {\n\tresult = FALSE;\n    }\n#else /* !HAVE_SIGACTION */\n    void (*ohandler) (int);\n\n    ohandler = signal(sig, SIG_IGN);\n    if (ohandler == SIG_DFL\n\t|| ohandler == handler\n#if USE_SIGWINCH\n\t|| (sig == SIGWINCH && ohandler == SIG_IGN)\n#endif\n\t) {\n\tsignal(sig, handler);\n\tresult = TRUE;\n    } else {\n\tsignal(sig, ohandler);\n\tresult = FALSE;\n    }\n#endif\n    T((\"CatchIfDefault - will %scatch %s\",\n       result ? \"\" : \"not \", signal_name(sig)));\n    return result;\n}\n\n/*\n * This is invoked once at the beginning (e.g., from 'initscr()'), to\n * initialize the signal catchers, and thereafter when spawning a shell (and\n * returning) to disable/enable the SIGTSTP (i.e., ^Z) catcher.\n *\n * If the application has already set one of the signals, we'll not modify it\n * (during initialization).\n *\n * The XSI document implies that we shouldn't keep the SIGTSTP handler if\n * the caller later changes its mind, but that doesn't seem correct.\n */\nNCURSES_EXPORT(void)\n_nc_signal_handler(int enable)\n{\n    T((T_CALLED(\"_nc_signal_handler(%d)\"), enable));\n#if USE_SIGTSTP\t\t\t/* Xenix 2.x doesn't have SIGTSTP, for example */\n    {\n\tstatic bool ignore_tstp = FALSE;\n\n\tif (!ignore_tstp) {\n\t    static sigaction_t new_sigaction, old_sigaction;\n\n\t    if (!enable) {\n\t\tnew_sigaction.sa_handler = SIG_IGN;\n\t\tsigaction(SIGTSTP, &new_sigaction, &old_sigaction);\n\t    } else if (new_sigaction.sa_handler != SIG_DFL) {\n\t\tsigaction(SIGTSTP, &old_sigaction, NULL);\n\t    } else if (sigaction(SIGTSTP, NULL, &old_sigaction) == 0\n\t\t       && (old_sigaction.sa_handler == SIG_DFL)) {\n\t\tsigemptyset(&new_sigaction.sa_mask);\n#ifdef SA_RESTART\n\t\tnew_sigaction.sa_flags |= SA_RESTART;\n#endif /* SA_RESTART */\n\t\tnew_sigaction.sa_handler = handle_SIGTSTP;\n\t\t(void) sigaction(SIGTSTP, &new_sigaction, NULL);\n\t    } else {\n\t\tignore_tstp = TRUE;\n\t    }\n\t}\n    }\n#endif /* !USE_SIGTSTP */\n\n    if (!_nc_globals.init_signals) {\n\tif (enable) {\n\t    CatchIfDefault(SIGINT, handle_SIGINT);\n\t    CatchIfDefault(SIGTERM, handle_SIGINT);\n#if USE_SIGWINCH\n\t    CatchIfDefault(SIGWINCH, handle_SIGWINCH);\n#endif\n\t    _nc_globals.init_signals = TRUE;\n\t}\n    }\n    returnVoid;\n}\n","/****************************************************************************\n * Copyright (c) 1998-2011,2012 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n**\tlib_ungetch.c\n**\n**\tThe routine ungetch().\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_ungetch.c,v 1.16 2012/08/04 17:38:53 tom Exp $\")\n\n#include <fifo_defs.h>\n\n#ifdef TRACE\nNCURSES_EXPORT(void)\n_nc_fifo_dump(SCREEN *sp)\n{\n    int i;\n    T((\"head = %d, tail = %d, peek = %d\", head, tail, peek));\n    for (i = 0; i < 10; i++)\n\tT((\"char %d = %s\", i, _nc_tracechar(sp, sp->_fifo[i])));\n}\n#endif /* TRACE */\n\nNCURSES_EXPORT(int)\nsafe_ungetch(SCREEN *sp, int ch)\n{\n    int rc = ERR;\n\n    T((T_CALLED(\"ungetch(%p,%s)\"), (void *) sp, _nc_tracechar(sp, ch)));\n\n    if (sp != 0 && tail >= 0) {\n\tif (head < 0) {\n\t    head = 0;\n\t    t_inc();\n\t    peek = tail;\t/* no raw keys */\n\t} else {\n\t    h_dec();\n\t}\n\n\tsp->_fifo[head] = ch;\n\tT((\"ungetch %s ok\", _nc_tracechar(sp, ch)));\n#ifdef TRACE\n\tif (USE_TRACEF(TRACE_IEVENT)) {\n\t    _nc_fifo_dump(sp);\n\t    _nc_unlock_global(tracef);\n\t}\n#endif\n\trc = OK;\n    }\n    returnCode(rc);\n}\n\nNCURSES_EXPORT(int)\nungetch(int ch)\n{\n    return safe_ungetch(CURRENT_SCREEN, ch);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2014,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n *\tvidputs(newmode, outc)\n *\n *\tnewmode is taken to be the logical 'or' of the symbols in curses.h\n *\trepresenting graphic renditions.  The terminal is set to be in all of\n *\tthe given modes, if possible.\n *\n *\tif the new attribute is normal\n *\t\tif exit-alt-char-set exists\n *\t\t\temit it\n *\t\temit exit-attribute-mode\n *\telse if set-attributes exists\n *\t\tuse it to set exactly what you want\n *\telse\n *\t\tif exit-attribute-mode exists\n *\t\t\tturn off everything\n *\t\telse\n *\t\t\tturn off those which can be turned off and aren't in\n *\t\t\tnewmode.\n *\t\tturn on each mode which should be on and isn't, one by one\n *\n *\tNOTE that this algorithm won't achieve the desired mix of attributes\n *\tin some cases, but those are probably just those cases in which it is\n *\tactually impossible, anyway, so...\n *\n * \tNOTE that we cannot assume that there's no interaction between color\n *\tand other attribute resets.  So each time we reset color (or other\n *\tattributes) we'll have to be prepared to restore the other.\n */\n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_vidattr.c,v 1.72 2017/06/24 12:13:42 tom Exp $\")\n\n#define doPut(mode) \\\n\tTPUTS_TRACE(#mode); \\\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx mode, 1, outc)\n\n#define TurnOn(mask, mode) \\\n\tif ((turn_on & mask) && mode) { doPut(mode); }\n\n#define TurnOff(mask, mode) \\\n\tif ((turn_off & mask) && mode) { doPut(mode); turn_off &= ~mask; }\n\n\t/* if there is no current screen, assume we *can* do color */\n#define SetColorsIf(why, old_attr) \\\n\tif (can_color && (why)) { \\\n\t\tint old_pair = PairNumber(old_attr); \\\n\t\tTR(TRACE_ATTRS, (\"old pair = %d -- new pair = %d\", old_pair, pair)); \\\n\t\tif ((pair != old_pair) \\\n\t\t || (fix_pair0 && (pair == 0)) \\\n\t\t || (reverse ^ ((old_attr & A_REVERSE) != 0))) { \\\n\t\t     NCURSES_SP_NAME(_nc_do_color) (NCURSES_SP_ARGx \\\n\t\t\t\t     (short) old_pair, \\\n\t\t\t\t     (short) pair, \\\n\t\t\t\t     reverse, outc); \\\n\t\t} \\\n\t}\n\n#define PreviousAttr _nc_prescreen.previous_attr\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(vidputs) (NCURSES_SP_DCLx\n\t\t\t  chtype newmode,\n\t\t\t  NCURSES_SP_OUTC outc)\n{\n    attr_t turn_on, turn_off;\n    int pair;\n    bool reverse = FALSE;\n    bool can_color = (SP_PARM == 0 || SP_PARM->_coloron);\n#if NCURSES_EXT_FUNCS\n    bool fix_pair0 = (SP_PARM != 0 && SP_PARM->_coloron && !SP_PARM->_default_color);\n#else\n#define fix_pair0 FALSE\n#endif\n\n    newmode &= A_ATTRIBUTES;\n\n    T((T_CALLED(\"vidputs(%p,%s)\"), (void *) SP_PARM, _traceattr(newmode)));\n\n    if (!IsValidTIScreen(SP_PARM))\n\treturnCode(ERR);\n\n    /* this allows us to go on whether or not newterm() has been called */\n    if (SP_PARM)\n\tPreviousAttr = AttrOf(SCREEN_ATTRS(SP_PARM));\n\n    TR(TRACE_ATTRS, (\"previous attribute was %s\", _traceattr(PreviousAttr)));\n\n    if ((SP_PARM != 0)\n\t&& (magic_cookie_glitch > 0)) {\n#if USE_XMC_SUPPORT\n\tstatic const chtype table[] =\n\t{\n\t    A_STANDOUT,\n\t    A_UNDERLINE,\n\t    A_REVERSE,\n\t    A_BLINK,\n\t    A_DIM,\n\t    A_BOLD,\n\t    A_INVIS,\n\t    A_PROTECT,\n#if USE_ITALIC\n\t    A_ITALIC,\n#endif\n\t};\n\tunsigned n;\n\tint used = 0;\n\tint limit = (max_attributes <= 0) ? 1 : max_attributes;\n\tchtype retain = 0;\n\n\t/*\n\t * Limit the number of attribute bits set in the newmode according to\n\t * the terminfo max_attributes value.\n\t */\n\tfor (n = 0; n < SIZEOF(table); ++n) {\n\t    if ((table[n] & SP_PARM->_ok_attributes) == 0) {\n\t\tnewmode &= ~table[n];\n\t    } else if ((table[n] & newmode) != 0) {\n\t\tif (used++ >= limit) {\n\t\t    newmode &= ~table[n];\n\t\t    if (newmode == retain)\n\t\t\tbreak;\n\t\t} else {\n\t\t    retain = newmode;\n\t\t}\n\t    }\n\t}\n#else\n\tnewmode &= ~(SP_PARM->_xmc_suppress);\n#endif\n\tTR(TRACE_ATTRS, (\"suppressed attribute is %s\", _traceattr(newmode)));\n    }\n\n    /*\n     * If we have a terminal that cannot combine color with video\n     * attributes, use the colors in preference.\n     */\n    if (((newmode & A_COLOR) != 0\n\t || fix_pair0)\n\t&& (no_color_video > 0)) {\n\t/*\n\t * If we had chosen the A_xxx definitions to correspond to the\n\t * no_color_video mask, we could simply shift it up and mask off the\n\t * attributes.  But we did not (actually copied Solaris' definitions).\n\t * However, this is still simpler/faster than a lookup table.\n\t *\n\t * The 63 corresponds to A_STANDOUT, A_UNDERLINE, A_REVERSE, A_BLINK,\n\t * A_DIM, A_BOLD which are 1:1 with no_color_video.  The bits that\n\t * correspond to A_INVIS, A_PROTECT (192) must be shifted up 1 and\n\t * A_ALTCHARSET (256) down 2 to line up.  We use the NCURSES_BITS\n\t * macro so this will work properly for the wide-character layout.\n\t */\n\tunsigned value = (unsigned) no_color_video;\n\tattr_t mask = NCURSES_BITS((value & 63)\n\t\t\t\t   | ((value & 192) << 1)\n\t\t\t\t   | ((value & 256) >> 2), 8);\n\n\tif ((mask & A_REVERSE) != 0\n\t    && (newmode & A_REVERSE) != 0) {\n\t    reverse = TRUE;\n\t    mask &= ~A_REVERSE;\n\t}\n\tnewmode &= ~mask;\n    }\n\n    if (newmode == PreviousAttr)\n\treturnCode(OK);\n\n    pair = PairNumber(newmode);\n\n    if (reverse) {\n\tnewmode &= ~A_REVERSE;\n    }\n\n    turn_off = (~newmode & PreviousAttr) & ALL_BUT_COLOR;\n    turn_on = (newmode & ~(PreviousAttr & TPARM_ATTR)) & ALL_BUT_COLOR;\n\n    SetColorsIf(((pair == 0) && !fix_pair0), PreviousAttr);\n\n    if (newmode == A_NORMAL) {\n\tif ((PreviousAttr & A_ALTCHARSET) && exit_alt_charset_mode) {\n\t    doPut(exit_alt_charset_mode);\n\t    PreviousAttr &= ~A_ALTCHARSET;\n\t}\n\tif (PreviousAttr) {\n\t    if (exit_attribute_mode) {\n\t\tdoPut(exit_attribute_mode);\n\t    } else {\n\t\tif (!SP_PARM || SP_PARM->_use_rmul) {\n\t\t    TurnOff(A_UNDERLINE, exit_underline_mode);\n\t\t}\n\t\tif (!SP_PARM || SP_PARM->_use_rmso) {\n\t\t    TurnOff(A_STANDOUT, exit_standout_mode);\n\t\t}\n#if USE_ITALIC\n\t\tif (!SP_PARM || SP_PARM->_use_ritm) {\n\t\t    TurnOff(A_ITALIC, exit_italics_mode);\n\t\t}\n#endif\n\t    }\n\t    PreviousAttr &= ALL_BUT_COLOR;\n\t}\n\n\tSetColorsIf((pair != 0) || fix_pair0, PreviousAttr);\n    } else if (set_attributes) {\n\tif (turn_on || turn_off) {\n\t    TPUTS_TRACE(\"set_attributes\");\n\t    NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t    tparm(set_attributes,\n\t\t\t\t\t  (newmode & A_STANDOUT) != 0,\n\t\t\t\t\t  (newmode & A_UNDERLINE) != 0,\n\t\t\t\t\t  (newmode & A_REVERSE) != 0,\n\t\t\t\t\t  (newmode & A_BLINK) != 0,\n\t\t\t\t\t  (newmode & A_DIM) != 0,\n\t\t\t\t\t  (newmode & A_BOLD) != 0,\n\t\t\t\t\t  (newmode & A_INVIS) != 0,\n\t\t\t\t\t  (newmode & A_PROTECT) != 0,\n\t\t\t\t\t  (newmode & A_ALTCHARSET) != 0),\n\t\t\t\t    1, outc);\n\t    PreviousAttr &= ALL_BUT_COLOR;\n\t}\n#if USE_ITALIC\n\tif (!SP_PARM || SP_PARM->_use_ritm) {\n\t    if (turn_on & A_ITALIC) {\n\t\tTurnOn(A_ITALIC, enter_italics_mode);\n\t    } else if (turn_off & A_ITALIC) {\n\t\tTurnOff(A_ITALIC, exit_italics_mode);\n\t    }\n\t}\n#endif\n\tSetColorsIf((pair != 0) || fix_pair0, PreviousAttr);\n    } else {\n\n\tTR(TRACE_ATTRS, (\"turning %s off\", _traceattr(turn_off)));\n\n\tTurnOff(A_ALTCHARSET, exit_alt_charset_mode);\n\n\tif (!SP_PARM || SP_PARM->_use_rmul) {\n\t    TurnOff(A_UNDERLINE, exit_underline_mode);\n\t}\n\n\tif (!SP_PARM || SP_PARM->_use_rmso) {\n\t    TurnOff(A_STANDOUT, exit_standout_mode);\n\t}\n#if USE_ITALIC\n\tif (!SP_PARM || SP_PARM->_use_ritm) {\n\t    TurnOff(A_ITALIC, exit_italics_mode);\n\t}\n#endif\n\tif (turn_off && exit_attribute_mode) {\n\t    doPut(exit_attribute_mode);\n\t    turn_on |= (newmode & ALL_BUT_COLOR);\n\t    PreviousAttr &= ALL_BUT_COLOR;\n\t}\n\tSetColorsIf((pair != 0) || fix_pair0, PreviousAttr);\n\n\tTR(TRACE_ATTRS, (\"turning %s on\", _traceattr(turn_on)));\n\t/* *INDENT-OFF* */\n\tTurnOn(A_ALTCHARSET,\tenter_alt_charset_mode);\n\tTurnOn(A_BLINK,\t\tenter_blink_mode);\n\tTurnOn(A_BOLD,\t\tenter_bold_mode);\n\tTurnOn(A_DIM,\t\tenter_dim_mode);\n\tTurnOn(A_REVERSE,\tenter_reverse_mode);\n\tTurnOn(A_STANDOUT,\tenter_standout_mode);\n\tTurnOn(A_PROTECT,\tenter_protected_mode);\n\tTurnOn(A_INVIS,\t\tenter_secure_mode);\n\tTurnOn(A_UNDERLINE,\tenter_underline_mode);\n#if USE_ITALIC\n\tTurnOn(A_ITALIC,\tenter_italics_mode);\n#endif\n#if USE_WIDEC_SUPPORT\n\tTurnOn(A_HORIZONTAL,\tenter_horizontal_hl_mode);\n\tTurnOn(A_LEFT,\t\tenter_left_hl_mode);\n\tTurnOn(A_LOW,\t\tenter_low_hl_mode);\n\tTurnOn(A_RIGHT,\t\tenter_right_hl_mode);\n\tTurnOn(A_TOP,\t\tenter_top_hl_mode);\n\tTurnOn(A_VERTICAL,\tenter_vertical_hl_mode);\n#endif\n\t/* *INDENT-ON* */\n\n    }\n\n    if (reverse)\n\tnewmode |= A_REVERSE;\n\n    if (SP_PARM)\n\tSetAttr(SCREEN_ATTRS(SP_PARM), newmode);\n    else\n\tPreviousAttr = newmode;\n\n    returnCode(OK);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nvidputs(chtype newmode, NCURSES_OUTC outc)\n{\n    SetSafeOutcWrapper(outc);\n    return NCURSES_SP_NAME(vidputs) (CURRENT_SCREEN,\n\t\t\t\t     newmode,\n\t\t\t\t     _nc_outc_wrapper);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(vidattr) (NCURSES_SP_DCLx chtype newmode)\n{\n    T((T_CALLED(\"vidattr(%p,%s)\"), (void *) SP_PARM, _traceattr(newmode)));\n    returnCode(NCURSES_SP_NAME(vidputs) (NCURSES_SP_ARGx\n\t\t\t\t\t newmode,\n\t\t\t\t\t NCURSES_SP_NAME(_nc_putchar)));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nvidattr(chtype newmode)\n{\n    return NCURSES_SP_NAME(vidattr) (CURRENT_SCREEN, newmode);\n}\n#endif\n\nNCURSES_EXPORT(chtype)\nNCURSES_SP_NAME(termattrs) (NCURSES_SP_DCL0)\n{\n    chtype attrs = A_NORMAL;\n\n    T((T_CALLED(\"termattrs(%p)\"), (void *) SP_PARM));\n\n    if (HasTerminal(SP_PARM)) {\n#ifdef USE_TERM_DRIVER\n\tattrs = CallDriver(SP_PARM, td_conattr);\n#else /* ! USE_TERM_DRIVER */\n\n\tif (enter_alt_charset_mode)\n\t    attrs |= A_ALTCHARSET;\n\n\tif (enter_blink_mode)\n\t    attrs |= A_BLINK;\n\n\tif (enter_bold_mode)\n\t    attrs |= A_BOLD;\n\n\tif (enter_dim_mode)\n\t    attrs |= A_DIM;\n\n\tif (enter_reverse_mode)\n\t    attrs |= A_REVERSE;\n\n\tif (enter_standout_mode)\n\t    attrs |= A_STANDOUT;\n\n\tif (enter_protected_mode)\n\t    attrs |= A_PROTECT;\n\n\tif (enter_secure_mode)\n\t    attrs |= A_INVIS;\n\n\tif (enter_underline_mode)\n\t    attrs |= A_UNDERLINE;\n\n\tif (SP_PARM->_coloron)\n\t    attrs |= A_COLOR;\n\n#if USE_ITALIC\n\tif (enter_italics_mode)\n\t    attrs |= A_ITALIC;\n#endif\n\n#endif /* USE_TERM_DRIVER */\n    }\n    returnChtype(attrs);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(chtype)\ntermattrs(void)\n{\n    return NCURSES_SP_NAME(termattrs) (CURRENT_SCREEN);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2010,2016 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n ****************************************************************************/\n\n/*\n**\tlib_window.c\n**\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_window.c,v 1.30 2016/05/28 23:11:26 tom Exp $\")\n\nNCURSES_EXPORT(void)\n_nc_synchook(WINDOW *win)\n/* hook to be called after each window change */\n{\n    if (win->_immed)\n\twrefresh(win);\n    if (win->_sync)\n\twsyncup(win);\n}\n\nNCURSES_EXPORT(int)\nmvderwin(WINDOW *win, int y, int x)\n/* move a derived window */\n{\n    WINDOW *orig;\n    int rc = ERR;\n\n    T((T_CALLED(\"mvderwin(%p,%d,%d)\"), (void *) win, y, x));\n\n    if (win != 0\n\t&& (orig = win->_parent) != 0\n\t&& (x >= 0 && y >= 0)\n\t&& (x + getmaxx(win) <= getmaxx(orig))\n\t&& (y + getmaxy(win) <= getmaxy(orig))) {\n\tint i;\n\n\twsyncup(win);\n\twin->_parx = x;\n\twin->_pary = y;\n\tfor (i = 0; i < getmaxy(win); i++)\n\t    win->_line[i].text = &(orig->_line[y++].text[x]);\n\trc = OK;\n    }\n    returnCode(rc);\n}\n\nNCURSES_EXPORT(int)\nsyncok(WINDOW *win, bool bf)\n/* enable/disable automatic wsyncup() on each change to window */\n{\n    T((T_CALLED(\"syncok(%p,%d)\"), (void *) win, bf));\n\n    if (win) {\n\twin->_sync = bf;\n\treturnCode(OK);\n    } else\n\treturnCode(ERR);\n}\n\nNCURSES_EXPORT(void)\nwsyncup(WINDOW *win)\n/* mark changed every cell in win's ancestors that is changed in win */\n/* Rewritten by J. Pfeifer, 1-Apr-96 (don't even think that...)      */\n{\n    WINDOW *wp;\n\n    T((T_CALLED(\"wsyncup(%p)\"), (void *) win));\n    if (win && win->_parent) {\n\tfor (wp = win; wp->_parent; wp = wp->_parent) {\n\t    int y;\n\t    WINDOW *pp = wp->_parent;\n\n\t    assert((wp->_pary <= pp->_maxy) &&\n\t\t   ((wp->_pary + wp->_maxy) <= pp->_maxy));\n\n\t    for (y = 0; y <= wp->_maxy; y++) {\n\t\tint left = wp->_line[y].firstchar;\n\t\tif (left >= 0) {\t/* line is touched */\n\t\t    struct ldat *line = &(pp->_line[wp->_pary + y]);\n\t\t    /* left & right character in parent window coordinates */\n\t\t    int right = wp->_line[y].lastchar + wp->_parx;\n\t\t    left += wp->_parx;\n\n\t\t    CHANGED_RANGE(line, left, right);\n\t\t}\n\t    }\n\t}\n    }\n    returnVoid;\n}\n\nNCURSES_EXPORT(void)\nwsyncdown(WINDOW *win)\n/* mark changed every cell in win that is changed in any of its ancestors */\n/* Rewritten by J. Pfeifer, 1-Apr-96 (don't even think that...)           */\n{\n    T((T_CALLED(\"wsyncdown(%p)\"), (void *) win));\n\n    if (win && win->_parent) {\n\tWINDOW *pp = win->_parent;\n\tint y;\n\n\t/* This recursion guarantees, that the changes are propagated down-\n\t   wards from the root to our direct parent. */\n\twsyncdown(pp);\n\n\t/* and now we only have to propagate the changes from our direct\n\t   parent, if there are any. */\n\tassert((win->_pary <= pp->_maxy) &&\n\t       ((win->_pary + win->_maxy) <= pp->_maxy));\n\n\tfor (y = 0; y <= win->_maxy; y++) {\n\t    if (pp->_line[win->_pary + y].firstchar >= 0) {\t/* parent changed */\n\t\tstruct ldat *line = &(win->_line[y]);\n\t\t/* left and right character in child coordinates */\n\t\tint left = pp->_line[win->_pary + y].firstchar - win->_parx;\n\t\tint right = pp->_line[win->_pary + y].lastchar - win->_parx;\n\t\t/* The change may be outside the child's range */\n\t\tif (left < 0)\n\t\t    left = 0;\n\t\tif (right > win->_maxx)\n\t\t    right = win->_maxx;\n\t\tCHANGED_RANGE(line, left, right);\n\t    }\n\t}\n    }\n    returnVoid;\n}\n\nNCURSES_EXPORT(void)\nwcursyncup(WINDOW *win)\n/* sync the cursor in all derived windows to its value in the base window */\n{\n    WINDOW *wp;\n\n    T((T_CALLED(\"wcursyncup(%p)\"), (void *) win));\n    for (wp = win; wp && wp->_parent; wp = wp->_parent) {\n\twmove(wp->_parent, wp->_pary + wp->_cury, wp->_parx + wp->_curx);\n    }\n    returnVoid;\n}\n\nNCURSES_EXPORT(WINDOW *)\ndupwin(WINDOW *win)\n/* make an exact duplicate of the given window */\n{\n    WINDOW *nwin = 0;\n\n    T((T_CALLED(\"dupwin(%p)\"), (void *) win));\n\n    if (win != 0) {\n#if NCURSES_SP_FUNCS\n\tSCREEN *sp = _nc_screen_of(win);\n#endif\n\t_nc_lock_global(curses);\n\tif (win->_flags & _ISPAD) {\n\t    nwin = NCURSES_SP_NAME(newpad) (NCURSES_SP_ARGx\n\t\t\t\t\t    win->_maxy + 1,\n\t\t\t\t\t    win->_maxx + 1);\n\t} else {\n\t    nwin = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx\n\t\t\t\t\t    win->_maxy + 1,\n\t\t\t\t\t    win->_maxx + 1,\n\t\t\t\t\t    win->_begy,\n\t\t\t\t\t    win->_begx);\n\t}\n\n\tif (nwin != 0) {\n\t    int i;\n\t    size_t linesize;\n\n\t    nwin->_curx = win->_curx;\n\t    nwin->_cury = win->_cury;\n\t    nwin->_maxy = win->_maxy;\n\t    nwin->_maxx = win->_maxx;\n\t    nwin->_begy = win->_begy;\n\t    nwin->_begx = win->_begx;\n\t    nwin->_yoffset = win->_yoffset;\n\n\t    nwin->_flags = win->_flags & ~_SUBWIN;\n\t    /* Due to the use of newwin(), the clone is not a subwindow.\n\t     * The text is really copied into the clone.\n\t     */\n\n\t    WINDOW_ATTRS(nwin) = WINDOW_ATTRS(win);\n\t    nwin->_nc_bkgd = win->_nc_bkgd;\n\n\t    nwin->_notimeout = win->_notimeout;\n\t    nwin->_clear = win->_clear;\n\t    nwin->_leaveok = win->_leaveok;\n\t    nwin->_scroll = win->_scroll;\n\t    nwin->_idlok = win->_idlok;\n\t    nwin->_idcok = win->_idcok;\n\t    nwin->_immed = win->_immed;\n\t    nwin->_sync = win->_sync;\n\t    nwin->_use_keypad = win->_use_keypad;\n\t    nwin->_delay = win->_delay;\n\n\t    nwin->_parx = 0;\n\t    nwin->_pary = 0;\n\t    nwin->_parent = (WINDOW *) 0;\n\t    /* See above: the clone isn't a subwindow! */\n\n\t    nwin->_regtop = win->_regtop;\n\t    nwin->_regbottom = win->_regbottom;\n\n\t    if (win->_flags & _ISPAD)\n\t\tnwin->_pad = win->_pad;\n\n\t    linesize = (unsigned) (win->_maxx + 1) * sizeof(NCURSES_CH_T);\n\t    for (i = 0; i <= nwin->_maxy; i++) {\n\t\tmemcpy(nwin->_line[i].text, win->_line[i].text, linesize);\n\t\tnwin->_line[i].firstchar = win->_line[i].firstchar;\n\t\tnwin->_line[i].lastchar = win->_line[i].lastchar;\n\t    }\n\t}\n\t_nc_unlock_global(curses);\n    }\n    returnWin(nwin);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*-----------------------------------------------------------------\n *\n *\tlib_doupdate.c\n *\n * \tThe routine doupdate() and its dependents.\n * \tAll physical output is concentrated here (except _nc_outch()\n *\tin lib_tputs.c).\n *\n *-----------------------------------------------------------------*/\n\n#define NEW_PAIR_INTERNAL 1\n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\n#if defined __HAIKU__ && defined __BEOS__\n#undef __BEOS__\n#endif\n\n#ifdef __BEOS__\n#undef false\n#undef true\n#include <OS.h>\n#endif\n\n#if defined(TRACE) && HAVE_SYS_TIMES_H && HAVE_TIMES\n#define USE_TRACE_TIMES 1\n#else\n#define USE_TRACE_TIMES 0\n#endif\n\n#if HAVE_SYS_TIME_H && HAVE_SYS_TIME_SELECT\n#include <sys/time.h>\n#endif\n\n#if USE_TRACE_TIMES\n#include <sys/times.h>\n#endif\n\n#if USE_FUNC_POLL\n#elif HAVE_SELECT\n#if HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#endif\n\n#include <ctype.h>\n\nMODULE_ID(\"$Id: tty_update.c,v 1.297 2017/09/02 21:45:44 Jeb.Rosen Exp $\")\n\n/*\n * This define controls the line-breakout optimization.  Every once in a\n * while during screen refresh, we want to check for input and abort the\n * update if there's some waiting.  CHECK_INTERVAL controls the number of\n * changed lines to be emitted between input checks.\n *\n * Note: Input-check-and-abort is no longer done if the screen is being\n * updated from scratch.  This is a feature, not a bug.\n */\n#define CHECK_INTERVAL\t5\n\n#define FILL_BCE(sp) (sp->_coloron && !sp->_default_color && !back_color_erase)\n\nstatic const NCURSES_CH_T blankchar = NewChar(BLANK_TEXT);\nstatic NCURSES_CH_T normal = NewChar(BLANK_TEXT);\n\n/*\n * Enable checking to see if doupdate and friends are tracking the true\n * cursor position correctly.  NOTE: this is a debugging hack which will\n * work ONLY on ANSI-compatible terminals!\n */\n/* #define POSITION_DEBUG */\n\nstatic NCURSES_INLINE NCURSES_CH_T ClrBlank(NCURSES_SP_DCLx WINDOW *win);\n\n#if NCURSES_SP_FUNCS\nstatic int ClrBottom(SCREEN *, int total);\nstatic void ClearScreen(SCREEN *, NCURSES_CH_T blank);\nstatic void ClrUpdate(SCREEN *);\nstatic void DelChar(SCREEN *, int count);\nstatic void InsStr(SCREEN *, NCURSES_CH_T * line, int count);\nstatic void TransformLine(SCREEN *, int const lineno);\n#else\nstatic int ClrBottom(int total);\nstatic void ClearScreen(NCURSES_CH_T blank);\nstatic void ClrUpdate(void);\nstatic void DelChar(int count);\nstatic void InsStr(NCURSES_CH_T * line, int count);\nstatic void TransformLine(int const lineno);\n#endif\n\n#ifdef POSITION_DEBUG\n/****************************************************************************\n *\n * Debugging code.  Only works on ANSI-standard terminals.\n *\n ****************************************************************************/\n\nstatic void\nposition_check(NCURSES_SP_DCLx int expected_y, int expected_x, char *legend)\n/* check to see if the real cursor position matches the virtual */\n{\n    char buf[20];\n    char *s;\n    int y, x;\n\n    if (!_nc_tracing || (expected_y < 0 && expected_x < 0))\n\treturn;\n\n    NCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n    memset(buf, '\\0', sizeof(buf));\n    NCURSES_PUTP2_FLUSH(\"cpr\", \"\\033[6n\");\t/* only works on ANSI-compatibles */\n    *(s = buf) = 0;\n    do {\n\tint ask = sizeof(buf) - 1 - (s - buf);\n\tint got = read(0, s, ask);\n\tif (got == 0)\n\t    break;\n\ts += got;\n    } while (strchr(buf, 'R') == 0);\n    _tracef(\"probe returned %s\", _nc_visbuf(buf));\n\n    /* try to interpret as a position report */\n    if (sscanf(buf, \"\\033[%d;%dR\", &y, &x) != 2) {\n\t_tracef(\"position probe failed in %s\", legend);\n    } else {\n\tif (expected_x < 0)\n\t    expected_x = x - 1;\n\tif (expected_y < 0)\n\t    expected_y = y - 1;\n\tif (y - 1 != expected_y || x - 1 != expected_x) {\n\t    NCURSES_SP_NAME(beep) (NCURSES_SP_ARG);\n\t    NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t    tparm(\"\\033[%d;%dH\",\n\t\t\t\t\t  expected_y + 1,\n\t\t\t\t\t  expected_x + 1),\n\t\t\t\t    1, NCURSES_SP_NAME(_nc_outch));\n\t    _tracef(\"position seen (%d, %d) doesn't match expected one (%d, %d) in %s\",\n\t\t    y - 1, x - 1, expected_y, expected_x, legend);\n\t} else {\n\t    _tracef(\"position matches OK in %s\", legend);\n\t}\n    }\n}\n#else\n#define position_check(expected_y, expected_x, legend)\t/* nothing */\n#endif /* POSITION_DEBUG */\n\n/****************************************************************************\n *\n * Optimized update code\n *\n ****************************************************************************/\n\nstatic NCURSES_INLINE void\nGoTo(NCURSES_SP_DCLx int const row, int const col)\n{\n    TR(TRACE_MOVE, (\"GoTo(%p, %d, %d) from (%d, %d)\",\n\t\t    (void *) SP_PARM, row, col, SP_PARM->_cursrow, SP_PARM->_curscol));\n\n    position_check(NCURSES_SP_ARGx\n\t\t   SP_PARM->_cursrow,\n\t\t   SP_PARM->_curscol, \"GoTo\");\n\n    TINFO_MVCUR(NCURSES_SP_ARGx\n\t\tSP_PARM->_cursrow,\n\t\tSP_PARM->_curscol,\n\t\trow, col);\n    position_check(NCURSES_SP_ARGx\n\t\t   SP_PARM->_cursrow,\n\t\t   SP_PARM->_curscol, \"GoTo2\");\n}\n\n#if !NCURSES_WCWIDTH_GRAPHICS\nstatic bool\nis_wacs_value(unsigned ch)\n{\n    bool result;\n    switch (ch) {\n    case 0x00a3:\t\t/* FALLTHRU - ncurses pound-sterling symbol */\n    case 0x00b0:\t\t/* FALLTHRU - VT100 degree symbol */\n    case 0x00b1:\t\t/* FALLTHRU - VT100 plus/minus */\n    case 0x00b7:\t\t/* FALLTHRU - VT100 bullet */\n    case 0x03c0:\t\t/* FALLTHRU - ncurses greek pi */\n    case 0x2190:\t\t/* FALLTHRU - Teletype arrow pointing left */\n    case 0x2191:\t\t/* FALLTHRU - Teletype arrow pointing up */\n    case 0x2192:\t\t/* FALLTHRU - Teletype arrow pointing right */\n    case 0x2193:\t\t/* FALLTHRU - Teletype arrow pointing down */\n    case 0x2260:\t\t/* FALLTHRU - ncurses not-equal */\n    case 0x2264:\t\t/* FALLTHRU - ncurses less-than-or-equal-to */\n    case 0x2265:\t\t/* FALLTHRU - ncurses greater-than-or-equal-to */\n    case 0x23ba:\t\t/* FALLTHRU - VT100 scan line 1 */\n    case 0x23bb:\t\t/* FALLTHRU - ncurses scan line 3 */\n    case 0x23bc:\t\t/* FALLTHRU - ncurses scan line 7 */\n    case 0x23bd:\t\t/* FALLTHRU - VT100 scan line 9 */\n    case 0x2500:\t\t/* FALLTHRU - VT100 horizontal line */\n    case 0x2501:\t\t/* FALLTHRU - thick horizontal line */\n    case 0x2502:\t\t/* FALLTHRU - VT100 vertical line */\n    case 0x2503:\t\t/* FALLTHRU - thick vertical line */\n    case 0x250c:\t\t/* FALLTHRU - VT100 upper left corner */\n    case 0x250f:\t\t/* FALLTHRU - thick upper left corner */\n    case 0x2510:\t\t/* FALLTHRU - VT100 upper right corner */\n    case 0x2513:\t\t/* FALLTHRU - thick upper right corner */\n    case 0x2514:\t\t/* FALLTHRU - VT100 lower left corner */\n    case 0x2517:\t\t/* FALLTHRU - thick lower left corner */\n    case 0x2518:\t\t/* FALLTHRU - VT100 lower right corner */\n    case 0x251b:\t\t/* FALLTHRU - thick lower right corner */\n    case 0x251c:\t\t/* FALLTHRU - VT100 tee pointing left */\n    case 0x2523:\t\t/* FALLTHRU - thick tee pointing left */\n    case 0x2524:\t\t/* FALLTHRU - VT100 tee pointing right */\n    case 0x252b:\t\t/* FALLTHRU - thick tee pointing right */\n    case 0x252c:\t\t/* FALLTHRU - VT100 tee pointing down */\n    case 0x2533:\t\t/* FALLTHRU - thick tee pointing down */\n    case 0x2534:\t\t/* FALLTHRU - VT100 tee pointing up */\n    case 0x253b:\t\t/* FALLTHRU - thick tee pointing up */\n    case 0x253c:\t\t/* FALLTHRU - VT100 large plus or crossover */\n    case 0x254b:\t\t/* FALLTHRU - thick large plus or crossover */\n    case 0x2550:\t\t/* FALLTHRU - double horizontal line */\n    case 0x2551:\t\t/* FALLTHRU - double vertical line */\n    case 0x2554:\t\t/* FALLTHRU - double upper left corner */\n    case 0x2557:\t\t/* FALLTHRU - double upper right corner */\n    case 0x255a:\t\t/* FALLTHRU - double lower left corner */\n    case 0x255d:\t\t/* FALLTHRU - double lower right corner */\n    case 0x2560:\t\t/* FALLTHRU - double tee pointing right */\n    case 0x2563:\t\t/* FALLTHRU - double tee pointing left */\n    case 0x2566:\t\t/* FALLTHRU - double tee pointing down */\n    case 0x2569:\t\t/* FALLTHRU - double tee pointing up */\n    case 0x256c:\t\t/* FALLTHRU - double large plus or crossover */\n    case 0x2592:\t\t/* FALLTHRU - VT100 checker board (stipple) */\n    case 0x25ae:\t\t/* FALLTHRU - Teletype solid square block */\n    case 0x25c6:\t\t/* FALLTHRU - VT100 diamond */\n    case 0x2603:\t\t/* FALLTHRU - Teletype lantern symbol */\n\tresult = TRUE;\n\tbreak;\n    default:\n\tresult = FALSE;\n\tbreak;\n    }\n    return result;\n}\n#endif\n\nstatic NCURSES_INLINE void\nPutAttrChar(NCURSES_SP_DCLx CARG_CH_T ch)\n{\n    int chlen = 1;\n    NCURSES_CH_T my_ch;\n#if USE_WIDEC_SUPPORT\n    PUTC_DATA;\n#endif\n    NCURSES_CH_T tilde;\n    NCURSES_CH_T attr = CHDEREF(ch);\n\n    TR(TRACE_CHARPUT, (\"PutAttrChar(%s) at (%d, %d)\",\n\t\t       _tracech_t(ch),\n\t\t       SP_PARM->_cursrow, SP_PARM->_curscol));\n#if USE_WIDEC_SUPPORT\n    /*\n     * If this is not a valid character, there is nothing more to do.\n     */\n    if (isWidecExt(CHDEREF(ch))) {\n\tTR(TRACE_CHARPUT, (\"...skip\"));\n\treturn;\n    }\n    /*\n     * Determine the number of character cells which the 'ch' value will use\n     * on the screen.  It should be at least one.\n     */\n    if ((chlen = wcwidth(CharOf(CHDEREF(ch)))) <= 0) {\n\tstatic const NCURSES_CH_T blank = NewChar(BLANK_TEXT);\n\n\t/*\n\t * If the character falls into any of these special cases, do\n\t * not force the result to a blank:\n\t *\n\t * a) it is printable (this works around a bug in wcwidth()).\n\t * b) use_legacy_coding() has been called to modify the treatment\n\t *    of codes 128-255.\n\t * c) the acs_map[] has been initialized to allow codes 0-31\n\t *    to be rendered.  This supports Linux console's \"PC\"\n\t *    characters.  Codes 128-255 are allowed though this is\n\t *    not checked.\n\t */\n\tif (is8bits(CharOf(CHDEREF(ch)))\n\t    && (isprint(CharOf(CHDEREF(ch)))\n\t\t|| (SP_PARM->_legacy_coding > 0 && CharOf(CHDEREF(ch)) >= 160)\n\t\t|| (SP_PARM->_legacy_coding > 1 && CharOf(CHDEREF(ch)) >= 128)\n\t\t|| (AttrOf(attr) & A_ALTCHARSET\n\t\t    && ((CharOfD(ch) < ACS_LEN\n\t\t\t && SP_PARM->_acs_map != 0\n\t\t\t && SP_PARM->_acs_map[CharOfD(ch)] != 0)\n\t\t\t|| (CharOfD(ch) >= 128))))) {\n\t    ;\n\t} else {\n\t    ch = CHREF(blank);\n\t    TR(TRACE_CHARPUT, (\"forced to blank\"));\n\t}\n\tchlen = 1;\n    }\n#endif\n\n    if ((AttrOf(attr) & A_ALTCHARSET)\n\t&& SP_PARM->_acs_map != 0\n\t&& ((CharOfD(ch) < ACS_LEN)\n#if !NCURSES_WCWIDTH_GRAPHICS\n\t    || is_wacs_value(CharOfD(ch))\n#endif\n\t)) {\n\tmy_ch = CHDEREF(ch);\t/* work around const param */\n#if USE_WIDEC_SUPPORT\n\t/*\n\t * This is crude & ugly, but works most of the time.  It checks if the\n\t * acs_chars string specified that we have a mapping for this\n\t * character, and uses the wide-character mapping when we expect the\n\t * normal one to be broken (by mis-design ;-).\n\t */\n\tif (SP_PARM->_screen_unicode\n\t    && _nc_wacs[CharOf(my_ch)].chars[0]) {\n\t    if (SP_PARM->_screen_acs_map[CharOf(my_ch)]) {\n\t\tif (SP_PARM->_screen_acs_fix) {\n\t\t    RemAttr(attr, A_ALTCHARSET);\n\t\t    my_ch = _nc_wacs[CharOf(my_ch)];\n\t\t}\n\t    } else {\n\t\tRemAttr(attr, A_ALTCHARSET);\n\t\tmy_ch = _nc_wacs[CharOf(my_ch)];\n\t    }\n#if !NCURSES_WCWIDTH_GRAPHICS\n\t    if (!(AttrOf(attr) & A_ALTCHARSET)) {\n\t\tchlen = 1;\n\t    }\n#endif /* !NCURSES_WCWIDTH_GRAPHICS */\n\t}\n#endif\n\t/*\n\t * If we (still) have alternate character set, it is the normal 8bit\n\t * flavor.  The _screen_acs_map[] array tells if the character was\n\t * really in acs_chars, needed because of the way wide/normal line\n\t * drawing flavors are integrated.\n\t */\n\tif (AttrOf(attr) & A_ALTCHARSET) {\n\t    int j = CharOfD(ch);\n\t    chtype temp = UChar(SP_PARM->_acs_map[j]);\n\n\t    if (temp != 0) {\n\t\tSetChar(my_ch, temp, AttrOf(attr));\n\t    } else {\n\t\tmy_ch = CHDEREF(ch);\n\t\tRemAttr(attr, A_ALTCHARSET);\n\t    }\n\t}\n\tch = CHREF(my_ch);\n    }\n#if USE_WIDEC_SUPPORT && !NCURSES_WCWIDTH_GRAPHICS\n    else if (chlen > 1 && is_wacs_value(CharOfD(ch))) {\n\tchlen = 1;\n    }\n#endif\n    if (tilde_glitch && (CharOfD(ch) == L('~'))) {\n\tSetChar(tilde, L('`'), AttrOf(attr));\n\tch = CHREF(tilde);\n    }\n\n    UpdateAttrs(SP_PARM, attr);\n    PUTC(CHDEREF(ch));\n#if !USE_WIDEC_SUPPORT\n    COUNT_OUTCHARS(1);\n#endif\n    SP_PARM->_curscol += chlen;\n    if (char_padding) {\n\tNCURSES_PUTP2(\"char_padding\", char_padding);\n    }\n}\n\nstatic bool\ncheck_pending(NCURSES_SP_DCL0)\n/* check for pending input */\n{\n    bool have_pending = FALSE;\n\n    /*\n     * Only carry out this check when the flag is zero, otherwise we'll\n     * have the refreshing slow down drastically (or stop) if there's an\n     * unread character available.\n     */\n    if (SP_PARM->_fifohold != 0)\n\treturn FALSE;\n\n    if (SP_PARM->_checkfd >= 0) {\n#if USE_FUNC_POLL\n\tstruct pollfd fds[1];\n\tfds[0].fd = SP_PARM->_checkfd;\n\tfds[0].events = POLLIN;\n\tif (poll(fds, (size_t) 1, 0) > 0) {\n\t    have_pending = TRUE;\n\t}\n#elif defined(__BEOS__)\n\t/*\n\t * BeOS's select() is declared in socket.h, so the configure script does\n\t * not see it.  That's just as well, since that function works only for\n\t * sockets.  This (using snooze and ioctl) was distilled from Be's patch\n\t * for ncurses which uses a separate thread to simulate select().\n\t *\n\t * FIXME: the return values from the ioctl aren't very clear if we get\n\t * interrupted.\n\t */\n\tint n = 0;\n\tint howmany = ioctl(0, 'ichr', &n);\n\tif (howmany >= 0 && n > 0) {\n\t    have_pending = TRUE;\n\t}\n#elif HAVE_SELECT\n\tfd_set fdset;\n\tstruct timeval ktimeout;\n\n\tktimeout.tv_sec =\n\t    ktimeout.tv_usec = 0;\n\n\tFD_ZERO(&fdset);\n\tFD_SET(SP_PARM->_checkfd, &fdset);\n\tif (select(SP_PARM->_checkfd + 1, &fdset, NULL, NULL, &ktimeout) != 0) {\n\t    have_pending = TRUE;\n\t}\n#endif\n    }\n    if (have_pending) {\n\tSP_PARM->_fifohold = 5;\n\tNCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n    }\n    return FALSE;\n}\n\n/* put char at lower right corner */\nstatic void\nPutCharLR(NCURSES_SP_DCLx const ARG_CH_T ch)\n{\n    if (!auto_right_margin) {\n\t/* we can put the char directly */\n\tPutAttrChar(NCURSES_SP_ARGx ch);\n    } else if (enter_am_mode && exit_am_mode) {\n\t/* we can suppress automargin */\n\tNCURSES_PUTP2(\"exit_am_mode\", exit_am_mode);\n\n\tPutAttrChar(NCURSES_SP_ARGx ch);\n\tSP_PARM->_curscol--;\n\tposition_check(NCURSES_SP_ARGx\n\t\t       SP_PARM->_cursrow,\n\t\t       SP_PARM->_curscol,\n\t\t       \"exit_am_mode\");\n\n\tNCURSES_PUTP2(\"enter_am_mode\", enter_am_mode);\n    } else if ((enter_insert_mode && exit_insert_mode)\n\t       || insert_character || parm_ich) {\n\tGoTo(NCURSES_SP_ARGx\n\t     screen_lines(SP_PARM) - 1,\n\t     screen_columns(SP_PARM) - 2);\n\tPutAttrChar(NCURSES_SP_ARGx ch);\n\tGoTo(NCURSES_SP_ARGx\n\t     screen_lines(SP_PARM) - 1,\n\t     screen_columns(SP_PARM) - 2);\n\tInsStr(NCURSES_SP_ARGx\n\t       NewScreen(SP_PARM)->_line[screen_lines(SP_PARM) - 1].text +\n\t       screen_columns(SP_PARM) - 2, 1);\n    }\n}\n\n/*\n * Wrap the cursor position, i.e., advance to the beginning of the next line.\n */\nstatic void\nwrap_cursor(NCURSES_SP_DCL0)\n{\n    if (eat_newline_glitch) {\n\t/*\n\t * xenl can manifest two different ways.  The vt100 way is that, when\n\t * you'd expect the cursor to wrap, it stays hung at the right margin\n\t * (on top of the character just emitted) and doesn't wrap until the\n\t * *next* graphic char is emitted.  The c100 way is to ignore LF\n\t * received just after an am wrap.\n\t *\n\t * An aggressive way to handle this would be to emit CR/LF after the\n\t * char and then assume the wrap is done, you're on the first position\n\t * of the next line, and the terminal out of its weird state.  Here\n\t * it's safe to just tell the code that the cursor is in hyperspace and\n\t * let the next mvcur() call straighten things out.\n\t */\n\tSP_PARM->_curscol = -1;\n\tSP_PARM->_cursrow = -1;\n    } else if (auto_right_margin) {\n\tSP_PARM->_curscol = 0;\n\tSP_PARM->_cursrow++;\n\t/*\n\t * We've actually moved - but may have to work around problems with\n\t * video attributes not working.\n\t */\n\tif (!move_standout_mode && AttrOf(SCREEN_ATTRS(SP_PARM))) {\n\t    TR(TRACE_CHARPUT, (\"turning off (%#lx) %s before wrapping\",\n\t\t\t       (unsigned long) AttrOf(SCREEN_ATTRS(SP_PARM)),\n\t\t\t       _traceattr(AttrOf(SCREEN_ATTRS(SP_PARM)))));\n\t    (void) VIDATTR(SP_PARM, A_NORMAL, 0);\n\t}\n    } else {\n\tSP_PARM->_curscol--;\n    }\n    position_check(NCURSES_SP_ARGx\n\t\t   SP_PARM->_cursrow,\n\t\t   SP_PARM->_curscol,\n\t\t   \"wrap_cursor\");\n}\n\nstatic NCURSES_INLINE void\nPutChar(NCURSES_SP_DCLx const ARG_CH_T ch)\n/* insert character, handling automargin stuff */\n{\n    if (SP_PARM->_cursrow == screen_lines(SP_PARM) - 1 &&\n\tSP_PARM->_curscol == screen_columns(SP_PARM) - 1) {\n\tPutCharLR(NCURSES_SP_ARGx ch);\n    } else {\n\tPutAttrChar(NCURSES_SP_ARGx ch);\n    }\n\n    if (SP_PARM->_curscol >= screen_columns(SP_PARM))\n\twrap_cursor(NCURSES_SP_ARG);\n\n    position_check(NCURSES_SP_ARGx\n\t\t   SP_PARM->_cursrow,\n\t\t   SP_PARM->_curscol, \"PutChar\");\n}\n\n/*\n * Check whether the given character can be output by clearing commands.  This\n * includes test for being a space and not including any 'bad' attributes, such\n * as A_REVERSE.  All attribute flags which don't affect appearance of a space\n * or can be output by clearing (A_COLOR in case of bce-terminal) are excluded.\n */\nstatic NCURSES_INLINE bool\ncan_clear_with(NCURSES_SP_DCLx ARG_CH_T ch)\n{\n    if (!back_color_erase && SP_PARM->_coloron) {\n#if NCURSES_EXT_FUNCS\n\tint pair;\n\n\tif (!SP_PARM->_default_color)\n\t    return FALSE;\n\tif (!(isDefaultColor(SP_PARM->_default_fg) &&\n\t      isDefaultColor(SP_PARM->_default_bg)))\n\t    return FALSE;\n\tif ((pair = GetPair(CHDEREF(ch))) != 0) {\n\t    NCURSES_COLOR_T fg, bg;\n\t    if (NCURSES_SP_NAME(pair_content) (NCURSES_SP_ARGx\n\t\t\t\t\t       (short) pair,\n\t\t\t\t\t       &fg, &bg) == ERR\n\t\t|| !(isDefaultColor(fg) && isDefaultColor(bg))) {\n\t\treturn FALSE;\n\t    }\n\t}\n#else\n\tif (AttrOfD(ch) & A_COLOR)\n\t    return FALSE;\n#endif\n    }\n    return (ISBLANK(CHDEREF(ch)) &&\n\t    (AttrOfD(ch) & ~(NONBLANK_ATTR | A_COLOR)) == BLANK_ATTR);\n}\n\n/*\n * Issue a given span of characters from an array.\n * Must be functionally equivalent to:\n *\tfor (i = 0; i < num; i++)\n *\t    PutChar(ntext[i]);\n * but can leave the cursor positioned at the middle of the interval.\n *\n * Returns: 0 - cursor is at the end of interval\n *\t    1 - cursor is somewhere in the middle\n *\n * This code is optimized using ech and rep.\n */\nstatic int\nEmitRange(NCURSES_SP_DCLx const NCURSES_CH_T * ntext, int num)\n{\n    int i;\n\n    TR(TRACE_CHARPUT, (\"EmitRange %d:%s\", num, _nc_viscbuf(ntext, num)));\n\n    if (erase_chars || repeat_char) {\n\twhile (num > 0) {\n\t    int runcount;\n\t    NCURSES_CH_T ntext0;\n\n\t    while (num > 1 && !CharEq(ntext[0], ntext[1])) {\n\t\tPutChar(NCURSES_SP_ARGx CHREF(ntext[0]));\n\t\tntext++;\n\t\tnum--;\n\t    }\n\t    ntext0 = ntext[0];\n\t    if (num == 1) {\n\t\tPutChar(NCURSES_SP_ARGx CHREF(ntext0));\n\t\treturn 0;\n\t    }\n\t    runcount = 2;\n\n\t    while (runcount < num && CharEq(ntext[runcount], ntext0))\n\t\truncount++;\n\n\t    /*\n\t     * The cost expression in the middle isn't exactly right.\n\t     * _cup_ch_cost is an upper bound on the cost for moving to the\n\t     * end of the erased area, but not the cost itself (which we\n\t     * can't compute without emitting the move).  This may result\n\t     * in erase_chars not getting used in some situations for\n\t     * which it would be marginally advantageous.\n\t     */\n\t    if (erase_chars\n\t\t&& runcount > SP_PARM->_ech_cost + SP_PARM->_cup_ch_cost\n\t\t&& can_clear_with(NCURSES_SP_ARGx CHREF(ntext0))) {\n\t\tUpdateAttrs(SP_PARM, ntext0);\n\t\tNCURSES_PUTP2(\"erase_chars\", TPARM_1(erase_chars, runcount));\n\n\t\t/*\n\t\t * If this is the last part of the given interval,\n\t\t * don't bother moving cursor, since it can be the\n\t\t * last update on the line.\n\t\t */\n\t\tif (runcount < num) {\n\t\t    GoTo(NCURSES_SP_ARGx\n\t\t\t SP_PARM->_cursrow,\n\t\t\t SP_PARM->_curscol + runcount);\n\t\t} else {\n\t\t    return 1;\t/* cursor stays in the middle */\n\t\t}\n\t    } else if (repeat_char != 0 &&\n#if USE_WIDEC_SUPPORT\n\t\t       (!SP_PARM->_screen_unicode &&\n\t\t\t((AttrOf(ntext0) & A_ALTCHARSET) == 0 ||\n\t\t\t (CharOf(ntext0) < ACS_LEN))) &&\n#endif\n\t\t       runcount > SP_PARM->_rep_cost) {\n\t\tNCURSES_CH_T temp;\n\t\tbool wrap_possible = (SP_PARM->_curscol + runcount >=\n\t\t\t\t      screen_columns(SP_PARM));\n\t\tint rep_count = runcount;\n\n\t\tif (wrap_possible)\n\t\t    rep_count--;\n\n\t\tUpdateAttrs(SP_PARM, ntext0);\n\t\ttemp = ntext0;\n\t\tif ((AttrOf(temp) & A_ALTCHARSET) &&\n\t\t    SP_PARM->_acs_map != 0 &&\n\t\t    (SP_PARM->_acs_map[CharOf(temp)] & A_CHARTEXT) != 0) {\n\t\t    SetChar(temp,\n\t\t\t    (SP_PARM->_acs_map[CharOf(ntext0)] & A_CHARTEXT),\n\t\t\t    AttrOf(ntext0) | A_ALTCHARSET);\n\t\t}\n\t\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t\tTPARM_2(repeat_char,\n\t\t\t\t\t\tCharOf(temp),\n\t\t\t\t\t\trep_count),\n\t\t\t\t\t1,\n\t\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n\t\tSP_PARM->_curscol += rep_count;\n\n\t\tif (wrap_possible)\n\t\t    PutChar(NCURSES_SP_ARGx CHREF(ntext0));\n\t    } else {\n\t\tfor (i = 0; i < runcount; i++)\n\t\t    PutChar(NCURSES_SP_ARGx CHREF(ntext[i]));\n\t    }\n\t    ntext += runcount;\n\t    num -= runcount;\n\t}\n\treturn 0;\n    }\n\n    for (i = 0; i < num; i++)\n\tPutChar(NCURSES_SP_ARGx CHREF(ntext[i]));\n    return 0;\n}\n\n/*\n * Output the line in the given range [first .. last]\n *\n * If there's a run of identical characters that's long enough to justify\n * cursor movement, use that also.\n *\n * Returns: same as EmitRange\n */\nstatic int\nPutRange(NCURSES_SP_DCLx\n\t const NCURSES_CH_T * otext,\n\t const NCURSES_CH_T * ntext,\n\t int row,\n\t int first, int last)\n{\n    int rc;\n\n    TR(TRACE_CHARPUT, (\"PutRange(%p, %p, %p, %d, %d, %d)\",\n\t\t       (void *) SP_PARM,\n\t\t       (const void *) otext,\n\t\t       (const void *) ntext,\n\t\t       row, first, last));\n\n    if (otext != ntext\n\t&& (last - first + 1) > SP_PARM->_inline_cost) {\n\tint i, j, same;\n\n\tfor (j = first, same = 0; j <= last; j++) {\n\t    if (!same && isWidecExt(otext[j]))\n\t\tcontinue;\n\t    if (CharEq(otext[j], ntext[j])) {\n\t\tsame++;\n\t    } else {\n\t\tif (same > SP_PARM->_inline_cost) {\n\t\t    EmitRange(NCURSES_SP_ARGx ntext + first, j - same - first);\n\t\t    GoTo(NCURSES_SP_ARGx row, first = j);\n\t\t}\n\t\tsame = 0;\n\t    }\n\t}\n\ti = EmitRange(NCURSES_SP_ARGx ntext + first, j - same - first);\n\t/*\n\t * Always return 1 for the next GoTo() after a PutRange() if we found\n\t * identical characters at end of interval\n\t */\n\trc = (same == 0 ? i : 1);\n    } else {\n\trc = EmitRange(NCURSES_SP_ARGx ntext + first, last - first + 1);\n    }\n    return rc;\n}\n\n/* leave unbracketed here so 'indent' works */\n#define MARK_NOCHANGE(win,row) \\\n\t\twin->_line[row].firstchar = _NOCHANGE; \\\n\t\twin->_line[row].lastchar = _NOCHANGE; \\\n\t\tif_USE_SCROLL_HINTS(win->_line[row].oldindex = row)\n\nNCURSES_EXPORT(int)\nTINFO_DOUPDATE(NCURSES_SP_DCL0)\n{\n    int i;\n    int nonempty;\n#if USE_TRACE_TIMES\n    struct tms before, after;\n#endif /* USE_TRACE_TIMES */\n\n    T((T_CALLED(\"_nc_tinfo:doupdate(%p)\"), (void *) SP_PARM));\n\n    _nc_lock_global(update);\n\n    if (SP_PARM == 0) {\n\t_nc_unlock_global(update);\n\treturnCode(ERR);\n    }\n#if !USE_REENTRANT\n    /*\n     * It is \"legal\" but unlikely that an application could assign a new\n     * value to one of the standard windows.  Check for that possibility\n     * and try to recover.\n     *\n     * We do not allow applications to assign new values in the reentrant\n     * model.\n     */\n#define SyncScreens(internal,exported) \\\n\tif (internal == 0) internal = exported; \\\n\tif (internal != exported) exported = internal\n\n    SyncScreens(CurScreen(SP_PARM), curscr);\n    SyncScreens(NewScreen(SP_PARM), newscr);\n    SyncScreens(StdScreen(SP_PARM), stdscr);\n#endif\n\n    if (CurScreen(SP_PARM) == 0\n\t|| NewScreen(SP_PARM) == 0\n\t|| StdScreen(SP_PARM) == 0) {\n\t_nc_unlock_global(update);\n\treturnCode(ERR);\n    }\n#ifdef TRACE\n    if (USE_TRACEF(TRACE_UPDATE)) {\n\tif (CurScreen(SP_PARM)->_clear)\n\t    _tracef(\"curscr is clear\");\n\telse\n\t    _tracedump(\"curscr\", CurScreen(SP_PARM));\n\t_tracedump(\"newscr\", NewScreen(SP_PARM));\n\t_nc_unlock_global(tracef);\n    }\n#endif /* TRACE */\n\n    _nc_signal_handler(FALSE);\n\n    if (SP_PARM->_fifohold)\n\tSP_PARM->_fifohold--;\n\n#if USE_SIZECHANGE\n    if ((SP_PARM->_endwin == ewSuspend)\n\t|| _nc_handle_sigwinch(SP_PARM)) {\n\t/*\n\t * This is a transparent extension:  XSI does not address it,\n\t * and applications need not know that ncurses can do it.\n\t *\n\t * Check if the terminal size has changed while curses was off\n\t * (this can happen in an xterm, for example), and resize the\n\t * ncurses data structures accordingly.\n\t */\n\t_nc_update_screensize(SP_PARM);\n    }\n#endif\n\n    if (SP_PARM->_endwin == ewSuspend) {\n\n\tT((\"coming back from shell mode\"));\n\tNCURSES_SP_NAME(reset_prog_mode) (NCURSES_SP_ARG);\n\n\tNCURSES_SP_NAME(_nc_mvcur_resume) (NCURSES_SP_ARG);\n\tNCURSES_SP_NAME(_nc_screen_resume) (NCURSES_SP_ARG);\n\tSP_PARM->_mouse_resume(SP_PARM);\n\n\tSP_PARM->_endwin = ewRunning;\n    }\n#if USE_TRACE_TIMES\n    /* zero the metering machinery */\n    RESET_OUTCHARS();\n    (void) times(&before);\n#endif /* USE_TRACE_TIMES */\n\n    /*\n     * This is the support for magic-cookie terminals.  The theory:  we scan\n     * the virtual screen looking for attribute turnons.  Where we find one,\n     * check to make sure it's realizable by seeing if the required number of\n     * un-attributed blanks are present before and after the attributed range;\n     * try to shift the range boundaries over blanks (not changing the screen\n     * display) so this becomes true.  If it is, shift the beginning attribute\n     * change appropriately (the end one, if we've gotten this far, is\n     * guaranteed room for its cookie).  If not, nuke the added attributes out\n     * of the span.\n     */\n#if USE_XMC_SUPPORT\n    if (magic_cookie_glitch > 0) {\n\tint j, k;\n\tattr_t rattr = A_NORMAL;\n\n\tfor (i = 0; i < screen_lines(SP_PARM); i++) {\n\t    for (j = 0; j < screen_columns(SP_PARM); j++) {\n\t\tbool failed = FALSE;\n\t\tNCURSES_CH_T *thisline = NewScreen(SP_PARM)->_line[i].text;\n\t\tattr_t thisattr = AttrOf(thisline[j]) & SP_PARM->_xmc_triggers;\n\t\tattr_t turnon = thisattr & ~rattr;\n\n\t\t/* is an attribute turned on here? */\n\t\tif (turnon == 0) {\n\t\t    rattr = thisattr;\n\t\t    continue;\n\t\t}\n\n\t\tTR(TRACE_ATTRS, (\"At (%d, %d): from %s...\", i, j, _traceattr(rattr)));\n\t\tTR(TRACE_ATTRS, (\"...to %s\", _traceattr(turnon)));\n\n\t\t/*\n\t\t * If the attribute change location is a blank with a \"safe\"\n\t\t * attribute, undo the attribute turnon.  This may ensure\n\t\t * there's enough room to set the attribute before the first\n\t\t * non-blank in the run.\n\t\t */\n#define SAFE(scr,a)\t(!((a) & (scr)->_xmc_triggers))\n\t\tif (ISBLANK(thisline[j]) && SAFE(SP_PARM, turnon)) {\n\t\t    RemAttr(thisline[j], turnon);\n\t\t    continue;\n\t\t}\n\n\t\t/* check that there's enough room at start of span */\n\t\tfor (k = 1; k <= magic_cookie_glitch; k++) {\n\t\t    if (j - k < 0\n\t\t\t|| !ISBLANK(thisline[j - k])\n\t\t\t|| !SAFE(SP_PARM, AttrOf(thisline[j - k]))) {\n\t\t\tfailed = TRUE;\n\t\t\tTR(TRACE_ATTRS, (\"No room at start in %d,%d%s%s\",\n\t\t\t\t\t i, j - k,\n\t\t\t\t\t (ISBLANK(thisline[j - k])\n\t\t\t\t\t  ? \"\"\n\t\t\t\t\t  : \":nonblank\"),\n\t\t\t\t\t (SAFE(SP_PARM, AttrOf(thisline[j - k]))\n\t\t\t\t\t  ? \"\"\n\t\t\t\t\t  : \":unsafe\")));\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (!failed) {\n\t\t    bool end_onscreen = FALSE;\n\t\t    int m, n = j;\n\n\t\t    /* find end of span, if it's onscreen */\n\t\t    for (m = i; m < screen_lines(SP_PARM); m++) {\n\t\t\tfor (; n < screen_columns(SP_PARM); n++) {\n\t\t\t    attr_t testattr =\n\t\t\t    AttrOf(NewScreen(SP_PARM)->_line[m].text[n]);\n\t\t\t    if ((testattr & SP_PARM->_xmc_triggers) == rattr) {\n\t\t\t\tend_onscreen = TRUE;\n\t\t\t\tTR(TRACE_ATTRS,\n\t\t\t\t   (\"Range attributed with %s ends at (%d, %d)\",\n\t\t\t\t    _traceattr(turnon), m, n));\n\t\t\t\tgoto foundit;\n\t\t\t    }\n\t\t\t}\n\t\t\tn = 0;\n\t\t    }\n\t\t    TR(TRACE_ATTRS,\n\t\t       (\"Range attributed with %s ends offscreen\",\n\t\t\t_traceattr(turnon)));\n\t\t  foundit:;\n\n\t\t    if (end_onscreen) {\n\t\t\tNCURSES_CH_T *lastline =\n\t\t\tNewScreen(SP_PARM)->_line[m].text;\n\n\t\t\t/*\n\t\t\t * If there are safely-attributed blanks at the end of\n\t\t\t * the range, shorten the range.  This will help ensure\n\t\t\t * that there is enough room at end of span.\n\t\t\t */\n\t\t\twhile (n >= 0\n\t\t\t       && ISBLANK(lastline[n])\n\t\t\t       && SAFE(SP_PARM, AttrOf(lastline[n]))) {\n\t\t\t    RemAttr(lastline[n--], turnon);\n\t\t\t}\n\n\t\t\t/* check that there's enough room at end of span */\n\t\t\tfor (k = 1; k <= magic_cookie_glitch; k++) {\n\t\t\t    if (n + k >= screen_columns(SP_PARM)\n\t\t\t\t|| !ISBLANK(lastline[n + k])\n\t\t\t\t|| !SAFE(SP_PARM, AttrOf(lastline[n + k]))) {\n\t\t\t\tfailed = TRUE;\n\t\t\t\tTR(TRACE_ATTRS,\n\t\t\t\t   (\"No room at end in %d,%d%s%s\",\n\t\t\t\t    i, j - k,\n\t\t\t\t    (ISBLANK(lastline[n + k])\n\t\t\t\t     ? \"\"\n\t\t\t\t     : \":nonblank\"),\n\t\t\t\t    (SAFE(SP_PARM, AttrOf(lastline[n + k]))\n\t\t\t\t     ? \"\"\n\t\t\t\t     : \":unsafe\")));\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (failed) {\n\t\t    int p, q = j;\n\n\t\t    TR(TRACE_ATTRS,\n\t\t       (\"Clearing %s beginning at (%d, %d)\",\n\t\t\t_traceattr(turnon), i, j));\n\n\t\t    /* turn off new attributes over span */\n\t\t    for (p = i; p < screen_lines(SP_PARM); p++) {\n\t\t\tfor (; q < screen_columns(SP_PARM); q++) {\n\t\t\t    attr_t testattr = AttrOf(newscr->_line[p].text[q]);\n\t\t\t    if ((testattr & SP_PARM->_xmc_triggers) == rattr)\n\t\t\t\tgoto foundend;\n\t\t\t    RemAttr(NewScreen(SP_PARM)->_line[p].text[q], turnon);\n\t\t\t}\n\t\t\tq = 0;\n\t\t    }\n\t\t  foundend:;\n\t\t} else {\n\t\t    TR(TRACE_ATTRS,\n\t\t       (\"Cookie space for %s found before (%d, %d)\",\n\t\t\t_traceattr(turnon), i, j));\n\n\t\t    /*\n\t\t     * Back up the start of range so there's room for cookies\n\t\t     * before the first nonblank character.\n\t\t     */\n\t\t    for (k = 1; k <= magic_cookie_glitch; k++)\n\t\t\tAddAttr(thisline[j - k], turnon);\n\t\t}\n\n\t\trattr = thisattr;\n\t    }\n\t}\n\n#ifdef TRACE\n\t/* show altered highlights after magic-cookie check */\n\tif (USE_TRACEF(TRACE_UPDATE)) {\n\t    _tracef(\"After magic-cookie check...\");\n\t    _tracedump(\"newscr\", NewScreen(SP_PARM));\n\t    _nc_unlock_global(tracef);\n\t}\n#endif /* TRACE */\n    }\n#endif /* USE_XMC_SUPPORT */\n\n    nonempty = 0;\n    if (CurScreen(SP_PARM)->_clear || NewScreen(SP_PARM)->_clear) {\t/* force refresh ? */\n\tClrUpdate(NCURSES_SP_ARG);\n\tCurScreen(SP_PARM)->_clear = FALSE;\t/* reset flag */\n\tNewScreen(SP_PARM)->_clear = FALSE;\t/* reset flag */\n    } else {\n\tint changedlines = CHECK_INTERVAL;\n\n\tif (check_pending(NCURSES_SP_ARG))\n\t    goto cleanup;\n\n\tnonempty = min(screen_lines(SP_PARM), NewScreen(SP_PARM)->_maxy + 1);\n\n\tif (SP_PARM->_scrolling) {\n\t    NCURSES_SP_NAME(_nc_scroll_optimize) (NCURSES_SP_ARG);\n\t}\n\n\tnonempty = ClrBottom(NCURSES_SP_ARGx nonempty);\n\n\tTR(TRACE_UPDATE, (\"Transforming lines, nonempty %d\", nonempty));\n\tfor (i = 0; i < nonempty; i++) {\n\t    /*\n\t     * Here is our line-breakout optimization.\n\t     */\n\t    if (changedlines == CHECK_INTERVAL) {\n\t\tif (check_pending(NCURSES_SP_ARG))\n\t\t    goto cleanup;\n\t\tchangedlines = 0;\n\t    }\n\n\t    /*\n\t     * newscr->line[i].firstchar is normally set\n\t     * by wnoutrefresh.  curscr->line[i].firstchar\n\t     * is normally set by _nc_scroll_window in the\n\t     * vertical-movement optimization code,\n\t     */\n\t    if (NewScreen(SP_PARM)->_line[i].firstchar != _NOCHANGE\n\t\t|| CurScreen(SP_PARM)->_line[i].firstchar != _NOCHANGE) {\n\t\tTransformLine(NCURSES_SP_ARGx i);\n\t\tchangedlines++;\n\t    }\n\n\t    /* mark line changed successfully */\n\t    if (i <= NewScreen(SP_PARM)->_maxy) {\n\t\tMARK_NOCHANGE(NewScreen(SP_PARM), i);\n\t    }\n\t    if (i <= CurScreen(SP_PARM)->_maxy) {\n\t\tMARK_NOCHANGE(CurScreen(SP_PARM), i);\n\t    }\n\t}\n    }\n\n    /* put everything back in sync */\n    for (i = nonempty; i <= NewScreen(SP_PARM)->_maxy; i++) {\n\tMARK_NOCHANGE(NewScreen(SP_PARM), i);\n    }\n    for (i = nonempty; i <= CurScreen(SP_PARM)->_maxy; i++) {\n\tMARK_NOCHANGE(CurScreen(SP_PARM), i);\n    }\n\n    if (!NewScreen(SP_PARM)->_leaveok) {\n\tCurScreen(SP_PARM)->_curx = NewScreen(SP_PARM)->_curx;\n\tCurScreen(SP_PARM)->_cury = NewScreen(SP_PARM)->_cury;\n\n\tGoTo(NCURSES_SP_ARGx CurScreen(SP_PARM)->_cury, CurScreen(SP_PARM)->_curx);\n    }\n\n  cleanup:\n    /*\n     * We would like to keep the physical screen in normal mode in case we get\n     * other processes writing to the screen.  This goal cannot be met for\n     * magic cookies since it interferes with attributes that may propagate\n     * past the current position.\n     */\n#if USE_XMC_SUPPORT\n    if (magic_cookie_glitch != 0)\n#endif\n\tUpdateAttrs(SP_PARM, normal);\n\n    NCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n    WINDOW_ATTRS(CurScreen(SP_PARM)) = WINDOW_ATTRS(NewScreen(SP_PARM));\n\n#if USE_TRACE_TIMES\n    (void) times(&after);\n    TR(TRACE_TIMES,\n       (\"Update cost: %ld chars, %ld clocks system time, %ld clocks user time\",\n\t_nc_outchars,\n\t(long) (after.tms_stime - before.tms_stime),\n\t(long) (after.tms_utime - before.tms_utime)));\n#endif /* USE_TRACE_TIMES */\n\n    _nc_signal_handler(TRUE);\n\n    _nc_unlock_global(update);\n    returnCode(OK);\n}\n\n#if NCURSES_SP_FUNCS && !defined(USE_TERM_DRIVER)\nNCURSES_EXPORT(int)\ndoupdate(void)\n{\n    return TINFO_DOUPDATE(CURRENT_SCREEN);\n}\n#endif\n\n/*\n *\tClrBlank(win)\n *\n *\tReturns the attributed character that corresponds to the \"cleared\"\n *\tscreen.  If the terminal has the back-color-erase feature, this will be\n *\tcolored according to the wbkgd() call.\n *\n *\tWe treat 'curscr' specially because it isn't supposed to be set directly\n *\tin the wbkgd() call.  Assume 'stdscr' for this case.\n */\n#define BCE_ATTRS (A_NORMAL|A_COLOR)\n#define BCE_BKGD(sp,win) (((win) == CurScreen(sp) ? StdScreen(sp) : (win))->_nc_bkgd)\n\nstatic NCURSES_INLINE NCURSES_CH_T\nClrBlank(NCURSES_SP_DCLx WINDOW *win)\n{\n    NCURSES_CH_T blank = blankchar;\n    if (back_color_erase)\n\tAddAttr(blank, (AttrOf(BCE_BKGD(SP_PARM, win)) & BCE_ATTRS));\n    return blank;\n}\n\n/*\n**\tClrUpdate()\n**\n**\tUpdate by clearing and redrawing the entire screen.\n**\n*/\n\nstatic void\nClrUpdate(NCURSES_SP_DCL0)\n{\n    TR(TRACE_UPDATE, (T_CALLED(\"ClrUpdate\")));\n    if (0 != SP_PARM) {\n\tint i;\n\tNCURSES_CH_T blank = ClrBlank(NCURSES_SP_ARGx StdScreen(SP_PARM));\n\tint nonempty = min(screen_lines(SP_PARM),\n\t\t\t   NewScreen(SP_PARM)->_maxy + 1);\n\n\tClearScreen(NCURSES_SP_ARGx blank);\n\n\tTR(TRACE_UPDATE, (\"updating screen from scratch\"));\n\n\tnonempty = ClrBottom(NCURSES_SP_ARGx nonempty);\n\n\tfor (i = 0; i < nonempty; i++)\n\t    TransformLine(NCURSES_SP_ARGx i);\n    }\n    TR(TRACE_UPDATE, (T_RETURN(\"\")));\n}\n\n/*\n**\tClrToEOL(blank)\n**\n**\tClear to end of current line, starting at the cursor position\n*/\n\nstatic void\nClrToEOL(NCURSES_SP_DCLx NCURSES_CH_T blank, int needclear)\n{\n    if (CurScreen(SP_PARM) != 0\n\t&& SP_PARM->_cursrow >= 0) {\n\tint j;\n\n\tfor (j = SP_PARM->_curscol; j < screen_columns(SP_PARM); j++) {\n\t    if (j >= 0) {\n\t\tNCURSES_CH_T *cp =\n\t\t&(CurScreen(SP_PARM)->_line[SP_PARM->_cursrow].text[j]);\n\n\t\tif (!CharEq(*cp, blank)) {\n\t\t    *cp = blank;\n\t\t    needclear = TRUE;\n\t\t}\n\t    }\n\t}\n    }\n\n    if (needclear) {\n\tUpdateAttrs(SP_PARM, blank);\n\tif (clr_eol && SP_PARM->_el_cost <= (screen_columns(SP_PARM) - SP_PARM->_curscol)) {\n\t    NCURSES_PUTP2(\"clr_eol\", clr_eol);\n\t} else {\n\t    int count = (screen_columns(SP_PARM) - SP_PARM->_curscol);\n\t    while (count-- > 0)\n\t\tPutChar(NCURSES_SP_ARGx CHREF(blank));\n\t}\n    }\n}\n\n/*\n**\tClrToEOS(blank)\n**\n**\tClear to end of screen, starting at the cursor position\n*/\n\nstatic void\nClrToEOS(NCURSES_SP_DCLx NCURSES_CH_T blank)\n{\n    int row, col;\n\n    row = SP_PARM->_cursrow;\n    col = SP_PARM->_curscol;\n\n    if (row < 0)\n\trow = 0;\n    if (col < 0)\n\tcol = 0;\n\n    UpdateAttrs(SP_PARM, blank);\n    TPUTS_TRACE(\"clr_eos\");\n    NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t    clr_eos,\n\t\t\t    screen_lines(SP_PARM) - row,\n\t\t\t    NCURSES_SP_NAME(_nc_outch));\n\n    while (col < screen_columns(SP_PARM))\n\tCurScreen(SP_PARM)->_line[row].text[col++] = blank;\n\n    for (row++; row < screen_lines(SP_PARM); row++) {\n\tfor (col = 0; col < screen_columns(SP_PARM); col++)\n\t    CurScreen(SP_PARM)->_line[row].text[col] = blank;\n    }\n}\n\n/*\n *\tClrBottom(total)\n *\n *\tTest if clearing the end of the screen would satisfy part of the\n *\tscreen-update.  Do this by scanning backwards through the lines in the\n *\tscreen, checking if each is blank, and one or more are changed.\n */\nstatic int\nClrBottom(NCURSES_SP_DCLx int total)\n{\n    int top = total;\n    int last = min(screen_columns(SP_PARM), NewScreen(SP_PARM)->_maxx + 1);\n    NCURSES_CH_T blank = NewScreen(SP_PARM)->_line[total - 1].text[last - 1];\n\n    if (clr_eos && can_clear_with(NCURSES_SP_ARGx CHREF(blank))) {\n\tint row;\n\n\tfor (row = total - 1; row >= 0; row--) {\n\t    int col;\n\t    bool ok;\n\n\t    for (col = 0, ok = TRUE; ok && col < last; col++) {\n\t\tok = (CharEq(NewScreen(SP_PARM)->_line[row].text[col], blank));\n\t    }\n\t    if (!ok)\n\t\tbreak;\n\n\t    for (col = 0; ok && col < last; col++) {\n\t\tok = (CharEq(CurScreen(SP_PARM)->_line[row].text[col], blank));\n\t    }\n\t    if (!ok)\n\t\ttop = row;\n\t}\n\n\t/* don't use clr_eos for just one line if clr_eol available */\n\tif (top < total) {\n\t    GoTo(NCURSES_SP_ARGx top, 0);\n\t    ClrToEOS(NCURSES_SP_ARGx blank);\n\t    if (SP_PARM->oldhash && SP_PARM->newhash) {\n\t\tfor (row = top; row < screen_lines(SP_PARM); row++)\n\t\t    SP_PARM->oldhash[row] = SP_PARM->newhash[row];\n\t    }\n\t}\n    }\n    return top;\n}\n\n#if USE_XMC_SUPPORT\n#if USE_WIDEC_SUPPORT\n#define check_xmc_transition(sp, a, b)\t\t\t\t\t\\\n    ((((a)->attr ^ (b)->attr) & ~((a)->attr) & (sp)->_xmc_triggers) != 0)\n#define xmc_turn_on(sp,a,b) check_xmc_transition(sp,&(a), &(b))\n#else\n#define xmc_turn_on(sp,a,b) ((((a)^(b)) & ~(a) & (sp)->_xmc_triggers) != 0)\n#endif\n\n#define xmc_new(sp,r,c) NewScreen(sp)->_line[r].text[c]\n#define xmc_turn_off(sp,a,b) xmc_turn_on(sp,b,a)\n#endif /* USE_XMC_SUPPORT */\n\n/*\n**\tTransformLine(lineno)\n**\n**\tTransform the given line in curscr to the one in newscr, using\n**\tInsert/Delete Character if idcok && has_ic().\n**\n**\t\tfirstChar = position of first different character in line\n**\t\toLastChar = position of last different character in old line\n**\t\tnLastChar = position of last different character in new line\n**\n**\t\tmove to firstChar\n**\t\toverwrite chars up to min(oLastChar, nLastChar)\n**\t\tif oLastChar < nLastChar\n**\t\t\tinsert newLine[oLastChar+1..nLastChar]\n**\t\telse\n**\t\t\tdelete oLastChar - nLastChar spaces\n*/\n\nstatic void\nTransformLine(NCURSES_SP_DCLx int const lineno)\n{\n    int firstChar, oLastChar, nLastChar;\n    NCURSES_CH_T *newLine = NewScreen(SP_PARM)->_line[lineno].text;\n    NCURSES_CH_T *oldLine = CurScreen(SP_PARM)->_line[lineno].text;\n    int n;\n    bool attrchanged = FALSE;\n\n    TR(TRACE_UPDATE, (T_CALLED(\"TransformLine(%p, %d)\"), (void *) SP_PARM, lineno));\n\n    /* copy new hash value to old one */\n    if (SP_PARM->oldhash && SP_PARM->newhash)\n\tSP_PARM->oldhash[lineno] = SP_PARM->newhash[lineno];\n\n    /*\n     * If we have colors, there is the possibility of having two color pairs\n     * that display as the same colors.  For instance, Lynx does this.  Check\n     * for this case, and update the old line with the new line's colors when\n     * they are equivalent.\n     */\n    if (SP_PARM->_coloron) {\n\tint oldPair;\n\tint newPair;\n\n\tfor (n = 0; n < screen_columns(SP_PARM); n++) {\n\t    if (!CharEq(newLine[n], oldLine[n])) {\n\t\toldPair = GetPair(oldLine[n]);\n\t\tnewPair = GetPair(newLine[n]);\n\t\tif (oldPair != newPair\n\t\t    && unColor(oldLine[n]) == unColor(newLine[n])) {\n\t\t    if (oldPair < SP_PARM->_pair_limit\n\t\t\t&& newPair < SP_PARM->_pair_limit\n\t\t\t&& (isSamePair(SP_PARM->_color_pairs[oldPair],\n\t\t\t\t       SP_PARM->_color_pairs[newPair]))) {\n\t\t\tSetPair(oldLine[n], GetPair(newLine[n]));\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    if (ceol_standout_glitch && clr_eol) {\n\tfirstChar = 0;\n\twhile (firstChar < screen_columns(SP_PARM)) {\n\t    if (!SameAttrOf(newLine[firstChar], oldLine[firstChar])) {\n\t\tattrchanged = TRUE;\n\t\tbreak;\n\t    }\n\t    firstChar++;\n\t}\n    }\n\n    firstChar = 0;\n\n    if (attrchanged) {\t\t/* we may have to disregard the whole line */\n\tGoTo(NCURSES_SP_ARGx lineno, firstChar);\n\tClrToEOL(NCURSES_SP_ARGx\n\t\t ClrBlank(NCURSES_SP_ARGx\n\t\t\t  CurScreen(SP_PARM)), FALSE);\n\tPutRange(NCURSES_SP_ARGx\n\t\t oldLine, newLine, lineno, 0,\n\t\t screen_columns(SP_PARM) - 1);\n#if USE_XMC_SUPPORT\n\n\t/*\n\t * This is a very simple loop to paint characters which may have the\n\t * magic cookie glitch embedded.  It doesn't know much about video\n\t * attributes which are continued from one line to the next.  It\n\t * assumes that we have filtered out requests for attribute changes\n\t * that do not get mapped to blank positions.\n\t *\n\t * FIXME: we are not keeping track of where we put the cookies, so this\n\t * will work properly only once, since we may overwrite a cookie in a\n\t * following operation.\n\t */\n    } else if (magic_cookie_glitch > 0) {\n\tGoTo(NCURSES_SP_ARGx lineno, firstChar);\n\tfor (n = 0; n < screen_columns(SP_PARM); n++) {\n\t    int m = n + magic_cookie_glitch;\n\n\t    /* check for turn-on:\n\t     * If we are writing an attributed blank, where the\n\t     * previous cell is not attributed.\n\t     */\n\t    if (ISBLANK(newLine[n])\n\t\t&& ((n > 0\n\t\t     && xmc_turn_on(SP_PARM, newLine[n - 1], newLine[n]))\n\t\t    || (n == 0\n\t\t\t&& lineno > 0\n\t\t\t&& xmc_turn_on(SP_PARM,\n\t\t\t\t       xmc_new(SP_PARM, lineno - 1,\n\t\t\t\t\t       screen_columns(SP_PARM) - 1),\n\t\t\t\t       newLine[n])))) {\n\t\tn = m;\n\t    }\n\n\t    PutChar(NCURSES_SP_ARGx CHREF(newLine[n]));\n\n\t    /* check for turn-off:\n\t     * If we are writing an attributed non-blank, where the\n\t     * next cell is blank, and not attributed.\n\t     */\n\t    if (!ISBLANK(newLine[n])\n\t\t&& ((n + 1 < screen_columns(SP_PARM)\n\t\t     && xmc_turn_off(SP_PARM, newLine[n], newLine[n + 1]))\n\t\t    || (n + 1 >= screen_columns(SP_PARM)\n\t\t\t&& lineno + 1 < screen_lines(SP_PARM)\n\t\t\t&& xmc_turn_off(SP_PARM,\n\t\t\t\t\tnewLine[n],\n\t\t\t\t\txmc_new(SP_PARM, lineno + 1, 0))))) {\n\t\tn = m;\n\t    }\n\n\t}\n#endif\n    } else {\n\tNCURSES_CH_T blank;\n\n\t/* it may be cheap to clear leading whitespace with clr_bol */\n\tblank = newLine[0];\n\tif (clr_bol && can_clear_with(NCURSES_SP_ARGx CHREF(blank))) {\n\t    int oFirstChar, nFirstChar;\n\n\t    for (oFirstChar = 0;\n\t\t oFirstChar < screen_columns(SP_PARM);\n\t\t oFirstChar++)\n\t\tif (!CharEq(oldLine[oFirstChar], blank))\n\t\t    break;\n\t    for (nFirstChar = 0;\n\t\t nFirstChar < screen_columns(SP_PARM);\n\t\t nFirstChar++)\n\t\tif (!CharEq(newLine[nFirstChar], blank))\n\t\t    break;\n\n\t    if (nFirstChar == oFirstChar) {\n\t\tfirstChar = nFirstChar;\n\t\t/* find the first differing character */\n\t\twhile (firstChar < screen_columns(SP_PARM)\n\t\t       && CharEq(newLine[firstChar], oldLine[firstChar]))\n\t\t    firstChar++;\n\t    } else if (oFirstChar > nFirstChar) {\n\t\tfirstChar = nFirstChar;\n\t    } else {\t\t/* oFirstChar < nFirstChar */\n\t\tfirstChar = oFirstChar;\n\t\tif (SP_PARM->_el1_cost < nFirstChar - oFirstChar) {\n\t\t    if (nFirstChar >= screen_columns(SP_PARM)\n\t\t\t&& SP_PARM->_el_cost <= SP_PARM->_el1_cost) {\n\t\t\tGoTo(NCURSES_SP_ARGx lineno, 0);\n\t\t\tUpdateAttrs(SP_PARM, blank);\n\t\t\tNCURSES_PUTP2(\"clr_eol\", clr_eol);\n\t\t    } else {\n\t\t\tGoTo(NCURSES_SP_ARGx lineno, nFirstChar - 1);\n\t\t\tUpdateAttrs(SP_PARM, blank);\n\t\t\tNCURSES_PUTP2(\"clr_bol\", clr_bol);\n\t\t    }\n\n\t\t    while (firstChar < nFirstChar)\n\t\t\toldLine[firstChar++] = blank;\n\t\t}\n\t    }\n\t} else {\n\t    /* find the first differing character */\n\t    while (firstChar < screen_columns(SP_PARM)\n\t\t   && CharEq(newLine[firstChar], oldLine[firstChar]))\n\t\tfirstChar++;\n\t}\n\t/* if there wasn't one, we're done */\n\tif (firstChar >= screen_columns(SP_PARM)) {\n\t    TR(TRACE_UPDATE, (T_RETURN(\"\")));\n\t    return;\n\t}\n\n\tblank = newLine[screen_columns(SP_PARM) - 1];\n\n\tif (!can_clear_with(NCURSES_SP_ARGx CHREF(blank))) {\n\t    /* find the last differing character */\n\t    nLastChar = screen_columns(SP_PARM) - 1;\n\n\t    while (nLastChar > firstChar\n\t\t   && CharEq(newLine[nLastChar], oldLine[nLastChar]))\n\t\tnLastChar--;\n\n\t    if (nLastChar >= firstChar) {\n\t\tGoTo(NCURSES_SP_ARGx lineno, firstChar);\n\t\tPutRange(NCURSES_SP_ARGx\n\t\t\t oldLine,\n\t\t\t newLine,\n\t\t\t lineno,\n\t\t\t firstChar,\n\t\t\t nLastChar);\n\t\tmemcpy(oldLine + firstChar,\n\t\t       newLine + firstChar,\n\t\t       (unsigned) (nLastChar - firstChar + 1) * sizeof(NCURSES_CH_T));\n\t    }\n\t    TR(TRACE_UPDATE, (T_RETURN(\"\")));\n\t    return;\n\t}\n\n\t/* find last non-blank character on old line */\n\toLastChar = screen_columns(SP_PARM) - 1;\n\twhile (oLastChar > firstChar && CharEq(oldLine[oLastChar], blank))\n\t    oLastChar--;\n\n\t/* find last non-blank character on new line */\n\tnLastChar = screen_columns(SP_PARM) - 1;\n\twhile (nLastChar > firstChar && CharEq(newLine[nLastChar], blank))\n\t    nLastChar--;\n\n\tif ((nLastChar == firstChar)\n\t    && (SP_PARM->_el_cost < (oLastChar - nLastChar))) {\n\t    GoTo(NCURSES_SP_ARGx lineno, firstChar);\n\t    if (!CharEq(newLine[firstChar], blank))\n\t\tPutChar(NCURSES_SP_ARGx CHREF(newLine[firstChar]));\n\t    ClrToEOL(NCURSES_SP_ARGx blank, FALSE);\n\t} else if ((nLastChar != oLastChar)\n\t\t   && (!CharEq(newLine[nLastChar], oldLine[oLastChar])\n\t\t       || !(SP_PARM->_nc_sp_idcok\n\t\t\t    && NCURSES_SP_NAME(has_ic) (NCURSES_SP_ARG)))) {\n\t    GoTo(NCURSES_SP_ARGx lineno, firstChar);\n\t    if ((oLastChar - nLastChar) > SP_PARM->_el_cost) {\n\t\tif (PutRange(NCURSES_SP_ARGx\n\t\t\t     oldLine,\n\t\t\t     newLine,\n\t\t\t     lineno,\n\t\t\t     firstChar,\n\t\t\t     nLastChar)) {\n\t\t    GoTo(NCURSES_SP_ARGx lineno, nLastChar + 1);\n\t\t}\n\t\tClrToEOL(NCURSES_SP_ARGx blank, FALSE);\n\t    } else {\n\t\tn = max(nLastChar, oLastChar);\n\t\tPutRange(NCURSES_SP_ARGx\n\t\t\t oldLine,\n\t\t\t newLine,\n\t\t\t lineno,\n\t\t\t firstChar,\n\t\t\t n);\n\t    }\n\t} else {\n\t    int nLastNonblank = nLastChar;\n\t    int oLastNonblank = oLastChar;\n\n\t    /* find the last characters that really differ */\n\t    /* can be -1 if no characters differ */\n\t    while (CharEq(newLine[nLastChar], oldLine[oLastChar])) {\n\t\t/* don't split a wide char */\n\t\tif (isWidecExt(newLine[nLastChar]) &&\n\t\t    !CharEq(newLine[nLastChar - 1], oldLine[oLastChar - 1]))\n\t\t    break;\n\t\tnLastChar--;\n\t\toLastChar--;\n\t\tif (nLastChar == -1 || oLastChar == -1)\n\t\t    break;\n\t    }\n\n\t    n = min(oLastChar, nLastChar);\n\t    if (n >= firstChar) {\n\t\tGoTo(NCURSES_SP_ARGx lineno, firstChar);\n\t\tPutRange(NCURSES_SP_ARGx\n\t\t\t oldLine,\n\t\t\t newLine,\n\t\t\t lineno,\n\t\t\t firstChar,\n\t\t\t n);\n\t    }\n\n\t    if (oLastChar < nLastChar) {\n\t\tint m = max(nLastNonblank, oLastNonblank);\n#if USE_WIDEC_SUPPORT\n\t\tif (n) {\n\t\t    while (isWidecExt(newLine[n + 1]) && n) {\n\t\t\t--n;\n\t\t\t--oLastChar;\t/* increase cost */\n\t\t    }\n\t\t} else if (n >= firstChar &&\n\t\t\t   isWidecBase(newLine[n])) {\n\t\t    while (isWidecExt(newLine[n + 1])) {\n\t\t\t++n;\n\t\t\t++oLastChar;\t/* decrease cost */\n\t\t    }\n\t\t}\n#endif\n\t\tGoTo(NCURSES_SP_ARGx lineno, n + 1);\n\t\tif ((nLastChar < nLastNonblank)\n\t\t    || InsCharCost(SP_PARM, nLastChar - oLastChar) > (m - n)) {\n\t\t    PutRange(NCURSES_SP_ARGx\n\t\t\t     oldLine,\n\t\t\t     newLine,\n\t\t\t     lineno,\n\t\t\t     n + 1,\n\t\t\t     m);\n\t\t} else {\n\t\t    InsStr(NCURSES_SP_ARGx &newLine[n + 1], nLastChar - oLastChar);\n\t\t}\n\t    } else if (oLastChar > nLastChar) {\n\t\tGoTo(NCURSES_SP_ARGx lineno, n + 1);\n\t\tif (DelCharCost(SP_PARM, oLastChar - nLastChar)\n\t\t    > SP_PARM->_el_cost + nLastNonblank - (n + 1)) {\n\t\t    if (PutRange(NCURSES_SP_ARGx oldLine, newLine, lineno,\n\t\t\t\t n + 1, nLastNonblank)) {\n\t\t\tGoTo(NCURSES_SP_ARGx lineno, nLastNonblank + 1);\n\t\t    }\n\t\t    ClrToEOL(NCURSES_SP_ARGx blank, FALSE);\n\t\t} else {\n\t\t    /*\n\t\t     * The delete-char sequence will\n\t\t     * effectively shift in blanks from the\n\t\t     * right margin of the screen.  Ensure\n\t\t     * that they are the right color by\n\t\t     * setting the video attributes from\n\t\t     * the last character on the row.\n\t\t     */\n\t\t    UpdateAttrs(SP_PARM, blank);\n\t\t    DelChar(NCURSES_SP_ARGx oLastChar - nLastChar);\n\t\t}\n\t    }\n\t}\n    }\n\n    /* update the code's internal representation */\n    if (screen_columns(SP_PARM) > firstChar)\n\tmemcpy(oldLine + firstChar,\n\t       newLine + firstChar,\n\t       (unsigned) (screen_columns(SP_PARM) - firstChar) * sizeof(NCURSES_CH_T));\n    TR(TRACE_UPDATE, (T_RETURN(\"\")));\n    return;\n}\n\n/*\n**\tClearScreen(blank)\n**\n**\tClear the physical screen and put cursor at home\n**\n*/\n\nstatic void\nClearScreen(NCURSES_SP_DCLx NCURSES_CH_T blank)\n{\n    int i, j;\n    bool fast_clear = (clear_screen || clr_eos || clr_eol);\n\n    TR(TRACE_UPDATE, (\"ClearScreen() called\"));\n\n#if NCURSES_EXT_FUNCS\n    if (SP_PARM->_coloron\n\t&& !SP_PARM->_default_color) {\n\tNCURSES_SP_NAME(_nc_do_color) (NCURSES_SP_ARGx\n\t\t\t\t       (short) GET_SCREEN_PAIR(SP_PARM),\n\t\t\t\t       0,\n\t\t\t\t       FALSE,\n\t\t\t\t       NCURSES_SP_NAME(_nc_outch));\n\tif (!back_color_erase) {\n\t    fast_clear = FALSE;\n\t}\n    }\n#endif\n\n    if (fast_clear) {\n\tif (clear_screen) {\n\t    UpdateAttrs(SP_PARM, blank);\n\t    NCURSES_PUTP2(\"clear_screen\", clear_screen);\n\t    SP_PARM->_cursrow = SP_PARM->_curscol = 0;\n\t    position_check(NCURSES_SP_ARGx\n\t\t\t   SP_PARM->_cursrow,\n\t\t\t   SP_PARM->_curscol,\n\t\t\t   \"ClearScreen\");\n\t} else if (clr_eos) {\n\t    SP_PARM->_cursrow = SP_PARM->_curscol = -1;\n\t    GoTo(NCURSES_SP_ARGx 0, 0);\n\t    UpdateAttrs(SP_PARM, blank);\n\t    TPUTS_TRACE(\"clr_eos\");\n\t    NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t    clr_eos,\n\t\t\t\t    screen_lines(SP_PARM),\n\t\t\t\t    NCURSES_SP_NAME(_nc_outch));\n\t} else if (clr_eol) {\n\t    SP_PARM->_cursrow = SP_PARM->_curscol = -1;\n\t    UpdateAttrs(SP_PARM, blank);\n\t    for (i = 0; i < screen_lines(SP_PARM); i++) {\n\t\tGoTo(NCURSES_SP_ARGx i, 0);\n\t\tNCURSES_PUTP2(\"clr_eol\", clr_eol);\n\t    }\n\t    GoTo(NCURSES_SP_ARGx 0, 0);\n\t}\n    } else {\n\tUpdateAttrs(SP_PARM, blank);\n\tfor (i = 0; i < screen_lines(SP_PARM); i++) {\n\t    GoTo(NCURSES_SP_ARGx i, 0);\n\t    for (j = 0; j < screen_columns(SP_PARM); j++)\n\t\tPutChar(NCURSES_SP_ARGx CHREF(blank));\n\t}\n\tGoTo(NCURSES_SP_ARGx 0, 0);\n    }\n\n    for (i = 0; i < screen_lines(SP_PARM); i++) {\n\tfor (j = 0; j < screen_columns(SP_PARM); j++)\n\t    CurScreen(SP_PARM)->_line[i].text[j] = blank;\n    }\n\n    TR(TRACE_UPDATE, (\"screen cleared\"));\n}\n\n/*\n**\tInsStr(line, count)\n**\n**\tInsert the count characters pointed to by line.\n**\n*/\n\nstatic void\nInsStr(NCURSES_SP_DCLx NCURSES_CH_T * line, int count)\n{\n    TR(TRACE_UPDATE, (\"InsStr(%p, %p,%d) called\",\n\t\t      (void *) SP_PARM,\n\t\t      (void *) line, count));\n\n    /* Prefer parm_ich as it has the smallest cost - no need to shift\n     * the whole line on each character. */\n    /* The order must match that of InsCharCost. */\n    if (parm_ich) {\n\tTPUTS_TRACE(\"parm_ich\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_1(parm_ich, count),\n\t\t\t\t1,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n\twhile (count > 0) {\n\t    PutAttrChar(NCURSES_SP_ARGx CHREF(*line));\n\t    line++;\n\t    count--;\n\t}\n    } else if (enter_insert_mode && exit_insert_mode) {\n\tNCURSES_PUTP2(\"enter_insert_mode\", enter_insert_mode);\n\twhile (count > 0) {\n\t    PutAttrChar(NCURSES_SP_ARGx CHREF(*line));\n\t    if (insert_padding) {\n\t\tNCURSES_PUTP2(\"insert_padding\", insert_padding);\n\t    }\n\t    line++;\n\t    count--;\n\t}\n\tNCURSES_PUTP2(\"exit_insert_mode\", exit_insert_mode);\n    } else {\n\twhile (count > 0) {\n\t    NCURSES_PUTP2(\"insert_character\", insert_character);\n\t    PutAttrChar(NCURSES_SP_ARGx CHREF(*line));\n\t    if (insert_padding) {\n\t\tNCURSES_PUTP2(\"insert_padding\", insert_padding);\n\t    }\n\t    line++;\n\t    count--;\n\t}\n    }\n    position_check(NCURSES_SP_ARGx\n\t\t   SP_PARM->_cursrow,\n\t\t   SP_PARM->_curscol, \"InsStr\");\n}\n\n/*\n**\tDelChar(count)\n**\n**\tDelete count characters at current position\n**\n*/\n\nstatic void\nDelChar(NCURSES_SP_DCLx int count)\n{\n    TR(TRACE_UPDATE, (\"DelChar(%p, %d) called, position = (%ld,%ld)\",\n\t\t      (void *) SP_PARM, count,\n\t\t      (long) NewScreen(SP_PARM)->_cury,\n\t\t      (long) NewScreen(SP_PARM)->_curx));\n\n    if (parm_dch) {\n\tTPUTS_TRACE(\"parm_dch\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_1(parm_dch, count),\n\t\t\t\t1,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else {\n\tint n;\n\n\tfor (n = 0; n < count; n++) {\n\t    NCURSES_PUTP2(\"delete_character\", delete_character);\n\t}\n    }\n}\n\n/*\n * Physical-scrolling support\n *\n * This code was adapted from Keith Bostic's hardware scrolling\n * support for 4.4BSD curses.  I (esr) translated it to use terminfo\n * capabilities, narrowed the call interface slightly, and cleaned\n * up some convoluted tests.  I also added support for the memory_above\n * memory_below, and non_dest_scroll_region capabilities.\n *\n * For this code to work, we must have either\n * change_scroll_region and scroll forward/reverse commands, or\n * insert and delete line capabilities.\n * When the scrolling region has been set, the cursor has to\n * be at the last line of the region to make the scroll up\n * happen, or on the first line of region to scroll down.\n *\n * This code makes one aesthetic decision in the opposite way from\n * BSD curses.  BSD curses preferred pairs of il/dl operations\n * over scrolls, allegedly because il/dl looked faster.  We, on\n * the other hand, prefer scrolls because (a) they're just as fast\n * on many terminals and (b) using them avoids bouncing an\n * unchanged bottom section of the screen up and down, which is\n * visually nasty.\n *\n * (lav): added more cases, used dl/il when bot==maxy and in csr case.\n *\n * I used assumption that capabilities il/il1/dl/dl1 work inside\n * changed scroll region not shifting screen contents outside of it.\n * If there are any terminals behaving different way, it would be\n * necessary to add some conditions to scroll_csr_forward/backward.\n */\n\n/* Try to scroll up assuming given csr (miny, maxy). Returns ERR on failure */\nstatic int\nscroll_csr_forward(NCURSES_SP_DCLx\n\t\t   int n,\n\t\t   int top,\n\t\t   int bot,\n\t\t   int miny,\n\t\t   int maxy,\n\t\t   NCURSES_CH_T blank)\n{\n    int i;\n\n    if (n == 1 && scroll_forward && top == miny && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx bot, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tNCURSES_PUTP2(\"scroll_forward\", scroll_forward);\n    } else if (n == 1 && delete_line && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tNCURSES_PUTP2(\"delete_line\", delete_line);\n    } else if (parm_index && top == miny && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx bot, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tTPUTS_TRACE(\"parm_index\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_2(parm_index, n, 0),\n\t\t\t\tn,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else if (parm_delete_line && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tTPUTS_TRACE(\"parm_delete_line\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_2(parm_delete_line, n, 0),\n\t\t\t\tn,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else if (scroll_forward && top == miny && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx bot, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tfor (i = 0; i < n; i++) {\n\t    NCURSES_PUTP2(\"scroll_forward\", scroll_forward);\n\t}\n    } else if (delete_line && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tfor (i = 0; i < n; i++) {\n\t    NCURSES_PUTP2(\"delete_line\", delete_line);\n\t}\n    } else\n\treturn ERR;\n\n#if NCURSES_EXT_FUNCS\n    if (FILL_BCE(SP_PARM)) {\n\tint j;\n\tfor (i = 0; i < n; i++) {\n\t    GoTo(NCURSES_SP_ARGx bot - i, 0);\n\t    for (j = 0; j < screen_columns(SP_PARM); j++)\n\t\tPutChar(NCURSES_SP_ARGx CHREF(blank));\n\t}\n    }\n#endif\n    return OK;\n}\n\n/* Try to scroll down assuming given csr (miny, maxy). Returns ERR on failure */\n/* n > 0 */\nstatic int\nscroll_csr_backward(NCURSES_SP_DCLx\n\t\t    int n,\n\t\t    int top,\n\t\t    int bot,\n\t\t    int miny,\n\t\t    int maxy,\n\t\t    NCURSES_CH_T blank)\n{\n    int i;\n\n    if (n == 1 && scroll_reverse && top == miny && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tNCURSES_PUTP2(\"scroll_reverse\", scroll_reverse);\n    } else if (n == 1 && insert_line && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tNCURSES_PUTP2(\"insert_line\", insert_line);\n    } else if (parm_rindex && top == miny && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tTPUTS_TRACE(\"parm_rindex\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_2(parm_rindex, n, 0),\n\t\t\t\tn,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else if (parm_insert_line && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tTPUTS_TRACE(\"parm_insert_line\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_2(parm_insert_line, n, 0),\n\t\t\t\tn,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else if (scroll_reverse && top == miny && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tfor (i = 0; i < n; i++) {\n\t    NCURSES_PUTP2(\"scroll_reverse\", scroll_reverse);\n\t}\n    } else if (insert_line && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tfor (i = 0; i < n; i++) {\n\t    NCURSES_PUTP2(\"insert_line\", insert_line);\n\t}\n    } else\n\treturn ERR;\n\n#if NCURSES_EXT_FUNCS\n    if (FILL_BCE(SP_PARM)) {\n\tint j;\n\tfor (i = 0; i < n; i++) {\n\t    GoTo(NCURSES_SP_ARGx top + i, 0);\n\t    for (j = 0; j < screen_columns(SP_PARM); j++)\n\t\tPutChar(NCURSES_SP_ARGx CHREF(blank));\n\t}\n    }\n#endif\n    return OK;\n}\n\n/* scroll by using delete_line at del and insert_line at ins */\n/* n > 0 */\nstatic int\nscroll_idl(NCURSES_SP_DCLx int n, int del, int ins, NCURSES_CH_T blank)\n{\n    int i;\n\n    if (!((parm_delete_line || delete_line) && (parm_insert_line || insert_line)))\n\treturn ERR;\n\n    GoTo(NCURSES_SP_ARGx del, 0);\n    UpdateAttrs(SP_PARM, blank);\n    if (n == 1 && delete_line) {\n\tNCURSES_PUTP2(\"delete_line\", delete_line);\n    } else if (parm_delete_line) {\n\tTPUTS_TRACE(\"parm_delete_line\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_2(parm_delete_line, n, 0),\n\t\t\t\tn,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else {\t\t\t/* if (delete_line) */\n\tfor (i = 0; i < n; i++) {\n\t    NCURSES_PUTP2(\"delete_line\", delete_line);\n\t}\n    }\n\n    GoTo(NCURSES_SP_ARGx ins, 0);\n    UpdateAttrs(SP_PARM, blank);\n    if (n == 1 && insert_line) {\n\tNCURSES_PUTP2(\"insert_line\", insert_line);\n    } else if (parm_insert_line) {\n\tTPUTS_TRACE(\"parm_insert_line\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_2(parm_insert_line, n, 0),\n\t\t\t\tn,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else {\t\t\t/* if (insert_line) */\n\tfor (i = 0; i < n; i++) {\n\t    NCURSES_PUTP2(\"insert_line\", insert_line);\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Note:  some terminals require the cursor to be within the scrolling margins\n * before setting them.  Generally, the cursor must be at the appropriate end\n * of the scrolling margins when issuing an indexing operation (it is not\n * apparent whether it must also be at the left margin; we do this just to be\n * safe).  To make the related cursor movement a little faster, we use the\n * save/restore cursor capabilities if the terminal has them.\n */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_scrolln) (NCURSES_SP_DCLx\n\t\t\t      int n,\n\t\t\t      int top,\n\t\t\t      int bot,\n\t\t\t      int maxy)\n/* scroll region from top to bot by n lines */\n{\n    NCURSES_CH_T blank;\n    int i;\n    bool cursor_saved = FALSE;\n    int res;\n\n    TR(TRACE_MOVE, (\"_nc_scrolln(%p, %d, %d, %d, %d)\",\n\t\t    (void *) SP_PARM, n, top, bot, maxy));\n\n    if (!IsValidScreen(SP_PARM))\n\treturn (ERR);\n\n    blank = ClrBlank(NCURSES_SP_ARGx StdScreen(SP_PARM));\n\n#if USE_XMC_SUPPORT\n    /*\n     * If we scroll, we might remove a cookie.\n     */\n    if (magic_cookie_glitch > 0) {\n\treturn (ERR);\n    }\n#endif\n\n    if (n > 0) {\t\t/* scroll up (forward) */\n\t/*\n\t * Explicitly clear if stuff pushed off top of region might\n\t * be saved by the terminal.\n\t */\n\tres = scroll_csr_forward(NCURSES_SP_ARGx n, top, bot, 0, maxy, blank);\n\n\tif (res == ERR && change_scroll_region) {\n\t    if ((((n == 1 && scroll_forward) || parm_index)\n\t\t && (SP_PARM->_cursrow == bot || SP_PARM->_cursrow == bot - 1))\n\t\t&& save_cursor && restore_cursor) {\n\t\tcursor_saved = TRUE;\n\t\tNCURSES_PUTP2(\"save_cursor\", save_cursor);\n\t    }\n\t    NCURSES_PUTP2(\"change_scroll_region\",\n\t\t\t  TPARM_2(change_scroll_region, top, bot));\n\t    if (cursor_saved) {\n\t\tNCURSES_PUTP2(\"restore_cursor\", restore_cursor);\n\t    } else {\n\t\tSP_PARM->_cursrow = SP_PARM->_curscol = -1;\n\t    }\n\n\t    res = scroll_csr_forward(NCURSES_SP_ARGx n, top, bot, top, bot, blank);\n\n\t    NCURSES_PUTP2(\"change_scroll_region\",\n\t\t\t  TPARM_2(change_scroll_region, 0, maxy));\n\t    SP_PARM->_cursrow = SP_PARM->_curscol = -1;\n\t}\n\n\tif (res == ERR && SP_PARM->_nc_sp_idlok)\n\t    res = scroll_idl(NCURSES_SP_ARGx n, top, bot - n + 1, blank);\n\n\t/*\n\t * Clear the newly shifted-in text.\n\t */\n\tif (res != ERR\n\t    && (non_dest_scroll_region || (memory_below && bot == maxy))) {\n\t    static const NCURSES_CH_T blank2 = NewChar(BLANK_TEXT);\n\t    if (bot == maxy && clr_eos) {\n\t\tGoTo(NCURSES_SP_ARGx bot - n + 1, 0);\n\t\tClrToEOS(NCURSES_SP_ARGx blank2);\n\t    } else {\n\t\tfor (i = 0; i < n; i++) {\n\t\t    GoTo(NCURSES_SP_ARGx bot - i, 0);\n\t\t    ClrToEOL(NCURSES_SP_ARGx blank2, FALSE);\n\t\t}\n\t    }\n\t}\n\n    } else {\t\t\t/* (n < 0) - scroll down (backward) */\n\tres = scroll_csr_backward(NCURSES_SP_ARGx -n, top, bot, 0, maxy, blank);\n\n\tif (res == ERR && change_scroll_region) {\n\t    if (top != 0\n\t\t&& (SP_PARM->_cursrow == top ||\n\t\t    SP_PARM->_cursrow == top - 1)\n\t\t&& save_cursor && restore_cursor) {\n\t\tcursor_saved = TRUE;\n\t\tNCURSES_PUTP2(\"save_cursor\", save_cursor);\n\t    }\n\t    NCURSES_PUTP2(\"change_scroll_region\",\n\t\t\t  TPARM_2(change_scroll_region, top, bot));\n\t    if (cursor_saved) {\n\t\tNCURSES_PUTP2(\"restore_cursor\", restore_cursor);\n\t    } else {\n\t\tSP_PARM->_cursrow = SP_PARM->_curscol = -1;\n\t    }\n\n\t    res = scroll_csr_backward(NCURSES_SP_ARGx\n\t\t\t\t      -n, top, bot, top, bot, blank);\n\n\t    NCURSES_PUTP2(\"change_scroll_region\",\n\t\t\t  TPARM_2(change_scroll_region, 0, maxy));\n\t    SP_PARM->_cursrow = SP_PARM->_curscol = -1;\n\t}\n\n\tif (res == ERR && SP_PARM->_nc_sp_idlok)\n\t    res = scroll_idl(NCURSES_SP_ARGx -n, bot + n + 1, top, blank);\n\n\t/*\n\t * Clear the newly shifted-in text.\n\t */\n\tif (res != ERR\n\t    && (non_dest_scroll_region || (memory_above && top == 0))) {\n\t    static const NCURSES_CH_T blank2 = NewChar(BLANK_TEXT);\n\t    for (i = 0; i < -n; i++) {\n\t\tGoTo(NCURSES_SP_ARGx i + top, 0);\n\t\tClrToEOL(NCURSES_SP_ARGx blank2, FALSE);\n\t    }\n\t}\n    }\n\n    if (res == ERR)\n\treturn (ERR);\n\n    _nc_scroll_window(CurScreen(SP_PARM), n,\n\t\t      (NCURSES_SIZE_T) top,\n\t\t      (NCURSES_SIZE_T) bot,\n\t\t      blank);\n\n    /* shift hash values too - they can be reused */\n    NCURSES_SP_NAME(_nc_scroll_oldhash) (NCURSES_SP_ARGx n, top, bot);\n\n    return (OK);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_scrolln(int n, int top, int bot, int maxy)\n{\n    return NCURSES_SP_NAME(_nc_scrolln) (CURRENT_SCREEN, n, top, bot, maxy);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_screen_resume) (NCURSES_SP_DCL0)\n{\n    assert(SP_PARM);\n\n    /* make sure terminal is in a sane known state */\n    SetAttr(SCREEN_ATTRS(SP_PARM), A_NORMAL);\n    NewScreen(SP_PARM)->_clear = TRUE;\n\n    /* reset color pairs and definitions */\n    if (SP_PARM->_coloron || SP_PARM->_color_defs)\n\tNCURSES_SP_NAME(_nc_reset_colors) (NCURSES_SP_ARG);\n\n    /* restore user-defined colors, if any */\n    if (SP_PARM->_color_defs < 0 && !SP_PARM->_direct_color.value) {\n\tint n;\n\tSP_PARM->_color_defs = -(SP_PARM->_color_defs);\n\tfor (n = 0; n < SP_PARM->_color_defs; ++n) {\n\t    if (SP_PARM->_color_table[n].init) {\n\t\t_nc_init_color(SP_PARM,\n\t\t\t       n,\n\t\t\t       SP_PARM->_color_table[n].r,\n\t\t\t       SP_PARM->_color_table[n].g,\n\t\t\t       SP_PARM->_color_table[n].b);\n\t    }\n\t}\n    }\n\n    if (exit_attribute_mode)\n\tNCURSES_PUTP2(\"exit_attribute_mode\", exit_attribute_mode);\n    else {\n\t/* turn off attributes */\n\tif (exit_alt_charset_mode)\n\t    NCURSES_PUTP2(\"exit_alt_charset_mode\", exit_alt_charset_mode);\n\tif (exit_standout_mode)\n\t    NCURSES_PUTP2(\"exit_standout_mode\", exit_standout_mode);\n\tif (exit_underline_mode)\n\t    NCURSES_PUTP2(\"exit_underline_mode\", exit_underline_mode);\n    }\n    if (exit_insert_mode)\n\tNCURSES_PUTP2(\"exit_insert_mode\", exit_insert_mode);\n    if (enter_am_mode && exit_am_mode) {\n\tif (auto_right_margin) {\n\t    NCURSES_PUTP2(\"enter_am_mode\", enter_am_mode);\n\t} else {\n\t    NCURSES_PUTP2(\"exit_am_mode\", exit_am_mode);\n\t}\n    }\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_screen_resume(void)\n{\n    NCURSES_SP_NAME(_nc_screen_resume) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_screen_init) (NCURSES_SP_DCL0)\n{\n    NCURSES_SP_NAME(_nc_screen_resume) (NCURSES_SP_ARG);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_screen_init(void)\n{\n    NCURSES_SP_NAME(_nc_screen_init) (CURRENT_SCREEN);\n}\n#endif\n\n/* wrap up screen handling */\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_screen_wrap) (NCURSES_SP_DCL0)\n{\n    if (SP_PARM != 0) {\n\n\tUpdateAttrs(SP_PARM, normal);\n#if NCURSES_EXT_FUNCS\n\tif (SP_PARM->_coloron\n\t    && !SP_PARM->_default_color) {\n\t    static const NCURSES_CH_T blank = NewChar(BLANK_TEXT);\n\t    SP_PARM->_default_color = TRUE;\n\t    NCURSES_SP_NAME(_nc_do_color) (NCURSES_SP_ARGx\n\t\t\t\t\t   -1,\n\t\t\t\t\t   0,\n\t\t\t\t\t   FALSE,\n\t\t\t\t\t   NCURSES_SP_NAME(_nc_outch));\n\t    SP_PARM->_default_color = FALSE;\n\n\t    TINFO_MVCUR(NCURSES_SP_ARGx\n\t\t\tSP_PARM->_cursrow,\n\t\t\tSP_PARM->_curscol,\n\t\t\tscreen_lines(SP_PARM) - 1,\n\t\t\t0);\n\n\t    ClrToEOL(NCURSES_SP_ARGx blank, TRUE);\n\t}\n#endif\n\tif (SP_PARM->_color_defs) {\n\t    NCURSES_SP_NAME(_nc_reset_colors) (NCURSES_SP_ARG);\n\t}\n    }\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_screen_wrap(void)\n{\n    NCURSES_SP_NAME(_nc_screen_wrap) (CURRENT_SCREEN);\n}\n#endif\n\n#if USE_XMC_SUPPORT\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_do_xmc_glitch) (NCURSES_SP_DCLx attr_t previous)\n{\n    if (SP_PARM != 0) {\n\tattr_t chg = XMC_CHANGES(previous ^ AttrOf(SCREEN_ATTRS(SP_PARM)));\n\n\twhile (chg != 0) {\n\t    if (chg & 1) {\n\t\tSP_PARM->_curscol += magic_cookie_glitch;\n\t\tif (SP_PARM->_curscol >= SP_PARM->_columns)\n\t\t    wrap_cursor(NCURSES_SP_ARG);\n\t\tTR(TRACE_UPDATE, (\"bumped to %d,%d after cookie\",\n\t\t\t\t  SP_PARM->_cursrow, SP_PARM->_curscol));\n\t    }\n\t    chg >>= 1;\n\t}\n    }\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_do_xmc_glitch(attr_t previous)\n{\n    NCURSES_SP_NAME(_nc_do_xmc_glitch) (CURRENT_SCREEN, previous);\n}\n#endif\n\n#endif /* USE_XMC_SUPPORT */\n","/****************************************************************************\n * Copyright (c) 1998-2014,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey          1998-on                               *\n *          Juergen Pfeifer           2009                                  *\n ****************************************************************************/\n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_dft_fgbg.c,v 1.29 2017/03/25 21:00:49 tom Exp $\")\n\n/*\n * Modify the behavior of color-pair 0 so that the library doesn't assume that\n * it is white on black.  This is an extension to XSI curses.\n */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(use_default_colors) (NCURSES_SP_DCL0)\n{\n    T((T_CALLED(\"use_default_colors(%p)\"), (void *) SP_PARM));\n    returnCode(NCURSES_SP_NAME(assume_default_colors) (NCURSES_SP_ARGx -1, -1));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nuse_default_colors(void)\n{\n    return NCURSES_SP_NAME(use_default_colors) (CURRENT_SCREEN);\n}\n#endif\n\n/*\n * Modify the behavior of color-pair 0 so that the library assumes that it\n * is something specific, possibly not white on black.\n */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(assume_default_colors) (NCURSES_SP_DCLx int fg, int bg)\n{\n    int code = ERR;\n\n    T((T_CALLED(\"assume_default_colors(%p,%d,%d)\"), (void *) SP_PARM, fg, bg));\n    if (SP_PARM != 0) {\n#ifdef USE_TERM_DRIVER\n\tcode = CallDriver_2(SP_PARM, td_defaultcolors, fg, bg);\n#else\n\tif ((orig_pair || orig_colors) && !initialize_pair) {\n\n\t    SP_PARM->_default_color = isDefaultColor(fg) || isDefaultColor(bg);\n\t    SP_PARM->_has_sgr_39_49 = (tigetflag(\"AX\") == TRUE);\n\t    SP_PARM->_default_fg = isDefaultColor(fg) ? COLOR_DEFAULT : fg;\n\t    SP_PARM->_default_bg = isDefaultColor(bg) ? COLOR_DEFAULT : bg;\n\t    if (SP_PARM->_color_pairs != 0) {\n\t\tbool save = SP_PARM->_default_color;\n\t\tSP_PARM->_assumed_color = TRUE;\n\t\tSP_PARM->_default_color = TRUE;\n\t\tinit_pair(0, (short) fg, (short) bg);\n\t\tSP_PARM->_default_color = save;\n\t    }\n\t    code = OK;\n\t}\n#endif\n    }\n    returnCode(code);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nassume_default_colors(int fg, int bg)\n{\n    return NCURSES_SP_NAME(assume_default_colors) (CURRENT_SCREEN, fg, bg);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2015,2016 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey                                                *\n *     and: Juergen Pfeifer                                                 *\n ****************************************************************************/\n\n/*\n * This is an extension to the curses library.  It provides callers with a hook\n * into the NCURSES data to resize windows, primarily for use by programs\n * running in an X Window terminal (e.g., xterm).  I abstracted this module\n * from my application library for NCURSES because it must be compiled with\n * the private data structures -- T.Dickey 1995/7/4.\n */\n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: resizeterm.c,v 1.49 2016/05/28 23:11:26 tom Exp $\")\n\n/*\n * If we're trying to be reentrant, do not want any local statics.\n */\n#if USE_REENTRANT\n#define EXTRA_ARGS ,     CurLines,     CurCols\n#define EXTRA_DCLS , int CurLines, int CurCols\n#else\nstatic int current_lines;\nstatic int current_cols;\n#define CurLines current_lines\n#define CurCols  current_cols\n#define EXTRA_ARGS\t\t/* nothing */\n#define EXTRA_DCLS\t\t/* nothing */\n#endif\n\n#if NCURSES_SP_FUNCS && !defined(USE_SP_WINDOWLIST)\n#define UNUSED_SP  (void) sp\n#else\n#define UNUSED_SP\t\t/* nothing */\n#endif\n\n#ifdef TRACE\nstatic void\nshow_window_sizes(const char *name)\n{\n    SCREEN *sp;\n    WINDOWLIST *wp;\n\n    _nc_lock_global(curses);\n    for (each_screen(sp)) {\n\t_tracef(\"%s resizing: %p: %2d x %2d (%2d x %2d)\", name, (void *) sp,\n\t\t*(ptrLines(sp)),\n\t\t*(ptrCols(sp)),\n\t\tscreen_lines(sp), screen_columns(sp));\n\tfor (each_window(sp, wp)) {\n\t    _tracef(\"  window %p is %2ld x %2ld at %2ld,%2ld\",\n\t\t    (void *) &(wp->win),\n\t\t    (long) wp->win._maxy + 1,\n\t\t    (long) wp->win._maxx + 1,\n\t\t    (long) wp->win._begy,\n\t\t    (long) wp->win._begx);\n\t}\n    }\n    _nc_unlock_global(curses);\n}\n#endif\n\n/*\n * Return true if the given dimensions do not match the internal terminal\n * structure's size.\n */\nNCURSES_EXPORT(bool)\nNCURSES_SP_NAME(is_term_resized) (NCURSES_SP_DCLx int ToLines, int ToCols)\n{\n    T((T_CALLED(\"is_term_resized(%p, %d, %d)\"), (void *) SP_PARM, ToLines, ToCols));\n    returnCode(ToLines > 0\n\t       && ToCols > 0\n\t       && (ToLines != screen_lines(SP_PARM)\n\t\t   || ToCols != screen_columns(SP_PARM)));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(bool)\nis_term_resized(int ToLines, int ToCols)\n{\n    return NCURSES_SP_NAME(is_term_resized) (CURRENT_SCREEN, ToLines, ToCols);\n}\n#endif\n\n/*\n */\nstatic ripoff_t *\nripped_window(WINDOW *win)\n{\n    ripoff_t *result = 0;\n    ripoff_t *rop;\n\n    if (win != 0) {\n#ifdef USE_SP_RIPOFF\n\tSCREEN *sp = _nc_screen_of(win);\n#endif\n\tfor (each_ripoff(rop)) {\n\t    if (rop->win == win && rop->line != 0) {\n\t\tresult = rop;\n\t\tbreak;\n\t    }\n\t}\n    }\n    return result;\n}\n\n/*\n * Returns the number of lines from the bottom for the beginning of a ripped\n * off window.\n */\nstatic int\nripped_bottom(WINDOW *win)\n{\n    int result = 0;\n\n    if (win != 0) {\n\tripoff_t *rop;\n\n#ifdef USE_SP_RIPOFF\n\tSCREEN *sp = _nc_screen_of(win);\n#endif\n\tfor (each_ripoff(rop)) {\n\t    if (rop->line < 0) {\n\t\tresult -= rop->line;\n\t\tif (rop->win == win) {\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n    return result;\n}\n\n/*\n * Return the number of levels of child-windows under the current window.\n */\nstatic int\nchild_depth(WINDOW *cmp)\n{\n    int depth = 0;\n\n    if (cmp != 0) {\n#ifdef USE_SP_WINDOWLIST\n\tSCREEN *sp = _nc_screen_of(cmp);\n#endif\n\tWINDOWLIST *wp;\n\n\tfor (each_window(sp, wp)) {\n\t    WINDOW *tst = &(wp->win);\n\t    if (tst->_parent == cmp) {\n\t\tdepth = 1 + child_depth(tst);\n\t\tbreak;\n\t    }\n\t}\n    }\n    return depth;\n}\n\n/*\n * Return the number of levels of parent-windows above the current window.\n */\nstatic int\nparent_depth(WINDOW *cmp)\n{\n    int depth = 0;\n\n    if (cmp != 0) {\n\tWINDOW *tst;\n\twhile ((tst = cmp->_parent) != 0) {\n\t    ++depth;\n\t    cmp = tst;\n\t}\n    }\n    return depth;\n}\n\n/*\n * FIXME: must adjust position so it's within the parent!\n */\nstatic int\nadjust_window(WINDOW *win, int ToLines, int ToCols, int stolen EXTRA_DCLS)\n{\n    int result;\n    int bottom = CurLines + _nc_screen_of(win)->_topstolen - stolen;\n    int myLines = win->_maxy + 1;\n    int myCols = win->_maxx + 1;\n    ripoff_t *rop = ripped_window(win);\n\n    T((T_CALLED(\"adjust_window(%p,%d,%d)%s depth %d/%d currently %ldx%ld at %ld,%ld\"),\n       (void *) win, ToLines, ToCols,\n       (rop != 0) ? \" (rip)\" : \"\",\n       parent_depth(win),\n       child_depth(win),\n       (long) getmaxy(win), (long) getmaxx(win),\n       (long) getbegy(win) + win->_yoffset, (long) getbegx(win)));\n\n    if (rop != 0 && rop->line < 0) {\n\t/*\n\t * If it is a ripped-off window at the bottom of the screen, simply\n\t * move it to the same relative position.\n\t */\n\twin->_begy = (NCURSES_SIZE_T) (ToLines - ripped_bottom(win) - 0 - win->_yoffset);\n\tif (rop->hook == _nc_slk_initialize)\n\t    _nc_format_slks(\n#if NCURSES_SP_FUNCS\n\t\t\t       _nc_screen_of(win),\n#endif\n\t\t\t       ToCols);\n    } else if (win->_begy >= bottom) {\n\t/*\n\t * If it is below the bottom of the new screen, move up by the same\n\t * amount that the screen shrank.\n\t */\n\twin->_begy = (NCURSES_SIZE_T) (win->_begy + (ToLines - CurLines));\n    } else {\n\tif (myLines == (CurLines - stolen)\n\t    && ToLines != CurLines) {\n\t    myLines = ToLines - stolen;\n\t} else if (myLines == CurLines\n\t\t   && ToLines != CurLines) {\n\t    myLines = ToLines;\n\t}\n    }\n\n    if (myLines > ToLines) {\n\tmyLines = ToLines;\n    }\n\n    if (myCols > ToCols)\n\tmyCols = ToCols;\n\n    if (myCols == CurCols\n\t&& ToCols != CurCols)\n\tmyCols = ToCols;\n\n    result = wresize(win, myLines, myCols);\n    returnCode(result);\n}\n\n/*\n * If we're decreasing size, recursively search for windows that have no\n * children, decrease those to fit, then decrease the containing window, etc.\n */\nstatic int\ndecrease_size(NCURSES_SP_DCLx int ToLines, int ToCols, int stolen EXTRA_DCLS)\n{\n    bool found;\n    int depth = 0;\n    WINDOWLIST *wp;\n\n    T((T_CALLED(\"decrease_size(%p, %d, %d)\"), (void *) SP_PARM, ToLines, ToCols));\n    UNUSED_SP;\n\n    do {\n\tfound = FALSE;\n\tTR(TRACE_UPDATE, (\"decreasing size of windows to %dx%d, depth=%d\",\n\t\t\t  ToLines, ToCols, depth));\n\tfor (each_window(SP_PARM, wp)) {\n\t    WINDOW *win = &(wp->win);\n\n\t    if (!(win->_flags & _ISPAD)) {\n\t\tif (child_depth(win) == depth) {\n\t\t    found = TRUE;\n\t\t    if (adjust_window(win, ToLines, ToCols,\n\t\t\t\t      stolen EXTRA_ARGS) != OK)\n\t\t\treturnCode(ERR);\n\t\t}\n\t    }\n\t}\n\t++depth;\n    } while (found);\n    returnCode(OK);\n}\n\n/*\n * If we're increasing size, recursively search for windows that have no\n * parent, increase those to fit, then increase the contained window, etc.\n */\nstatic int\nincrease_size(NCURSES_SP_DCLx int ToLines, int ToCols, int stolen EXTRA_DCLS)\n{\n    bool found;\n    int depth = 0;\n    WINDOWLIST *wp;\n\n    T((T_CALLED(\"increase_size(%p, %d, %d)\"), (void *) SP_PARM, ToLines, ToCols));\n    UNUSED_SP;\n\n    do {\n\tfound = FALSE;\n\tTR(TRACE_UPDATE, (\"increasing size of windows to %dx%d, depth=%d\",\n\t\t\t  ToLines, ToCols, depth));\n\tfor (each_window(SP_PARM, wp)) {\n\t    WINDOW *win = &(wp->win);\n\n\t    if (!(win->_flags & _ISPAD)) {\n\t\tif (parent_depth(win) == depth) {\n\t\t    found = TRUE;\n\t\t    if (adjust_window(win, ToLines, ToCols,\n\t\t\t\t      stolen EXTRA_ARGS) != OK)\n\t\t\treturnCode(ERR);\n\t\t}\n\t    }\n\t}\n\t++depth;\n    } while (found);\n    returnCode(OK);\n}\n\n/*\n * This function reallocates NCURSES window structures, with no side-effects\n * such as ungetch().\n */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(resize_term) (NCURSES_SP_DCLx int ToLines, int ToCols)\n{\n    int result = OK EXTRA_ARGS;\n    int was_stolen;\n\n    T((T_CALLED(\"resize_term(%p,%d,%d) old(%d,%d)\"),\n       (void *) SP_PARM, ToLines, ToCols,\n       (SP_PARM == 0) ? -1 : screen_lines(SP_PARM),\n       (SP_PARM == 0) ? -1 : screen_columns(SP_PARM)));\n\n    if (SP_PARM == 0 || ToLines <= 0 || ToCols <= 0) {\n\treturnCode(ERR);\n    }\n\n    _nc_nonsp_lock_global(curses);\n\n    was_stolen = (screen_lines(SP_PARM) - SP_PARM->_lines_avail);\n    if (NCURSES_SP_NAME(is_term_resized) (NCURSES_SP_ARGx ToLines, ToCols)) {\n\tint myLines = CurLines = screen_lines(SP_PARM);\n\tint myCols = CurCols = screen_columns(SP_PARM);\n\n#ifdef TRACE\n\tif (USE_TRACEF(TRACE_UPDATE)) {\n\t    show_window_sizes(\"before\");\n\t    _nc_unlock_global(tracef);\n\t}\n#endif\n\tif (ToLines > screen_lines(SP_PARM)) {\n\t    result = increase_size(NCURSES_SP_ARGx\n\t\t\t\t   myLines = ToLines,\n\t\t\t\t   myCols,\n\t\t\t\t   was_stolen EXTRA_ARGS);\n\t    CurLines = myLines;\n\t    CurCols = myCols;\n\t}\n\n\tif ((result == OK)\n\t    && (ToCols > screen_columns(SP_PARM))) {\n\t    result = increase_size(NCURSES_SP_ARGx\n\t\t\t\t   myLines,\n\t\t\t\t   myCols = ToCols,\n\t\t\t\t   was_stolen EXTRA_ARGS);\n\t    CurLines = myLines;\n\t    CurCols = myCols;\n\t}\n\n\tif ((result == OK)\n\t    && (ToLines < myLines ||\n\t\tToCols < myCols)) {\n\t    result = decrease_size(NCURSES_SP_ARGx\n\t\t\t\t   ToLines,\n\t\t\t\t   ToCols,\n\t\t\t\t   was_stolen EXTRA_ARGS);\n\t}\n\n\tif (result == OK) {\n\t    screen_lines(SP_PARM) = (NCURSES_SIZE_T) ToLines;\n\t    screen_columns(SP_PARM) = (NCURSES_SIZE_T) ToCols;\n\n#ifdef USE_TERM_DRIVER\n\t    CallDriver_2(SP_PARM, td_setsize, ToLines, ToCols);\n#else\n\t    lines = (NCURSES_SIZE_T) ToLines;\n\t    columns = (NCURSES_SIZE_T) ToCols;\n#endif\n\n\t    SP_PARM->_lines_avail = (NCURSES_SIZE_T) (ToLines - was_stolen);\n\n\t    if (SP_PARM->oldhash) {\n\t\tFreeAndNull(SP_PARM->oldhash);\n\t    }\n\t    if (SP_PARM->newhash) {\n\t\tFreeAndNull(SP_PARM->newhash);\n\t    }\n#ifdef TRACE\n\t    if (USE_TRACEF(TRACE_UPDATE)) {\n\t\tSET_LINES(ToLines - was_stolen);\n\t\tSET_COLS(ToCols);\n\t\tshow_window_sizes(\"after\");\n\t\t_nc_unlock_global(tracef);\n\t    }\n#endif\n\t}\n    }\n\n    if (result == OK) {\n\t/*\n\t * Always update LINES, to allow for call from lib_doupdate.c which\n\t * needs to have the count adjusted by the stolen (ripped off) lines.\n\t */\n\tSET_LINES(ToLines - was_stolen);\n\tSET_COLS(ToCols);\n    }\n\n    _nc_nonsp_unlock_global(curses);\n\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nresize_term(int ToLines, int ToCols)\n{\n    int res;\n    _nc_sp_lock_global(curses);\n    res = NCURSES_SP_NAME(resize_term) (CURRENT_SCREEN, ToLines, ToCols);\n    _nc_sp_unlock_global(curses);\n    return (res);\n}\n#endif\n\n/*\n * This function reallocates NCURSES window structures.  It is invoked in\n * response to a SIGWINCH interrupt.  Other user-defined windows may also need\n * to be reallocated.\n *\n * Because this performs memory allocation, it should not (in general) be\n * invoked directly from the signal handler.\n */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(resizeterm) (NCURSES_SP_DCLx int ToLines, int ToCols)\n{\n    int result = ERR;\n\n    T((T_CALLED(\"resizeterm(%p, %d,%d) old(%d,%d)\"),\n       (void *) SP_PARM, ToLines, ToCols,\n       (SP_PARM == 0) ? -1 : screen_lines(SP_PARM),\n       (SP_PARM == 0) ? -1 : screen_columns(SP_PARM)));\n\n    if (SP_PARM != 0 && ToLines > 0 && ToCols > 0) {\n\tresult = OK;\n\tSP_PARM->_sig_winch = FALSE;\n\n\tif (NCURSES_SP_NAME(is_term_resized) (NCURSES_SP_ARGx ToLines, ToCols)) {\n#if USE_SIGWINCH\n\t    ripoff_t *rop;\n\t    bool slk_visible = (SP_PARM != 0\n\t\t\t\t&& SP_PARM->_slk != 0\n\t\t\t\t&& !(SP_PARM->_slk->hidden));\n\n\t    if (slk_visible) {\n\t\tslk_clear();\n\t    }\n#endif\n\t    result = NCURSES_SP_NAME(resize_term) (NCURSES_SP_ARGx ToLines, ToCols);\n\n#if USE_SIGWINCH\n\t    clearok(CurScreen(SP_PARM), TRUE);\t/* screen contents are unknown */\n\n\t    /* ripped-off lines are a special case: if we did not lengthen\n\t     * them, we haven't moved them either.  repaint them, too.\n\t     *\n\t     * for the rest - stdscr and other windows - the client has to\n\t     * decide which to repaint, since without panels, ncurses does\n\t     * not know which are really on top.\n\t     */\n\t    for (each_ripoff(rop)) {\n\t\tif (rop->win != StdScreen(SP_PARM)\n\t\t    && rop->win != 0\n\t\t    && rop->line < 0) {\n\n\t\t    if (rop->hook != _nc_slk_initialize) {\n\t\t\ttouchwin(rop->win);\n\t\t\twnoutrefresh(rop->win);\n\t\t    }\n\t\t}\n\t    }\n\n\t    /* soft-keys are a special case: we _know_ how to repaint them */\n\t    if (slk_visible) {\n\t\tNCURSES_SP_NAME(slk_restore) (NCURSES_SP_ARG);\n\t\tNCURSES_SP_NAME(slk_touch) (NCURSES_SP_ARG);\n\t\tNCURSES_SP_NAME(slk_refresh) (NCURSES_SP_ARG);\n\t    }\n#endif\n\t}\n#if USE_SIGWINCH\n\tsafe_ungetch(SP_PARM, KEY_RESIZE);\t/* so application can know this */\n#endif\n    }\n\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nresizeterm(int ToLines, int ToCols)\n{\n    return NCURSES_SP_NAME(resizeterm) (CURRENT_SCREEN, ToLines, ToCols);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 2007-2009,2016 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *     Author: Thomas E. Dickey                        2007                 *\n ****************************************************************************/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: use_window.c,v 1.10 2016/01/23 21:32:00 tom Exp $\")\n\nNCURSES_EXPORT(int)\nuse_window(WINDOW *win, NCURSES_WINDOW_CB func, void *data)\n{\n    int code = OK;\n\n    T((T_CALLED(\"use_window(%p,%p,%p)\"), (void *) win, TR_FUNC(func), data));\n    _nc_lock_global(curses);\n    code = func(win, data);\n    _nc_unlock_global(curses);\n\n    returnCode(code);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2010,2011 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey 1996-on                                        *\n *     and: Juergen Pfeifer                                                 *\n ****************************************************************************/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: wresize.c,v 1.35 2011/05/21 18:55:07 tom Exp $\")\n\nstatic int\ncleanup_lines(struct ldat *data, int length)\n{\n    while (--length >= 0)\n\tfree(data[length].text);\n    free(data);\n    return ERR;\n}\n\n/*\n * If we have reallocated the ldat structs, we will have to repair pointers\n * used in subwindows.\n */\nstatic void\nrepair_subwindows(WINDOW *cmp)\n{\n    WINDOWLIST *wp;\n    struct ldat *pline = cmp->_line;\n    int row;\n#ifdef USE_SP_WINDOWLIST\n    SCREEN *sp = _nc_screen_of(cmp);\n#endif\n\n    _nc_lock_global(curses);\n\n    for (each_window(SP_PARM, wp)) {\n\tWINDOW *tst = &(wp->win);\n\n\tif (tst->_parent == cmp) {\n\n\t    if (tst->_pary > cmp->_maxy)\n\t\ttst->_pary = cmp->_maxy;\n\t    if (tst->_parx > cmp->_maxx)\n\t\ttst->_parx = cmp->_maxx;\n\n\t    if (tst->_maxy + tst->_pary > cmp->_maxy)\n\t\ttst->_maxy = (NCURSES_SIZE_T) (cmp->_maxy - tst->_pary);\n\t    if (tst->_maxx + tst->_parx > cmp->_maxx)\n\t\ttst->_maxx = (NCURSES_SIZE_T) (cmp->_maxx - tst->_parx);\n\n\t    for (row = 0; row <= tst->_maxy; ++row) {\n\t\ttst->_line[row].text = &pline[tst->_pary + row].text[tst->_parx];\n\t    }\n\t    repair_subwindows(tst);\n\t}\n    }\n    _nc_unlock_global(curses);\n}\n\n/*\n * Reallocate a curses WINDOW struct to either shrink or grow to the specified\n * new lines/columns.  If it grows, the new character cells are filled with\n * blanks.  The application is responsible for repainting the blank area.\n */\nNCURSES_EXPORT(int)\nwresize(WINDOW *win, int ToLines, int ToCols)\n{\n    int col, row, size_x, size_y;\n    struct ldat *pline;\n    struct ldat *new_lines = 0;\n\n#ifdef TRACE\n    T((T_CALLED(\"wresize(%p,%d,%d)\"), (void *) win, ToLines, ToCols));\n    if (win) {\n\tTR(TRACE_UPDATE, (\"...beg (%ld, %ld), max(%ld,%ld), reg(%ld,%ld)\",\n\t\t\t  (long) win->_begy, (long) win->_begx,\n\t\t\t  (long) win->_maxy, (long) win->_maxx,\n\t\t\t  (long) win->_regtop, (long) win->_regbottom));\n\tif (USE_TRACEF(TRACE_UPDATE)) {\n\t    _tracedump(\"...before\", win);\n\t    _nc_unlock_global(tracef);\n\t}\n    }\n#endif\n\n    if (!win || --ToLines < 0 || --ToCols < 0)\n\treturnCode(ERR);\n\n    size_x = win->_maxx;\n    size_y = win->_maxy;\n\n    if (ToLines == size_y\n\t&& ToCols == size_x)\n\treturnCode(OK);\n\n    if ((win->_flags & _SUBWIN)) {\n\t/*\n\t * Check if the new limits will fit into the parent window's size.  If\n\t * not, do not resize.  We could adjust the location of the subwindow,\n\t * but the application may not like that.\n\t */\n\tif (win->_pary + ToLines > win->_parent->_maxy\n\t    || win->_parx + ToCols > win->_parent->_maxx) {\n\t    returnCode(ERR);\n\t}\n\tpline = win->_parent->_line;\n    } else {\n\tpline = 0;\n    }\n\n    /*\n     * Allocate new memory as needed.  Do the allocations without modifying\n     * the original window, in case an allocation fails.  Always allocate\n     * (at least temporarily) the array pointing to the individual lines.\n     */\n    new_lines = typeCalloc(struct ldat, (unsigned) (ToLines + 1));\n    if (new_lines == 0)\n\treturnCode(ERR);\n\n    /*\n     * For each line in the target, allocate or adjust pointers for the\n     * corresponding text, depending on whether this is a window or a\n     * subwindow.\n     */\n    for (row = 0; row <= ToLines; ++row) {\n\tint begin = (row > size_y) ? 0 : (size_x + 1);\n\tint end = ToCols;\n\tNCURSES_CH_T *s;\n\n\tif (!(win->_flags & _SUBWIN)) {\n\t    if (row <= size_y) {\n\t\tif (ToCols != size_x) {\n\t\t    s = typeMalloc(NCURSES_CH_T, (unsigned) ToCols + 1);\n\t\t    if (s == 0)\n\t\t\treturnCode(cleanup_lines(new_lines, row));\n\t\t    for (col = 0; col <= ToCols; ++col) {\n\t\t\ts[col] = (col <= size_x\n\t\t\t\t  ? win->_line[row].text[col]\n\t\t\t\t  : win->_nc_bkgd);\n\t\t    }\n\t\t} else {\n\t\t    s = win->_line[row].text;\n\t\t}\n\t    } else {\n\t\ts = typeMalloc(NCURSES_CH_T, (unsigned) ToCols + 1);\n\t\tif (s == 0)\n\t\t    returnCode(cleanup_lines(new_lines, row));\n\t\tfor (col = 0; col <= ToCols; ++col)\n\t\t    s[col] = win->_nc_bkgd;\n\t    }\n\t} else if (pline != 0 && pline[win->_pary + row].text != 0) {\n\t    s = &pline[win->_pary + row].text[win->_parx];\n\t} else {\n\t    s = 0;\n\t}\n\n\tif_USE_SCROLL_HINTS(new_lines[row].oldindex = row);\n\tif (row <= size_y) {\n\t    new_lines[row].firstchar = win->_line[row].firstchar;\n\t    new_lines[row].lastchar = win->_line[row].lastchar;\n\t}\n\tif ((ToCols != size_x) || (row > size_y)) {\n\t    if (end >= begin) {\t/* growing */\n\t\tif (new_lines[row].firstchar < begin)\n\t\t    new_lines[row].firstchar = (NCURSES_SIZE_T) begin;\n\t    } else {\t\t/* shrinking */\n\t\tnew_lines[row].firstchar = 0;\n\t    }\n\t    new_lines[row].lastchar = (NCURSES_SIZE_T) ToCols;\n\t}\n\tnew_lines[row].text = s;\n    }\n\n    /*\n     * Dispose of unwanted memory.\n     */\n    if (!(win->_flags & _SUBWIN)) {\n\tif (ToCols == size_x) {\n\t    for (row = ToLines + 1; row <= size_y; row++) {\n\t\tfree(win->_line[row].text);\n\t    }\n\t} else {\n\t    for (row = 0; row <= size_y; row++) {\n\t\tfree(win->_line[row].text);\n\t    }\n\t}\n    }\n\n    free(win->_line);\n    win->_line = new_lines;\n\n    /*\n     * Finally, adjust the parameters showing screen size and cursor\n     * position:\n     */\n    win->_maxx = (NCURSES_SIZE_T) ToCols;\n    win->_maxy = (NCURSES_SIZE_T) ToLines;\n\n    if (win->_regtop > win->_maxy)\n\twin->_regtop = win->_maxy;\n    if (win->_regbottom > win->_maxy\n\t|| win->_regbottom == size_y)\n\twin->_regbottom = win->_maxy;\n\n    if (win->_curx > win->_maxx)\n\twin->_curx = win->_maxx;\n    if (win->_cury > win->_maxy)\n\twin->_cury = win->_maxy;\n\n    /*\n     * Check for subwindows of this one, and readjust pointers to our text,\n     * if needed.\n     */\n    repair_subwindows(win);\n\n#ifdef TRACE\n    TR(TRACE_UPDATE, (\"...beg (%ld, %ld), max(%ld,%ld), reg(%ld,%ld)\",\n\t\t      (long) win->_begy, (long) win->_begx,\n\t\t      (long) win->_maxy, (long) win->_maxx,\n\t\t      (long) win->_regtop, (long) win->_regbottom));\n    if (USE_TRACEF(TRACE_UPDATE)) {\n\t_tracedump(\"...after:\", win);\n\t_nc_unlock_global(tracef);\n    }\n#endif\n    returnCode(OK);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2012,2016 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n ****************************************************************************/\n\n/*\n *\tcomp_error.c -- Error message routines\n *\n */\n\n#include <curses.priv.h>\n\n#include <tic.h>\n\nMODULE_ID(\"$Id: comp_error.c,v 1.37 2016/09/10 20:26:29 tom Exp $\")\n\nNCURSES_EXPORT_VAR(bool) _nc_suppress_warnings = FALSE;\nNCURSES_EXPORT_VAR(int) _nc_curr_line = 0; /* current line # in input */\nNCURSES_EXPORT_VAR(int) _nc_curr_col = 0; /* current column # in input */\n\n#define SourceName\t_nc_globals.comp_sourcename\n#define TermType\t_nc_globals.comp_termtype\n\nNCURSES_EXPORT(const char *)\n_nc_get_source(void)\n{\n    return SourceName;\n}\n\nNCURSES_EXPORT(void)\n_nc_set_source(const char *const name)\n{\n    FreeIfNeeded(SourceName);\n    SourceName = strdup(name);\n}\n\nNCURSES_EXPORT(void)\n_nc_set_type(const char *const name)\n{\n#define MY_SIZE (size_t) MAX_NAME_SIZE\n    if (TermType == 0)\n\tTermType = typeMalloc(char, MY_SIZE + 1);\n    if (TermType != 0) {\n\tTermType[0] = '\\0';\n\tif (name) {\n\t    _nc_STRNCAT(TermType, name, MY_SIZE, MY_SIZE);\n\t}\n    }\n}\n\nNCURSES_EXPORT(void)\n_nc_get_type(char *name)\n{\n#if NO_LEAKS\n    if (name == 0 && TermType != 0) {\n\tFreeAndNull(TermType);\n\treturn;\n    }\n#endif\n    if (name != 0)\n\t_nc_STRCPY(name, TermType != 0 ? TermType : \"\", MAX_NAME_SIZE);\n}\n\nstatic NCURSES_INLINE void\nwhere_is_problem(void)\n{\n    fprintf(stderr, \"\\\"%s\\\"\", SourceName ? SourceName : \"?\");\n    if (_nc_curr_line >= 0)\n\tfprintf(stderr, \", line %d\", _nc_curr_line);\n    if (_nc_curr_col >= 0)\n\tfprintf(stderr, \", col %d\", _nc_curr_col);\n    if (TermType != 0 && TermType[0] != '\\0')\n\tfprintf(stderr, \", terminal '%s'\", TermType);\n    fputc(':', stderr);\n    fputc(' ', stderr);\n}\n\nNCURSES_EXPORT(void)\n_nc_warning(const char *const fmt,...)\n{\n    va_list argp;\n\n    if (_nc_suppress_warnings)\n\treturn;\n\n    where_is_problem();\n    va_start(argp, fmt);\n    vfprintf(stderr, fmt, argp);\n    fprintf(stderr, \"\\n\");\n    va_end(argp);\n}\n\nNCURSES_EXPORT(void)\n_nc_err_abort(const char *const fmt,...)\n{\n    va_list argp;\n\n    where_is_problem();\n    va_start(argp, fmt);\n    vfprintf(stderr, fmt, argp);\n    fprintf(stderr, \"\\n\");\n    va_end(argp);\n    exit(EXIT_FAILURE);\n}\n\nNCURSES_EXPORT(void)\n_nc_syserr_abort(const char *const fmt,...)\n{\n    va_list argp;\n\n    where_is_problem();\n    va_start(argp, fmt);\n    vfprintf(stderr, fmt, argp);\n    fprintf(stderr, \"\\n\");\n    va_end(argp);\n\n    /* If we're debugging, try to show where the problem occurred - this\n     * will dump core.\n     */\n#if defined(TRACE) || !defined(NDEBUG)\n    abort();\n#else\n    /* Dumping core in production code is not a good idea.\n     */\n    exit(EXIT_FAILURE);\n#endif\n}\n\n#if NO_LEAKS\nNCURSES_EXPORT(void)\n_nc_comp_error_leaks(void)\n{\n    FreeAndNull(SourceName);\n    FreeAndNull(TermType);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2000,2012 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey <dickey@clark.net> 1998                        *\n ****************************************************************************/\n\n/*\n * Wrapper for malloc/realloc.  Standard implementations allow realloc with\n * a null pointer, but older libraries may not (e.g., SunOS).\n *\n * Also if realloc fails, we discard the old memory to avoid leaks.\n */\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: doalloc.c,v 1.11 2012/11/03 19:27:41 tom Exp $\")\n\nNCURSES_EXPORT(void *)\n_nc_doalloc(void *oldp, size_t amount)\n{\n    void *newp;\n\n    if (oldp != 0) {\n\tif ((newp = realloc(oldp, amount)) == 0) {\n\t    free(oldp);\n\t    errno = ENOMEM;\t/* just in case 'free' reset */\n\t}\n    } else {\n\tnewp = malloc(amount);\n    }\n    return newp;\n}\n","/****************************************************************************\n * Copyright (c) 1998-2012,2013 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey <dickey@clark.net> 1998                        *\n ****************************************************************************/\n\n/*\n *\tgetenv_num.c -- obtain a number from the environment\n */\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: getenv_num.c,v 1.6 2013/09/28 20:25:08 tom Exp $\")\n\nNCURSES_EXPORT(int)\n_nc_getenv_num(const char *name)\n{\n    char *dst = 0;\n    char *src = getenv(name);\n    long value;\n\n    if ((src == 0)\n\t|| (value = strtol(src, &dst, 0)) < 0\n\t|| (dst == src)\n\t|| (*dst != '\\0')\n\t|| (int) value < value)\n\tvalue = -1;\n\n    return (int) value;\n}\n\nNCURSES_EXPORT(void)\n_nc_setenv_num(const char *name, int value)\n{\n    if (name != 0 && value >= 0) {\n\tchar buffer[128];\n#if HAVE_SETENV\n\t_nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer)) \"%d\", value);\n\tsetenv(name, buffer, 1);\n#elif HAVE_PUTENV\n\tchar *s;\n\t_nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer)) \"%s=%d\", name, value);\n\tif ((s = strdup(buffer)) != 0)\n\t    putenv(s);\n#endif\n    }\n}\n","/****************************************************************************\n * Copyright (c) 1998-2014,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2008                    *\n ****************************************************************************/\n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_acs.c,v 1.46 2017/09/20 00:48:55 tom Exp $\")\n\n#if BROKEN_LINKER || USE_REENTRANT\n#define MyBuffer _nc_prescreen.real_acs_map\nNCURSES_EXPORT(chtype *)\nNCURSES_PUBLIC_VAR(acs_map) (void)\n{\n    if (MyBuffer == 0)\n\tMyBuffer = typeCalloc(chtype, ACS_LEN);\n    return MyBuffer;\n}\n#undef MyBuffer\n#else\nNCURSES_EXPORT_VAR (chtype) acs_map[ACS_LEN] =\n{\n    0\n};\n#endif\n\n#ifdef USE_TERM_DRIVER\nNCURSES_EXPORT(chtype)\nNCURSES_SP_NAME(_nc_acs_char) (NCURSES_SP_DCLx int c)\n{\n    chtype *map;\n    if (c < 0 || c >= ACS_LEN)\n\treturn (chtype) 0;\n    map = (SP_PARM != 0) ? SP_PARM->_acs_map :\n#if BROKEN_LINKER || USE_REENTRANT\n\t_nc_prescreen.real_acs_map\n#else\n\tacs_map\n#endif\n\t;\n    return map[c];\n}\n#endif /* USE_TERM_DRIVER */\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_init_acs) (NCURSES_SP_DCL0)\n{\n    chtype *fake_map = acs_map;\n    chtype *real_map = SP_PARM != 0 ? SP_PARM->_acs_map : fake_map;\n    int j;\n\n    T((\"initializing ACS map\"));\n\n    /*\n     * If we're using this from curses (rather than terminfo), we are storing\n     * the mapping information in the SCREEN struct so we can decide how to\n     * render it.\n     */\n    if (real_map != fake_map) {\n\tfor (j = 1; j < ACS_LEN; ++j) {\n\t    real_map[j] = 0;\n\t    fake_map[j] = A_ALTCHARSET | (chtype) j;\n\t    if (SP_PARM)\n\t\tSP_PARM->_screen_acs_map[j] = FALSE;\n\t}\n    } else {\n\tfor (j = 1; j < ACS_LEN; ++j) {\n\t    real_map[j] = 0;\n\t}\n    }\n\n    /*\n     * Initializations for a UNIX-like multi-terminal environment.  Use\n     * ASCII chars and count on the terminfo description to do better.\n     */\n    real_map['l'] = '+';\t/* should be upper left corner */\n    real_map['m'] = '+';\t/* should be lower left corner */\n    real_map['k'] = '+';\t/* should be upper right corner */\n    real_map['j'] = '+';\t/* should be lower right corner */\n    real_map['u'] = '+';\t/* should be tee pointing left */\n    real_map['t'] = '+';\t/* should be tee pointing right */\n    real_map['v'] = '+';\t/* should be tee pointing up */\n    real_map['w'] = '+';\t/* should be tee pointing down */\n    real_map['q'] = '-';\t/* should be horizontal line */\n    real_map['x'] = '|';\t/* should be vertical line */\n    real_map['n'] = '+';\t/* should be large plus or crossover */\n    real_map['o'] = '~';\t/* should be scan line 1 */\n    real_map['s'] = '_';\t/* should be scan line 9 */\n    real_map['`'] = '+';\t/* should be diamond */\n    real_map['a'] = ':';\t/* should be checker board (stipple) */\n    real_map['f'] = '\\'';\t/* should be degree symbol */\n    real_map['g'] = '#';\t/* should be plus/minus */\n    real_map['~'] = 'o';\t/* should be bullet */\n    real_map[','] = '<';\t/* should be arrow pointing left */\n    real_map['+'] = '>';\t/* should be arrow pointing right */\n    real_map['.'] = 'v';\t/* should be arrow pointing down */\n    real_map['-'] = '^';\t/* should be arrow pointing up */\n    real_map['h'] = '#';\t/* should be board of squares */\n    real_map['i'] = '#';\t/* should be lantern symbol */\n    real_map['0'] = '#';\t/* should be solid square block */\n    /* these defaults were invented for ncurses */\n    real_map['p'] = '-';\t/* should be scan line 3 */\n    real_map['r'] = '-';\t/* should be scan line 7 */\n    real_map['y'] = '<';\t/* should be less-than-or-equal-to */\n    real_map['z'] = '>';\t/* should be greater-than-or-equal-to */\n    real_map['{'] = '*';\t/* should be greek pi */\n    real_map['|'] = '!';\t/* should be not-equal */\n    real_map['}'] = 'f';\t/* should be pound-sterling symbol */\n    /* thick-line-drawing */\n    real_map['L'] = '+';\t/* upper left corner */\n    real_map['M'] = '+';\t/* lower left corner */\n    real_map['K'] = '+';\t/* upper right corner */\n    real_map['J'] = '+';\t/* lower right corner */\n    real_map['T'] = '+';\t/* tee pointing left */\n    real_map['U'] = '+';\t/* tee pointing right */\n    real_map['V'] = '+';\t/* tee pointing up */\n    real_map['W'] = '+';\t/* tee pointing down */\n    real_map['Q'] = '-';\t/* horizontal line */\n    real_map['X'] = '|';\t/* vertical line */\n    real_map['N'] = '+';\t/* large plus or crossover */\n    /* double-line-drawing */\n    real_map['C'] = '+';\t/* upper left corner */\n    real_map['D'] = '+';\t/* lower left corner */\n    real_map['B'] = '+';\t/* upper right corner */\n    real_map['A'] = '+';\t/* lower right corner */\n    real_map['G'] = '+';\t/* tee pointing left */\n    real_map['F'] = '+';\t/* tee pointing right */\n    real_map['H'] = '+';\t/* tee pointing up */\n    real_map['I'] = '+';\t/* tee pointing down */\n    real_map['R'] = '-';\t/* horizontal line */\n    real_map['Y'] = '|';\t/* vertical line */\n    real_map['E'] = '+';\t/* large plus or crossover */\n\n#ifdef USE_TERM_DRIVER\n    CallDriver_2(SP_PARM, td_initacs, real_map, fake_map);\n#else\n    if (ena_acs != NULL) {\n\tNCURSES_PUTP2(\"ena_acs\", ena_acs);\n    }\n#if NCURSES_EXT_FUNCS && defined(enter_pc_charset_mode) && defined(exit_pc_charset_mode)\n    /*\n     * Linux console \"supports\" the \"PC ROM\" character set by the coincidence\n     * that smpch/rmpch and smacs/rmacs have the same values.  ncurses has\n     * no codepage support (see SCO Merge for an example).  Outside of the\n     * values defined in acsc, there are no definitions for the \"PC ROM\"\n     * character set (assumed by some applications to be codepage 437), but we\n     * allow those applications to use those codepoints.\n     *\n     * test/blue.c uses this feature.\n     */\n#define PCH_KLUDGE(a,b) (a != 0 && b != 0 && !strcmp(a,b))\n    if (PCH_KLUDGE(enter_pc_charset_mode, enter_alt_charset_mode) &&\n\tPCH_KLUDGE(exit_pc_charset_mode, exit_alt_charset_mode)) {\n\tsize_t i;\n\tfor (i = 1; i < ACS_LEN; ++i) {\n\t    if (real_map[i] == 0) {\n\t\treal_map[i] = (chtype) i;\n\t\tif (real_map != fake_map) {\n\t\t    if (SP != 0)\n\t\t\tSP->_screen_acs_map[i] = TRUE;\n\t\t}\n\t    }\n\t}\n    }\n#endif\n\n    if (acs_chars != NULL) {\n\tsize_t i = 0;\n\tsize_t length = strlen(acs_chars);\n\n\twhile (i + 1 < length) {\n\t    if (acs_chars[i] != 0 && UChar(acs_chars[i]) < ACS_LEN) {\n\t\treal_map[UChar(acs_chars[i])] = UChar(acs_chars[i + 1]) | A_ALTCHARSET;\n\t\tif (SP != 0)\n\t\t    SP->_screen_acs_map[UChar(acs_chars[i])] = TRUE;\n\t    }\n\t    i += 2;\n\t}\n    }\n#ifdef TRACE\n    /* Show the equivalent mapping, noting if it does not match the\n     * given attribute, whether by re-ordering or duplication.\n     */\n    if (USE_TRACEF(TRACE_CALLS)) {\n\tsize_t n, m;\n\tchar show[ACS_LEN * 2 + 1];\n\tfor (n = 1, m = 0; n < ACS_LEN; n++) {\n\t    if (real_map[n] != 0) {\n\t\tshow[m++] = (char) n;\n\t\tshow[m++] = (char) ChCharOf(real_map[n]);\n\t    }\n\t}\n\tshow[m] = 0;\n\tif (acs_chars == NULL || strcmp(acs_chars, show))\n\t    _tracef(\"%s acs_chars %s\",\n\t\t    (acs_chars == NULL) ? \"NULL\" : \"READ\",\n\t\t    _nc_visbuf(acs_chars));\n\t_tracef(\"%s acs_chars %s\",\n\t\t(acs_chars == NULL)\n\t\t? \"NULL\"\n\t\t: (strcmp(acs_chars, show)\n\t\t   ? \"DIFF\"\n\t\t   : \"SAME\"),\n\t\t_nc_visbuf(show));\n\t_nc_unlock_global(tracef);\n    }\n#endif /* TRACE */\n#endif\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_init_acs(void)\n{\n    NCURSES_SP_NAME(_nc_init_acs) (CURRENT_SCREEN);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n ****************************************************************************/\n\n/*\n *\tlib_baudrate.c\n *\n */\n\n#include <curses.priv.h>\n#include <termcap.h>\t\t/* ospeed */\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n#include <sys/param.h>\n#endif\n\n/*\n * These systems use similar header files, which define B1200 as 1200, etc.,\n * but can be overridden by defining USE_OLD_TTY so B1200 is 9, which makes all\n * of the indices up to B115200 fit nicely in a 'short', allowing us to retain\n * ospeed's type for compatibility.\n */\n#if NCURSES_OSPEED_COMPAT && \\\n \t((defined(__FreeBSD__) && (__FreeBSD_version < 700000)) || \\\n\tdefined(__NetBSD__) || \\\n\t((defined(__OpenBSD__) && OpenBSD < 201510)) || \\\n\tdefined(__APPLE__))\n#undef B0\n#undef B50\n#undef B75\n#undef B110\n#undef B134\n#undef B150\n#undef B200\n#undef B300\n#undef B600\n#undef B1200\n#undef B1800\n#undef B2400\n#undef B4800\n#undef B9600\n#undef B19200\n#undef EXTA\n#undef B38400\n#undef EXTB\n#undef B57600\n#undef B115200\n#undef B230400\n#undef B460800\n#undef B921600\n#define USE_OLD_TTY\n#include <sys/ttydev.h>\n#else\n#undef USE_OLD_TTY\n#endif /* USE_OLD_TTY */\n\nMODULE_ID(\"$Id: lib_baudrate.c,v 1.43 2017/03/31 17:19:30 tom Exp $\")\n\n/*\n *\tint\n *\tbaudrate()\n *\n *\tReturns the current terminal's baud rate.\n *\n */\n\nstruct speed {\n    int given_speed;\t\t/* values for 'ospeed' */\n    int actual_speed;\t\t/* the actual speed */\n};\n\n#define DATA(number) { B##number, number }\n\nstatic struct speed const speeds[] =\n{\n    DATA(0),\n    DATA(50),\n    DATA(75),\n    DATA(110),\n    DATA(134),\n    DATA(150),\n    DATA(200),\n    DATA(300),\n    DATA(600),\n    DATA(1200),\n    DATA(1800),\n    DATA(2400),\n    DATA(4800),\n    DATA(9600),\n#ifdef B19200\n    DATA(19200),\n#elif defined(EXTA)\n    {EXTA, 19200},\n#endif\n#ifdef B28800\n    DATA(28800),\n#endif\n#ifdef B38400\n    DATA(38400),\n#elif defined(EXTB)\n    {EXTB, 38400},\n#endif\n#ifdef B57600\n    DATA(57600),\n#endif\n    /* ifdef to prevent overflow when OLD_TTY is not available */\n#if !(NCURSES_OSPEED_COMPAT && defined(__FreeBSD__) && (__FreeBSD_version > 700000))\n#ifdef B76800\n    DATA(76800),\n#endif\n#ifdef B115200\n    DATA(115200),\n#endif\n#ifdef B153600\n    DATA(153600),\n#endif\n#ifdef B230400\n    DATA(230400),\n#endif\n#ifdef B307200\n    DATA(307200),\n#endif\n#ifdef B460800\n    DATA(460800),\n#endif\n#ifdef B500000\n    DATA(500000),\n#endif\n#ifdef B576000\n    DATA(576000),\n#endif\n#ifdef B921600\n    DATA(921600),\n#endif\n#ifdef B1000000\n    DATA(1000000),\n#endif\n#ifdef B1152000\n    DATA(1152000),\n#endif\n#ifdef B1500000\n    DATA(1500000),\n#endif\n#ifdef B2000000\n    DATA(2000000),\n#endif\n#ifdef B2500000\n    DATA(2500000),\n#endif\n#ifdef B3000000\n    DATA(3000000),\n#endif\n#ifdef B3500000\n    DATA(3500000),\n#endif\n#ifdef B4000000\n    DATA(4000000),\n#endif\n#endif\n};\n\nNCURSES_EXPORT(int)\n_nc_baudrate(int OSpeed)\n{\n#if !USE_REENTRANT\n    static int last_OSpeed;\n    static int last_baudrate;\n#endif\n\n    int result = ERR;\n\n    if (OSpeed < 0)\n\tOSpeed = (NCURSES_OSPEED) OSpeed;\n    if (OSpeed < 0)\n\tOSpeed = (unsigned short) OSpeed;\n#if !USE_REENTRANT\n    if (OSpeed == last_OSpeed) {\n\tresult = last_baudrate;\n    }\n#endif\n    if (result == ERR) {\n\tif (OSpeed >= 0) {\n\t    unsigned i;\n\n\t    for (i = 0; i < SIZEOF(speeds); i++) {\n\t\tif (speeds[i].given_speed > OSpeed) {\n\t\t    break;\n\t\t}\n\t\tif (speeds[i].given_speed == OSpeed) {\n\t\t    result = speeds[i].actual_speed;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#if !USE_REENTRANT\n\tif (OSpeed != last_OSpeed) {\n\t    last_OSpeed = OSpeed;\n\t    last_baudrate = result;\n\t}\n#endif\n    }\n    return (result);\n}\n\nNCURSES_EXPORT(int)\n_nc_ospeed(int BaudRate)\n{\n    int result = 1;\n\n    if (BaudRate >= 0) {\n\tunsigned i;\n\n\tfor (i = 0; i < SIZEOF(speeds); i++) {\n\t    if (speeds[i].actual_speed == BaudRate) {\n\t\tresult = speeds[i].given_speed;\n\t\tbreak;\n\t    }\n\t}\n    }\n    return (result);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(baudrate) (NCURSES_SP_DCL0)\n{\n    int result;\n\n    T((T_CALLED(\"baudrate(%p)\"), (void *) SP_PARM));\n\n    /*\n     * In debugging, allow the environment symbol to override when we're\n     * redirecting to a file, so we can construct repeatable test-cases\n     * that take into account costs that depend on baudrate.\n     */\n#ifdef TRACE\n    if (IsValidTIScreen(SP_PARM)\n\t&& !NC_ISATTY(fileno((SP_PARM && SP_PARM->_ofp) ? SP_PARM->_ofp : stdout))\n\t&& getenv(\"BAUDRATE\") != 0) {\n\tint ret;\n\tif ((ret = _nc_getenv_num(\"BAUDRATE\")) <= 0)\n\t    ret = 9600;\n\tospeed = (NCURSES_OSPEED) _nc_ospeed(ret);\n\treturnCode(ret);\n    }\n#endif\n\n    if (IsValidTIScreen(SP_PARM)) {\n#ifdef USE_OLD_TTY\n\tresult = (int) cfgetospeed(&(TerminalOf(SP_PARM)->Nttyb));\n\tospeed = (NCURSES_OSPEED) _nc_ospeed(result);\n#else /* !USE_OLD_TTY */\n#ifdef TERMIOS\n\tospeed = (NCURSES_OSPEED) cfgetospeed(&(TerminalOf(SP_PARM)->Nttyb));\n#else\n\tospeed = (NCURSES_OSPEED) TerminalOf(SP_PARM)->Nttyb.sg_ospeed;\n#endif\n\tresult = _nc_baudrate(ospeed);\n#endif\n\tTerminalOf(SP_PARM)->_baudrate = result;\n    } else {\n\tresult = ERR;\n    }\n\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nbaudrate(void)\n{\n    return NCURSES_SP_NAME(baudrate) (CURRENT_SCREEN);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey <dickey@clark.net> 1997                        *\n ****************************************************************************/\n/*\n * Module that \"owns\" the 'cur_term' variable:\n *\n *\tTERMINAL *set_curterm(TERMINAL *)\n *\tint del_curterm(TERMINAL *)\n */\n\n#include <curses.priv.h>\n#include <termcap.h>\t\t/* ospeed */\n\nMODULE_ID(\"$Id: lib_cur_term.c,v 1.41 2017/06/17 22:21:35 tom Exp $\")\n\n#undef CUR\n#define CUR TerminalType(termp).\n\n#if USE_REENTRANT\n\nNCURSES_EXPORT(TERMINAL *)\nNCURSES_SP_NAME(_nc_get_cur_term) (NCURSES_SP_DCL0)\n{\n    return ((0 != TerminalOf(SP_PARM)) ? TerminalOf(SP_PARM) : CurTerm);\n}\n\n#if NCURSES_SP_FUNCS\n\nNCURSES_EXPORT(TERMINAL *)\n_nc_get_cur_term(void)\n{\n    return NCURSES_SP_NAME(_nc_get_cur_term) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(TERMINAL *)\nNCURSES_PUBLIC_VAR(cur_term) (void)\n{\n#if NCURSES_SP_FUNCS\n    return NCURSES_SP_NAME(_nc_get_cur_term) (CURRENT_SCREEN);\n#else\n    return NCURSES_SP_NAME(_nc_get_cur_term) (NCURSES_SP_ARG);\n#endif\n}\n\n#else\nNCURSES_EXPORT_VAR(TERMINAL *) cur_term = 0;\n#endif\n\nNCURSES_EXPORT(TERMINAL *)\nNCURSES_SP_NAME(set_curterm) (NCURSES_SP_DCLx TERMINAL *termp)\n{\n    TERMINAL *oldterm;\n\n    T((T_CALLED(\"set_curterm(%p)\"), (void *) termp));\n\n    _nc_lock_global(curses);\n    oldterm = cur_term;\n    if (SP_PARM)\n\tSP_PARM->_term = termp;\n#if USE_REENTRANT\n    CurTerm = termp;\n#else\n    cur_term = termp;\n#endif\n    if (termp != 0) {\n#ifdef USE_TERM_DRIVER\n\tTERMINAL_CONTROL_BLOCK *TCB = (TERMINAL_CONTROL_BLOCK *) termp;\n\tospeed = (NCURSES_OSPEED) _nc_ospeed(termp->_baudrate);\n\tif (TCB->drv &&\n\t    TCB->drv->isTerminfo &&\n\t    TerminalType(termp).Strings) {\n\t    PC = (char) ((pad_char != NULL) ? pad_char[0] : 0);\n\t}\n\tTCB->csp = SP_PARM;\n#else\n\tospeed = (NCURSES_OSPEED) _nc_ospeed(termp->_baudrate);\n\tif (TerminalType(termp).Strings) {\n\t    PC = (char) ((pad_char != NULL) ? pad_char[0] : 0);\n\t}\n#endif\n#if !USE_REENTRANT\n\tsave_ttytype(termp);\n#endif\n    }\n    _nc_unlock_global(curses);\n\n    T((T_RETURN(\"%p\"), (void *) oldterm));\n    return (oldterm);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(TERMINAL *)\nset_curterm(TERMINAL *termp)\n{\n    return NCURSES_SP_NAME(set_curterm) (CURRENT_SCREEN, termp);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(del_curterm) (NCURSES_SP_DCLx TERMINAL *termp)\n{\n    int rc = ERR;\n\n    T((T_CALLED(\"del_curterm(%p, %p)\"), (void *) SP_PARM, (void *) termp));\n\n    if (termp != 0) {\n#ifdef USE_TERM_DRIVER\n\tTERMINAL_CONTROL_BLOCK *TCB = (TERMINAL_CONTROL_BLOCK *) termp;\n#endif\n\tTERMINAL *cur = (\n#if USE_REENTRANT\n\t\t\t    NCURSES_SP_NAME(_nc_get_cur_term) (NCURSES_SP_ARG)\n#else\n\t\t\t    cur_term\n#endif\n\t);\n\n#if NCURSES_EXT_NUMBERS\n\t_nc_free_termtype(&termp->type);\n#endif\n\t_nc_free_termtype2(&TerminalType(termp));\n\tif (termp == cur)\n\t    NCURSES_SP_NAME(set_curterm) (NCURSES_SP_ARGx 0);\n\n\tFreeIfNeeded(termp->_termname);\n#if USE_HOME_TERMINFO\n\tif (_nc_globals.home_terminfo != 0) {\n\t    FreeAndNull(_nc_globals.home_terminfo);\n\t}\n#endif\n#ifdef USE_TERM_DRIVER\n\tif (TCB->drv)\n\t    TCB->drv->td_release(TCB);\n#endif\n#if NO_LEAKS\n\t/* discard memory used in tgetent's cache for this terminal */\n\t_nc_tgetent_leak(termp);\n#endif\n\tfree(termp);\n\n\trc = OK;\n    }\n    returnCode(rc);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ndel_curterm(TERMINAL *termp)\n{\n    int rc;\n\n    _nc_lock_global(curses);\n    rc = NCURSES_SP_NAME(del_curterm) (CURRENT_SCREEN, termp);\n    _nc_unlock_global(curses);\n\n    return (rc);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                                                 *\n ****************************************************************************/\n\n/*\n**\tlib_data.c\n**\n**\tCommon data that may/may not be allocated, but is referenced globally\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_data.c,v 1.75 2017/08/04 08:59:48 tom Exp $\")\n\n/*\n * OS/2's native linker complains if we don't initialize public data when\n * constructing a dll (reported by J.J.G.Ripoll).\n */\n#if USE_REENTRANT\nNCURSES_EXPORT(WINDOW *)\nNCURSES_PUBLIC_VAR(stdscr) (void)\n{\n    return CURRENT_SCREEN ? StdScreen(CURRENT_SCREEN) : 0;\n}\nNCURSES_EXPORT(WINDOW *)\nNCURSES_PUBLIC_VAR(curscr) (void)\n{\n    return CURRENT_SCREEN ? CurScreen(CURRENT_SCREEN) : 0;\n}\nNCURSES_EXPORT(WINDOW *)\nNCURSES_PUBLIC_VAR(newscr) (void)\n{\n    return CURRENT_SCREEN ? NewScreen(CURRENT_SCREEN) : 0;\n}\n#else\nNCURSES_EXPORT_VAR(WINDOW *) stdscr = 0;\nNCURSES_EXPORT_VAR(WINDOW *) curscr = 0;\nNCURSES_EXPORT_VAR(WINDOW *) newscr = 0;\n#endif\n\nNCURSES_EXPORT_VAR(SCREEN *) _nc_screen_chain = 0;\n\n/*\n * The variable 'SP' will be defined as a function on systems that cannot link\n * data-only modules, since it is used in a lot of places within ncurses and we\n * cannot guarantee that any application will use any particular function.  We\n * put the WINDOW variables in this module, because it appears that any\n * application that uses them will also use 'SP'.\n *\n * This module intentionally does not reference other ncurses modules, to avoid\n * module coupling that increases the size of the executable.\n */\n#if BROKEN_LINKER\nstatic SCREEN *my_screen;\n\nNCURSES_EXPORT(SCREEN *)\n_nc_screen(void)\n{\n    return my_screen;\n}\n\nNCURSES_EXPORT(int)\n_nc_alloc_screen(void)\n{\n    my_screen = _nc_alloc_screen_sp();\n    T((\"_nc_alloc_screen_sp %p\", my_screen));\n    return (my_screen != 0);\n}\n\nNCURSES_EXPORT(void)\n_nc_set_screen(SCREEN *sp)\n{\n    my_screen = sp;\n}\n\n#else\n\nNCURSES_EXPORT_VAR(SCREEN *) SP = NULL; /* Some linkers require initialized data... */\n#endif\n/* *INDENT-OFF* */\n#define CHARS_0s { '\\0' }\n\n#define TGETENT_0 { 0L, FALSE, NULL, NULL, NULL }\n#define TGETENT_0s { TGETENT_0, TGETENT_0, TGETENT_0, TGETENT_0 }\n\nNCURSES_EXPORT_VAR(NCURSES_GLOBALS) _nc_globals = {\n    0,\t\t\t\t/* have_sigtstp */\n    0,\t\t\t\t/* have_sigwinch */\n    0,\t\t\t\t/* cleanup_nested */\n\n    FALSE,\t\t\t/* init_signals */\n    FALSE,\t\t\t/* init_screen */\n\n    NULL,\t\t\t/* comp_sourcename */\n    NULL,\t\t\t/* comp_termtype */\n\n    FALSE,\t\t\t/* have_tic_directory */\n    FALSE,\t\t\t/* keep_tic_directory */\n    0,\t\t\t\t/* tic_directory */\n\n    NULL,\t\t\t/* dbi_list */\n    0,\t\t\t\t/* dbi_size */\n\n    NULL,\t\t\t/* first_name */\n    NULL,\t\t\t/* keyname_table */\n    0,\t\t\t\t/* init_keyname */\n\n    0,\t\t\t\t/* slk_format */\n\n    NULL,\t\t\t/* safeprint_buf */\n    0,\t\t\t\t/* safeprint_used */\n\n    TGETENT_0s,\t\t\t/* tgetent_cache */\n    0,\t\t\t\t/* tgetent_index */\n    0,\t\t\t\t/* tgetent_sequence */\n\n    0,\t\t\t\t/* dbd_blob */\n    0,\t\t\t\t/* dbd_list */\n    0,\t\t\t\t/* dbd_size */\n    0,\t\t\t\t/* dbd_time */\n    { { 0, 0 } },\t\t/* dbd_vars */\n\n#ifndef USE_SP_WINDOWLIST\n    0,\t\t\t\t/* _nc_windowlist */\n#endif\n\n#if USE_HOME_TERMINFO\n    NULL,\t\t\t/* home_terminfo */\n#endif\n\n#if !USE_SAFE_SPRINTF\n    0,\t\t\t\t/* safeprint_cols */\n    0,\t\t\t\t/* safeprint_rows */\n#endif\n\n#ifdef USE_TERM_DRIVER\n    0,\t\t\t\t/* term_driver */\n#endif\n\n#ifdef TRACE\n    FALSE,\t\t\t/* trace_opened */\n    CHARS_0s,\t\t\t/* trace_fname */\n    0,\t\t\t\t/* trace_level */\n    NULL,\t\t\t/* trace_fp */\n    -1,\t\t\t\t/* trace_fd */\n\n    NULL,\t\t\t/* tracearg_buf */\n    0,\t\t\t\t/* tracearg_used */\n\n    NULL,\t\t\t/* tracebuf_ptr */\n    0,\t\t\t\t/* tracebuf_used */\n\n    CHARS_0s,\t\t\t/* tracechr_buf */\n\n    NULL,\t\t\t/* tracedmp_buf */\n    0,\t\t\t\t/* tracedmp_used */\n\n    NULL,\t\t\t/* tracetry_buf */\n    0,\t\t\t\t/* tracetry_used */\n\n    { CHARS_0s, CHARS_0s },\t/* traceatr_color_buf */\n    0,\t\t\t\t/* traceatr_color_sel */\n    -1,\t\t\t\t/* traceatr_color_last */\n#if !defined(USE_PTHREADS) && USE_REENTRANT\n    0,\t\t\t\t/* nested_tracef */\n#endif\n#endif /* TRACE */\n#if NO_LEAKS\n    FALSE,\t\t\t/* leak_checking */\n#endif\n#ifdef USE_PTHREADS\n    PTHREAD_MUTEX_INITIALIZER,\t/* mutex_curses */\n    PTHREAD_MUTEX_INITIALIZER,\t/* mutex_prescreen */\n    PTHREAD_MUTEX_INITIALIZER,\t/* mutex_screen */\n    PTHREAD_MUTEX_INITIALIZER,\t/* mutex_update */\n    PTHREAD_MUTEX_INITIALIZER,\t/* mutex_tst_tracef */\n    PTHREAD_MUTEX_INITIALIZER,\t/* mutex_tracef */\n    0,\t\t\t\t/* nested_tracef */\n    0,\t\t\t\t/* use_pthreads */\n#endif\n#if USE_PTHREADS_EINTR\n    0,\t\t\t\t/* read_thread */\n#endif\n#if USE_WIDEC_SUPPORT\n    CHARS_0s,\t\t\t/* key_name */\n#endif\n};\n\n#define STACK_FRAME_0\t{ { 0 }, 0 }\n#define STACK_FRAME_0s\t{ STACK_FRAME_0 }\n#define NUM_VARS_0s\t{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }\n\n#define RIPOFF_0\t{ 0,0,0 }\n#define RIPOFF_0s\t{ RIPOFF_0 }\n\nNCURSES_EXPORT_VAR(NCURSES_PRESCREEN) _nc_prescreen = {\n    NULL,\t\t\t/* allocated */\n    TRUE,\t\t\t/* use_env */\n    FALSE,\t\t\t/* filter_mode */\n    A_NORMAL,\t\t\t/* previous_attr */\n#ifndef USE_SP_RIPOFF\n    RIPOFF_0s,\t\t\t/* ripoff */\n    NULL,\t\t\t/* rsp */\n#endif\n    {\t\t\t\t/* tparm_state */\n#ifdef TRACE\n\tNULL,\t\t\t/* tname */\n#endif\n\tNULL,\t\t\t/* tparam_base */\n\n\tSTACK_FRAME_0s,\t\t/* stack */\n\t0,\t\t\t/* stack_ptr */\n\n\tNULL,\t\t\t/* out_buff */\n\t0,\t\t\t/* out_size */\n\t0,\t\t\t/* out_used */\n\n\tNULL,\t\t\t/* fmt_buff */\n\t0,\t\t\t/* fmt_size */\n\n\tNUM_VARS_0s,\t\t/* dynamic_var */\n\tNUM_VARS_0s,\t\t/* static_vars */\n    },\n    NULL,\t\t\t/* saved_tty */\n#if NCURSES_NO_PADDING\n    FALSE,\t\t\t/* flag to set if padding disabled  */\n#endif\n    0,\t\t\t\t/* _outch */\n#if BROKEN_LINKER || USE_REENTRANT\n    NULL,\t\t\t/* real_acs_map */\n    0,\t\t\t\t/* LINES */\n    0,\t\t\t\t/* COLS */\n    8,\t\t\t\t/* TABSIZE */\n    1000,\t\t\t/* ESCDELAY */\n    0,\t\t\t\t/* cur_term */\n#ifdef TRACE\n    0L,\t\t\t\t/* _outchars */\n    NULL,\t\t\t/* _tputs_trace */\n#endif\n#endif\n    FALSE,\t\t\t/* use_tioctl */\n};\n/* *INDENT-ON* */\n\n/*\n * wgetch() and other functions with a WINDOW* parameter may use a SCREEN*\n * internally, and it is useful to allow those to be invoked without switching\n * SCREEN's, e.g., for multi-threaded applications.\n */\nNCURSES_EXPORT(SCREEN *)\n_nc_screen_of(WINDOW *win)\n{\n    SCREEN *sp = 0;\n\n    if (win != 0) {\n\tsp = WINDOW_EXT(win, screen);\n    }\n    return (sp);\n}\n\n/******************************************************************************/\n#ifdef USE_PTHREADS\nstatic void\ninit_global_mutexes(void)\n{\n    static bool initialized = FALSE;\n\n    if (!initialized) {\n\tinitialized = TRUE;\n\t_nc_mutex_init(&_nc_globals.mutex_curses);\n\t_nc_mutex_init(&_nc_globals.mutex_prescreen);\n\t_nc_mutex_init(&_nc_globals.mutex_screen);\n\t_nc_mutex_init(&_nc_globals.mutex_update);\n\t_nc_mutex_init(&_nc_globals.mutex_tst_tracef);\n\t_nc_mutex_init(&_nc_globals.mutex_tracef);\n    }\n}\n\nNCURSES_EXPORT(void)\n_nc_init_pthreads(void)\n{\n    if (_nc_use_pthreads)\n\treturn;\n# if USE_WEAK_SYMBOLS\n    if ((pthread_mutex_init) == 0)\n\treturn;\n    if ((pthread_mutex_lock) == 0)\n\treturn;\n    if ((pthread_mutex_unlock) == 0)\n\treturn;\n    if ((pthread_mutex_trylock) == 0)\n\treturn;\n    if ((pthread_mutexattr_settype) == 0)\n\treturn;\n# endif\n    _nc_use_pthreads = 1;\n    init_global_mutexes();\n}\n\n/*\n * Use recursive mutexes if we have them - they're part of Unix98.\n * For the cases where we do not, _nc_mutex_trylock() is used to avoid a\n * deadlock, at the expense of memory leaks and unexpected failures that\n * may not be handled by typical clients.\n *\n * FIXME - need configure check for PTHREAD_MUTEX_RECURSIVE, define it to\n * PTHREAD_MUTEX_NORMAL if not supported.\n */\nNCURSES_EXPORT(void)\n_nc_mutex_init(pthread_mutex_t * obj)\n{\n    pthread_mutexattr_t recattr;\n\n    if (_nc_use_pthreads) {\n\tpthread_mutexattr_init(&recattr);\n\tpthread_mutexattr_settype(&recattr, PTHREAD_MUTEX_RECURSIVE);\n\tpthread_mutex_init(obj, &recattr);\n    }\n}\n\nNCURSES_EXPORT(int)\n_nc_mutex_lock(pthread_mutex_t * obj)\n{\n    if (_nc_use_pthreads == 0)\n\treturn 0;\n    return pthread_mutex_lock(obj);\n}\n\nNCURSES_EXPORT(int)\n_nc_mutex_trylock(pthread_mutex_t * obj)\n{\n    if (_nc_use_pthreads == 0)\n\treturn 0;\n    return pthread_mutex_trylock(obj);\n}\n\nNCURSES_EXPORT(int)\n_nc_mutex_unlock(pthread_mutex_t * obj)\n{\n    if (_nc_use_pthreads == 0)\n\treturn 0;\n    return pthread_mutex_unlock(obj);\n}\n#endif /* USE_PTHREADS */\n\n#if defined(USE_PTHREADS) || USE_PTHREADS_EINTR\n#if USE_WEAK_SYMBOLS\n/*\n * NB: sigprocmask(2) is global but pthread_sigmask(3p)\n * only for the calling thread.\n */\nNCURSES_EXPORT(int)\n_nc_sigprocmask(int how, const sigset_t * newmask, sigset_t * oldmask)\n{\n    if ((pthread_sigmask))\n\treturn pthread_sigmask(how, newmask, oldmask);\n    else\n\treturn (sigprocmask) (how, newmask, oldmask);\n}\n#endif\n#endif /* USE_PTHREADS */\n","/****************************************************************************\n * Copyright (c) 1998-2009,2013 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-2003               *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n**\tlib_has_cap.c\n**\n**\tThe routines to query terminal capabilities\n**\n*/\n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_has_cap.c,v 1.10 2013/11/16 19:57:22 tom Exp $\")\n\nNCURSES_EXPORT(bool)\nNCURSES_SP_NAME(has_ic) (NCURSES_SP_DCL0)\n{\n    bool code = FALSE;\n\n    T((T_CALLED(\"has_ic(%p)\"), (void *) SP_PARM));\n\n    if (HasTInfoTerminal(SP_PARM)) {\n\tcode = ((insert_character || parm_ich\n\t\t || (enter_insert_mode && exit_insert_mode))\n\t\t&& (delete_character || parm_dch)) ? TRUE : FALSE;\n    }\n\n    returnCode(code);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(bool)\nhas_ic(void)\n{\n    return NCURSES_SP_NAME(has_ic) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(bool)\nNCURSES_SP_NAME(has_il) (NCURSES_SP_DCL0)\n{\n    bool code = FALSE;\n    T((T_CALLED(\"has_il(%p)\"), (void *) SP_PARM));\n    if (HasTInfoTerminal(SP_PARM)) {\n\tcode = ((insert_line || parm_insert_line)\n\t\t&& (delete_line || parm_delete_line)) ? TRUE : FALSE;\n    }\n\n    returnCode(code);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(bool)\nhas_il(void)\n{\n    return NCURSES_SP_NAME(has_il) (CURRENT_SCREEN);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2009,2010 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        2002                    *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n *\tlib_kernel.c\n *\n *\tMisc. low-level routines:\n *\t\terasechar()\n *\t\tkillchar()\n *\t\tflushinp()\n *\n * The baudrate() and delay_output() functions could logically live here,\n * but are in other modules to reduce the static-link size of programs\n * that use only these facilities.\n */\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_kernel.c,v 1.31 2010/12/19 01:21:19 tom Exp $\")\n\nstatic int\n_nc_vdisable(void)\n{\n    int value = -1;\n#if defined(_POSIX_VDISABLE) && HAVE_UNISTD_H\n    value = _POSIX_VDISABLE;\n#endif\n#if defined(_PC_VDISABLE)\n    if (value == -1) {\n\tvalue = (int) fpathconf(0, _PC_VDISABLE);\n\tif (value == -1) {\n\t    value = 0377;\n\t}\n    }\n#elif defined(VDISABLE)\n    if (value == -1)\n\tvalue = VDISABLE;\n#endif\n    return value;\n}\n\n/*\n *\terasechar()\n *\n *\tReturn erase character as given in cur_term->Ottyb.\n *\n */\n\nNCURSES_EXPORT(char)\nNCURSES_SP_NAME(erasechar) (NCURSES_SP_DCL0)\n{\n    int result = ERR;\n    TERMINAL *termp = TerminalOf(SP_PARM);\n\n    T((T_CALLED(\"erasechar(%p)\"), (void *) SP_PARM));\n\n    if (termp != 0) {\n#ifdef TERMIOS\n\tresult = termp->Ottyb.c_cc[VERASE];\n\tif (result == _nc_vdisable())\n\t    result = ERR;\n#else\n\tresult = termp->Ottyb.sg_erase;\n#endif\n    }\n    returnChar((char) result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(char)\nerasechar(void)\n{\n    return NCURSES_SP_NAME(erasechar) (CURRENT_SCREEN);\n}\n#endif\n\n/*\n *\tkillchar()\n *\n *\tReturn kill character as given in cur_term->Ottyb.\n *\n */\n\nNCURSES_EXPORT(char)\nNCURSES_SP_NAME(killchar) (NCURSES_SP_DCL0)\n{\n    int result = ERR;\n    TERMINAL *termp = TerminalOf(SP_PARM);\n\n    T((T_CALLED(\"killchar(%p)\"), (void *) SP_PARM));\n\n    if (termp != 0) {\n#ifdef TERMIOS\n\tresult = termp->Ottyb.c_cc[VKILL];\n\tif (result == _nc_vdisable())\n\t    result = ERR;\n#else\n\tresult = termp->Ottyb.sg_kill;\n#endif\n    }\n    returnChar((char) result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(char)\nkillchar(void)\n{\n    return NCURSES_SP_NAME(killchar) (CURRENT_SCREEN);\n}\n#endif\n\n/*\n *\tflushinp()\n *\n *\tFlush any input on cur_term->Filedes\n *\n */\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(flushinp) (NCURSES_SP_DCL0)\n{\n    TERMINAL *termp = TerminalOf(SP_PARM);\n\n    T((T_CALLED(\"flushinp(%p)\"), (void *) SP_PARM));\n\n    if (termp != 0) {\n#ifdef TERMIOS\n\ttcflush(termp->Filedes, TCIFLUSH);\n#else\n\terrno = 0;\n\tdo {\n\t    ioctl(termp->Filedes, TIOCFLUSH, 0);\n\t} while\n\t    (errno == EINTR);\n#endif\n\tif (SP_PARM) {\n\t    SP_PARM->_fifohead = -1;\n\t    SP_PARM->_fifotail = 0;\n\t    SP_PARM->_fifopeek = 0;\n\t}\n\treturnCode(OK);\n    }\n    returnCode(ERR);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nflushinp(void)\n{\n    return NCURSES_SP_NAME(flushinp) (CURRENT_SCREEN);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2014,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n *\tlib_napms.c\n *\n *\tThe routine napms.\n *\n *\t(This file was originally written by Eric Raymond; however except for\n *\tcomments, none of the original code remains - T.Dickey).\n */\n\n#include <curses.priv.h>\n\n#if HAVE_NANOSLEEP\n#include <time.h>\n#if HAVE_SYS_TIME_H\n#include <sys/time.h>\t\t/* needed for MacOS X DP3 */\n#endif\n#endif\n\nMODULE_ID(\"$Id: lib_napms.c,v 1.25 2017/07/01 21:05:56 tom Exp $\")\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(napms) (NCURSES_SP_DCLx int ms)\n{\n    T((T_CALLED(\"napms(%d)\"), ms));\n\n#ifdef USE_TERM_DRIVER\n    CallDriver_1(SP_PARM, td_nap, ms);\n#else /* !USE_TERM_DRIVER */\n#if NCURSES_SP_FUNCS\n    (void) sp;\n#endif\n#if HAVE_NANOSLEEP\n    {\n\tstruct timespec request, remaining;\n\trequest.tv_sec = ms / 1000;\n\trequest.tv_nsec = (ms % 1000) * 1000000;\n\twhile (nanosleep(&request, &remaining) == -1\n\t       && errno == EINTR) {\n\t    request = remaining;\n\t}\n    }\n#else\n    _nc_timed_wait(0, 0, ms, (int *) 0 EVENTLIST_2nd(0));\n#endif\n#endif /* !USE_TERM_DRIVER */\n\n    returnCode(OK);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nnapms(int ms)\n{\n    return NCURSES_SP_NAME(napms) (CURRENT_SCREEN, ms);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2014,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n**\tlib_options.c\n**\n**\tThe routines to handle option setting.\n**\n*/\n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_options.c,v 1.80 2017/06/24 23:13:09 tom Exp $\")\n\nNCURSES_EXPORT(int)\nidlok(WINDOW *win, bool flag)\n{\n    int res = ERR;\n    T((T_CALLED(\"idlok(%p,%d)\"), (void *) win, flag));\n\n    if (win) {\n\tSCREEN *sp = _nc_screen_of(win);\n\tif (sp != 0\n#ifdef USE_TERM_DRIVER\n\t    && IsTermInfo(sp)\n#endif\n\t    ) {\n\t    sp->_nc_sp_idlok =\n\t\twin->_idlok = (flag && (NCURSES_SP_NAME(has_il) (NCURSES_SP_ARG)\n\t\t\t\t\t|| change_scroll_region));\n\t    res = OK;\n\t}\n    }\n    returnCode(res);\n}\n\nNCURSES_EXPORT(void)\nidcok(WINDOW *win, bool flag)\n{\n    T((T_CALLED(\"idcok(%p,%d)\"), (void *) win, flag));\n\n    if (win) {\n\tSCREEN *sp = _nc_screen_of(win);\n\tsp->_nc_sp_idcok = win->_idcok = (flag && NCURSES_SP_NAME(has_ic) (NCURSES_SP_ARG));\n    }\n    returnVoid;\n}\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(halfdelay) (NCURSES_SP_DCLx int t)\n{\n    T((T_CALLED(\"halfdelay(%p,%d)\"), (void *) SP_PARM, t));\n\n    if (t < 1 || t > 255 || !SP_PARM || !IsValidTIScreen(SP_PARM))\n\treturnCode(ERR);\n\n    NCURSES_SP_NAME(cbreak) (NCURSES_SP_ARG);\n    SP_PARM->_cbreak = t + 1;\n    returnCode(OK);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nhalfdelay(int t)\n{\n    return NCURSES_SP_NAME(halfdelay) (CURRENT_SCREEN, t);\n}\n#endif\n\nNCURSES_EXPORT(int)\nnodelay(WINDOW *win, bool flag)\n{\n    T((T_CALLED(\"nodelay(%p,%d)\"), (void *) win, flag));\n\n    if (win) {\n\tif (flag == TRUE)\n\t    win->_delay = 0;\n\telse\n\t    win->_delay = -1;\n\treturnCode(OK);\n    } else\n\treturnCode(ERR);\n}\n\nNCURSES_EXPORT(int)\nnotimeout(WINDOW *win, bool f)\n{\n    T((T_CALLED(\"notimeout(%p,%d)\"), (void *) win, f));\n\n    if (win) {\n\twin->_notimeout = f;\n\treturnCode(OK);\n    } else\n\treturnCode(ERR);\n}\n\nNCURSES_EXPORT(void)\nwtimeout(WINDOW *win, int delay)\n{\n    T((T_CALLED(\"wtimeout(%p,%d)\"), (void *) win, delay));\n\n    if (win) {\n\twin->_delay = delay;\n    }\n    returnVoid;\n}\n\nNCURSES_EXPORT(int)\nkeypad(WINDOW *win, bool flag)\n{\n    T((T_CALLED(\"keypad(%p,%d)\"), (void *) win, flag));\n\n    if (win) {\n\twin->_use_keypad = flag;\n\treturnCode(_nc_keypad(_nc_screen_of(win), flag));\n    } else\n\treturnCode(ERR);\n}\n\nNCURSES_EXPORT(int)\nmeta(WINDOW *win GCC_UNUSED, bool flag)\n{\n    int result = ERR;\n    SCREEN *sp = (win == 0) ? CURRENT_SCREEN : _nc_screen_of(win);\n\n    /* Ok, we stay relaxed and don't signal an error if win is NULL */\n    T((T_CALLED(\"meta(%p,%d)\"), (void *) win, flag));\n\n    /* Ok, we stay relaxed and don't signal an error if win is NULL */\n\n    if (sp != 0) {\n\tsp->_use_meta = flag;\n#ifdef USE_TERM_DRIVER\n\tif (IsTermInfo(sp)) {\n\t    if (flag) {\n\t\tNCURSES_PUTP2(\"meta_on\", meta_on);\n\t    } else {\n\t\tNCURSES_PUTP2(\"meta_off\", meta_off);\n\t    }\n\t}\n#else\n\tif (flag) {\n\t    NCURSES_PUTP2(\"meta_on\", meta_on);\n\t} else {\n\t    NCURSES_PUTP2(\"meta_off\", meta_off);\n\t}\n#endif\n\tresult = OK;\n    }\n    returnCode(result);\n}\n\n/* curs_set() moved here to narrow the kernel interface */\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(curs_set) (NCURSES_SP_DCLx int vis)\n{\n    int code = ERR;\n    T((T_CALLED(\"curs_set(%p,%d)\"), (void *) SP_PARM, vis));\n\n    if (SP_PARM != 0 && vis >= 0 && vis <= 2) {\n\tint cursor = SP_PARM->_cursor;\n\tif (vis == cursor) {\n\t    code = cursor;\n\t} else {\n#ifdef USE_TERM_DRIVER\n\t    code = CallDriver_1(SP_PARM, td_cursorSet, vis);\n#else\n\t    if (IsValidTIScreen(SP_PARM)) {\n\t\tswitch (vis) {\n\t\tcase 2:\n\t\t    code = NCURSES_PUTP2_FLUSH(\"cursor_visible\",\n\t\t\t\t\t       cursor_visible);\n\t\t    break;\n\t\tcase 1:\n\t\t    code = NCURSES_PUTP2_FLUSH(\"cursor_normal\",\n\t\t\t\t\t       cursor_normal);\n\t\t    break;\n\t\tcase 0:\n\t\t    code = NCURSES_PUTP2_FLUSH(\"cursor_invisible\",\n\t\t\t\t\t       cursor_invisible);\n\t\t    break;\n\t\t}\n\t    } else {\n\t\tcode = ERR;\n\t    }\n#endif\n\t    if (code != ERR)\n\t\tcode = (cursor == -1 ? 1 : cursor);\n\t    SP_PARM->_cursor = vis;\n\t}\n    }\n    returnCode(code);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ncurs_set(int vis)\n{\n    return (NCURSES_SP_NAME(curs_set) (CURRENT_SCREEN, vis));\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(typeahead) (NCURSES_SP_DCLx int fd)\n{\n    T((T_CALLED(\"typeahead(%p, %d)\"), (void *) SP_PARM, fd));\n    if (SP_PARM && IsValidTIScreen(SP_PARM)) {\n\tSP_PARM->_checkfd = fd;\n\treturnCode(OK);\n    } else {\n\treturnCode(ERR);\n    }\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ntypeahead(int fd)\n{\n    return NCURSES_SP_NAME(typeahead) (CURRENT_SCREEN, fd);\n}\n#endif\n\n/*\n**      has_key()\n**\n**      Return TRUE if the current terminal has the given key\n**\n*/\n\n#if NCURSES_EXT_FUNCS\nstatic int\nhas_key_internal(int keycode, TRIES * tp)\n{\n    if (tp == 0)\n\treturn (FALSE);\n    else if (tp->value == keycode)\n\treturn (TRUE);\n    else\n\treturn (has_key_internal(keycode, tp->child)\n\t\t|| has_key_internal(keycode, tp->sibling));\n}\n\n#ifdef USE_TERM_DRIVER\nNCURSES_EXPORT(int)\nTINFO_HAS_KEY(SCREEN *sp, int keycode)\n{\n    return IsValidTIScreen(sp) ?\n\thas_key_internal(keycode, sp->_keytry) : 0;\n}\n#else\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(has_key) (NCURSES_SP_DCLx int keycode)\n{\n    T((T_CALLED(\"has_key(%p,%d)\"), (void *) SP_PARM, keycode));\n    returnCode(SP != 0 ? has_key_internal(keycode, SP_PARM->_keytry) : FALSE);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nhas_key(int keycode)\n{\n    return NCURSES_SP_NAME(has_key) (CURRENT_SCREEN, keycode);\n}\n#endif\n#endif\n#endif /* NCURSES_EXT_FUNCS */\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_putp_flush) (NCURSES_SP_DCLx\n\t\t\t\t const char *name, const char *value)\n{\n    int rc = NCURSES_PUTP2(name, value);\n    if (rc != ERR) {\n\t_nc_flush();\n    }\n    return rc;\n}\n\n#if 0 && NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_putp_flush(const char *name, const char *value)\n{\n    return NCURSES_SP_NAME(_nc_putp_flush) (CURRENT_SCREEN, name, value);\n}\n#endif\n\n/* Turn the keypad on/off\n *\n * Note:  we flush the output because changing this mode causes some terminals\n * to emit different escape sequences for cursor and keypad keys.  If we don't\n * flush, then the next wgetch may get the escape sequence that corresponds to\n * the terminal state _before_ switching modes.\n */\nNCURSES_EXPORT(int)\n_nc_keypad(SCREEN *sp, int flag)\n{\n    int rc = ERR;\n\n    if (sp != 0) {\n#ifdef USE_PTHREADS\n\t/*\n\t * We might have this situation in a multithreaded application that\n\t * has wgetch() reading in more than one thread.  putp() and below\n\t * may use SP explicitly.\n\t */\n\tif (_nc_use_pthreads && sp != CURRENT_SCREEN) {\n\t    SCREEN *save_sp;\n\n\t    /* cannot use use_screen(), since that is not in tinfo library */\n\t    _nc_lock_global(curses);\n\t    save_sp = CURRENT_SCREEN;\n\t    _nc_set_screen(sp);\n\t    rc = _nc_keypad(sp, flag);\n\t    _nc_set_screen(save_sp);\n\t    _nc_unlock_global(curses);\n\t} else\n#endif\n\t{\n#ifdef USE_TERM_DRIVER\n\t    rc = CallDriver_1(sp, td_kpad, flag);\n\t    if (rc == OK)\n\t\tsp->_keypad_on = flag;\n#else\n\t    if (flag) {\n\t\t(void) NCURSES_PUTP2_FLUSH(\"keypad_xmit\", keypad_xmit);\n\t    } else if (!flag && keypad_local) {\n\t\t(void) NCURSES_PUTP2_FLUSH(\"keypad_local\", keypad_local);\n\t    }\n\n\t    if (flag && !sp->_tried) {\n\t\t_nc_init_keytry(sp);\n\t\tsp->_tried = TRUE;\n\t    }\n\t    sp->_keypad_on = flag;\n\t    rc = OK;\n#endif\n\t}\n    }\n    return (rc);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1998-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n *\traw.c\n *\n *\tRoutines:\n *\t\traw()\n *\t\tcbreak()\n *\t\tnoraw()\n *\t\tnocbreak()\n *\t\tqiflush()\n *\t\tnoqiflush()\n *\t\tintrflush()\n *\n */\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_raw.c,v 1.23 2017/04/15 22:24:45 tom Exp $\")\n\n#if HAVE_SYS_TERMIO_H\n#include <sys/termio.h>\t\t/* needed for ISC */\n#endif\n\n#ifdef __EMX__\n#include <io.h>\n#define _nc_setmode(mode) setmode(SP_PARM->_ifd, mode)\n#else\n#define _nc_setmode(mode)\t/* nothing */\n#endif\n\n#if USE_KLIBC_KBD\n#define INCL_KBD\n#include <os2.h>\n#endif\n\n#define COOKED_INPUT\t(IXON|BRKINT|PARMRK)\n\n#ifdef TRACE\n#define BEFORE(N)\tif (USE_TRACEF(TRACE_BITS)) _nc_locked_tracef(\"%s before bits: %s\", N, _nc_tracebits())\n#define AFTER(N)\tif (USE_TRACEF(TRACE_BITS)) _nc_locked_tracef(\"%s after bits: %s\", N, _nc_tracebits())\n#else\n#define BEFORE(s)\n#define AFTER(s)\n#endif /* TRACE */\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(raw) (NCURSES_SP_DCL0)\n{\n    int result = ERR;\n    TERMINAL *termp;\n\n    T((T_CALLED(\"raw(%p)\"), (void *) SP_PARM));\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\n\tBEFORE(\"raw\");\n\t_nc_setmode(O_BINARY);\n\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tbuf.c_lflag &= (unsigned) ~(ICANON | ISIG | IEXTEN);\n\tbuf.c_iflag &= (unsigned) ~(COOKED_INPUT);\n\tbuf.c_cc[VMIN] = 1;\n\tbuf.c_cc[VTIME] = 0;\n#else\n\tbuf.sg_flags |= RAW;\n#endif\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n\tif (result == OK) {\n#if USE_KLIBC_KBD\n\t    KBDINFO kbdinfo;\n\n\t    kbdinfo.cb = sizeof(kbdinfo);\n\t    KbdGetStatus(&kbdinfo, 0);\n\n\t    kbdinfo.cb = sizeof(kbdinfo);\n\t    kbdinfo.fsMask &= ~KEYBOARD_ASCII_MODE;\n\t    kbdinfo.fsMask |= KEYBOARD_BINARY_MODE;\n\t    KbdSetStatus(&kbdinfo, 0);\n#endif\n\t    if (SP_PARM) {\n\t\tSP_PARM->_raw = TRUE;\n\t\tSP_PARM->_cbreak = 1;\n\t    }\n\t    termp->Nttyb = buf;\n\t}\n\tAFTER(\"raw\");\n    }\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nraw(void)\n{\n    return NCURSES_SP_NAME(raw) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(cbreak) (NCURSES_SP_DCL0)\n{\n    int result = ERR;\n    TERMINAL *termp;\n\n    T((T_CALLED(\"cbreak(%p)\"), (void *) SP_PARM));\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\n\tBEFORE(\"cbreak\");\n\t_nc_setmode(O_BINARY);\n\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tbuf.c_lflag &= (unsigned) ~ICANON;\n\tbuf.c_iflag &= (unsigned) ~ICRNL;\n\tbuf.c_lflag |= ISIG;\n\tbuf.c_cc[VMIN] = 1;\n\tbuf.c_cc[VTIME] = 0;\n#else\n\tbuf.sg_flags |= CBREAK;\n#endif\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n\tif (result == OK) {\n\t    if (SP_PARM) {\n\t\tSP_PARM->_cbreak = 1;\n\t    }\n\t    termp->Nttyb = buf;\n\t}\n\tAFTER(\"cbreak\");\n    }\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ncbreak(void)\n{\n    return NCURSES_SP_NAME(cbreak) (CURRENT_SCREEN);\n}\n#endif\n\n/*\n * Note:\n * this implementation may be wrong.  See the comment under intrflush().\n */\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(qiflush) (NCURSES_SP_DCL0)\n{\n    TERMINAL *termp;\n\n    T((T_CALLED(\"qiflush(%p)\"), (void *) SP_PARM));\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\tint result;\n\n\tBEFORE(\"qiflush\");\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tbuf.c_lflag &= (unsigned) ~(NOFLSH);\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n#else\n\tresult = ERR;\n\t/* FIXME */\n#endif\n\tif (result == OK)\n\t    termp->Nttyb = buf;\n\tAFTER(\"qiflush\");\n    }\n    returnVoid;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\nqiflush(void)\n{\n    NCURSES_SP_NAME(qiflush) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(noraw) (NCURSES_SP_DCL0)\n{\n    int result = ERR;\n    TERMINAL *termp;\n\n    T((T_CALLED(\"noraw(%p)\"), (void *) SP_PARM));\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\n\tBEFORE(\"noraw\");\n\t_nc_setmode(O_TEXT);\n\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tbuf.c_lflag |= ISIG | ICANON |\n\t    (termp->Ottyb.c_lflag & IEXTEN);\n\tbuf.c_iflag |= COOKED_INPUT;\n#else\n\tbuf.sg_flags &= ~(RAW | CBREAK);\n#endif\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n\tif (result == OK) {\n#if USE_KLIBC_KBD\n\t    KBDINFO kbdinfo;\n\n\t    kbdinfo.cb = sizeof(kbdinfo);\n\t    KbdGetStatus(&kbdinfo, 0);\n\n\t    kbdinfo.cb = sizeof(kbdinfo);\n\t    kbdinfo.fsMask &= ~KEYBOARD_BINARY_MODE;\n\t    kbdinfo.fsMask |= KEYBOARD_ASCII_MODE;\n\t    KbdSetStatus(&kbdinfo, 0);\n#endif\n\t    if (SP_PARM) {\n\t\tSP_PARM->_raw = FALSE;\n\t\tSP_PARM->_cbreak = 0;\n\t    }\n\t    termp->Nttyb = buf;\n\t}\n\tAFTER(\"noraw\");\n    }\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nnoraw(void)\n{\n    return NCURSES_SP_NAME(noraw) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(nocbreak) (NCURSES_SP_DCL0)\n{\n    int result = ERR;\n    TERMINAL *termp;\n\n    T((T_CALLED(\"nocbreak(%p)\"), (void *) SP_PARM));\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\n\tBEFORE(\"nocbreak\");\n\t_nc_setmode(O_TEXT);\n\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tbuf.c_lflag |= ICANON;\n\tbuf.c_iflag |= ICRNL;\n#else\n\tbuf.sg_flags &= ~CBREAK;\n#endif\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n\tif (result == OK) {\n\t    if (SP_PARM) {\n\t\tSP_PARM->_cbreak = 0;\n\t    }\n\t    termp->Nttyb = buf;\n\t}\n\tAFTER(\"nocbreak\");\n    }\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nnocbreak(void)\n{\n    return NCURSES_SP_NAME(nocbreak) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(noqiflush) (NCURSES_SP_DCL0)\n{\n    TERMINAL *termp;\n\n    T((T_CALLED(\"noqiflush(%p)\"), (void *) SP_PARM));\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\tint result;\n\n\tBEFORE(\"noqiflush\");\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tbuf.c_lflag |= NOFLSH;\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n#else\n\t/* FIXME */\n\tresult = ERR;\n#endif\n\tif (result == OK)\n\t    termp->Nttyb = buf;\n\tAFTER(\"noqiflush\");\n    }\n    returnVoid;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\nnoqiflush(void)\n{\n    NCURSES_SP_NAME(noqiflush) (CURRENT_SCREEN);\n}\n#endif\n\n/*\n * This call does the same thing as the qiflush()/noqiflush() pair.  We know\n * for certain that SVr3 intrflush() tweaks the NOFLSH bit; on the other hand,\n * the match (in the SVr4 man pages) between the language describing NOFLSH in\n * termio(7) and the language describing qiflush()/noqiflush() in\n * curs_inopts(3x) is too exact to be coincidence.\n */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(intrflush) (NCURSES_SP_DCLx WINDOW *win GCC_UNUSED, bool flag)\n{\n    int result = ERR;\n    TERMINAL *termp;\n\n    T((T_CALLED(\"intrflush(%p,%d)\"), (void *) SP_PARM, flag));\n    if (SP_PARM == 0)\n\treturnCode(ERR);\n\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\n\tBEFORE(\"intrflush\");\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tif (flag)\n\t    buf.c_lflag &= (unsigned) ~(NOFLSH);\n\telse\n\t    buf.c_lflag |= (NOFLSH);\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n#else\n\t/* FIXME */\n#endif\n\tif (result == OK) {\n\t    termp->Nttyb = buf;\n\t}\n\tAFTER(\"intrflush\");\n    }\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nintrflush(WINDOW *win GCC_UNUSED, bool flag)\n{\n    return NCURSES_SP_NAME(intrflush) (CURRENT_SCREEN, win, flag);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n * Terminal setup routines common to termcap and terminfo:\n *\n *\t\tuse_env(bool)\n *\t\tuse_tioctl(bool)\n *\t\tsetupterm(char *, int, int *)\n */\n\n#include <curses.priv.h>\n#include <tic.h>\t\t/* for MAX_NAME_SIZE */\n\n#if HAVE_LOCALE_H\n#include <locale.h>\n#endif\n\nMODULE_ID(\"$Id: lib_setup.c,v 1.188 2017/07/01 18:24:50 tom Exp $\")\n\n/****************************************************************************\n *\n * Terminal size computation\n *\n ****************************************************************************/\n\n#if HAVE_SIZECHANGE\n# if !defined(sun) || !TERMIOS\n#  if HAVE_SYS_IOCTL_H\n#   include <sys/ioctl.h>\n#  endif\n# endif\n#endif\n\n#if NEED_PTEM_H\n /* On SCO, they neglected to define struct winsize in termios.h -- it's only\n  * in termio.h and ptem.h (the former conflicts with other definitions).\n  */\n# include <sys/stream.h>\n# include <sys/ptem.h>\n#endif\n\n#if HAVE_LANGINFO_CODESET\n#include <langinfo.h>\n#endif\n\n/*\n * SCO defines TIOCGSIZE and the corresponding struct.  Other systems (SunOS,\n * Solaris, IRIX) define TIOCGWINSZ and struct winsize.\n */\n#ifdef TIOCGSIZE\n# define IOCTL_WINSIZE TIOCGSIZE\n# define STRUCT_WINSIZE struct ttysize\n# define WINSIZE_ROWS(n) (int)n.ts_lines\n# define WINSIZE_COLS(n) (int)n.ts_cols\n#else\n# ifdef TIOCGWINSZ\n#  define IOCTL_WINSIZE TIOCGWINSZ\n#  define STRUCT_WINSIZE struct winsize\n#  define WINSIZE_ROWS(n) (int)n.ws_row\n#  define WINSIZE_COLS(n) (int)n.ws_col\n# endif\n#endif\n\n/*\n * Reduce explicit use of \"cur_term\" global variable.\n */\n#undef CUR\n#define CUR TerminalType(termp).\n\n/*\n * Wrap global variables in this module.\n */\n#if USE_REENTRANT\n\nNCURSES_EXPORT(char *)\nNCURSES_PUBLIC_VAR(ttytype) (void)\n{\n    static char empty[] = \"\";\n    char *result = empty;\n\n#if NCURSES_SP_FUNCS\n    if (CURRENT_SCREEN) {\n\tTERMINAL *termp = TerminalOf(CURRENT_SCREEN);\n\tif (termp != 0) {\n\t    result = TerminalType(termp).term_names;\n\t}\n    }\n#else\n    if (cur_term != 0) {\n\tresult = TerminalType(cur_term).term_names;\n    }\n#endif\n    return result;\n}\n\nNCURSES_EXPORT(int *)\n_nc_ptr_Lines(SCREEN *sp)\n{\n    return ptrLines(sp);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_PUBLIC_VAR(LINES) (void)\n{\n    return *_nc_ptr_Lines(CURRENT_SCREEN);\n}\n\nNCURSES_EXPORT(int *)\n_nc_ptr_Cols(SCREEN *sp)\n{\n    return ptrCols(sp);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_PUBLIC_VAR(COLS) (void)\n{\n    return *_nc_ptr_Cols(CURRENT_SCREEN);\n}\n\nNCURSES_EXPORT(int *)\n_nc_ptr_Tabsize(SCREEN *sp)\n{\n    return ptrTabsize(sp);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_PUBLIC_VAR(TABSIZE) (void)\n{\n    return *_nc_ptr_Tabsize(CURRENT_SCREEN);\n}\n#else\nNCURSES_EXPORT_VAR(char) ttytype[NAMESIZE] = \"\";\nNCURSES_EXPORT_VAR(int) LINES = 0;\nNCURSES_EXPORT_VAR(int) COLS = 0;\nNCURSES_EXPORT_VAR(int) TABSIZE = 8;\n#endif\n\n#if NCURSES_EXT_FUNCS\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(set_tabsize) (NCURSES_SP_DCLx int value)\n{\n    int code = OK;\n#if USE_REENTRANT\n    if (SP_PARM) {\n\tSP_PARM->_TABSIZE = value;\n    } else {\n\tcode = ERR;\n    }\n#else\n    (void) SP_PARM;\n    TABSIZE = value;\n#endif\n    return code;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nset_tabsize(int value)\n{\n    return NCURSES_SP_NAME(set_tabsize) (CURRENT_SCREEN, value);\n}\n#endif\n#endif /* NCURSES_EXT_FUNCS */\n\n#if USE_SIGWINCH\n/*\n * If we have a pending SIGWINCH, set the flag in each screen.\n */\nNCURSES_EXPORT(int)\n_nc_handle_sigwinch(SCREEN *sp)\n{\n    SCREEN *scan;\n\n    if (_nc_globals.have_sigwinch) {\n\t_nc_globals.have_sigwinch = 0;\n\n\tfor (each_screen(scan)) {\n\t    scan->_sig_winch = TRUE;\n\t}\n    }\n\n    return (sp ? sp->_sig_winch : 0);\n}\n\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(use_env) (NCURSES_SP_DCLx bool f)\n{\n    START_TRACE();\n    T((T_CALLED(\"use_env(%p,%d)\"), (void *) SP_PARM, (int) f));\n#if NCURSES_SP_FUNCS\n    if (IsPreScreen(SP_PARM)) {\n\tSP_PARM->_use_env = f;\n    }\n#else\n    _nc_prescreen.use_env = f;\n#endif\n    returnVoid;\n}\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(use_tioctl) (NCURSES_SP_DCLx bool f)\n{\n    START_TRACE();\n    T((T_CALLED(\"use_tioctl(%p,%d)\"), (void *) SP_PARM, (int) f));\n#if NCURSES_SP_FUNCS\n    if (IsPreScreen(SP_PARM)) {\n\tSP_PARM->use_tioctl = f;\n    }\n#else\n    _nc_prescreen.use_tioctl = f;\n#endif\n    returnVoid;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\nuse_env(bool f)\n{\n    START_TRACE();\n    T((T_CALLED(\"use_env(%d)\"), (int) f));\n    _nc_prescreen.use_env = f;\n    returnVoid;\n}\n\nNCURSES_EXPORT(void)\nuse_tioctl(bool f)\n{\n    START_TRACE();\n    T((T_CALLED(\"use_tioctl(%d)\"), (int) f));\n    _nc_prescreen.use_tioctl = f;\n    returnVoid;\n}\n#endif\n\nNCURSES_EXPORT(void)\n_nc_get_screensize(SCREEN *sp,\n#ifdef USE_TERM_DRIVER\n\t\t   TERMINAL *termp,\n#endif\n\t\t   int *linep, int *colp)\n/* Obtain lines/columns values from the environment and/or terminfo entry */\n{\n#ifdef USE_TERM_DRIVER\n    TERMINAL_CONTROL_BLOCK *TCB;\n    int my_tabsize;\n\n    assert(termp != 0 && linep != 0 && colp != 0);\n    TCB = (TERMINAL_CONTROL_BLOCK *) termp;\n\n    my_tabsize = TCB->info.tabsize;\n    TCB->drv->td_size(TCB, linep, colp);\n\n#if USE_REENTRANT\n    if (sp != 0) {\n\tsp->_TABSIZE = my_tabsize;\n    }\n#else\n    (void) sp;\n    TABSIZE = my_tabsize;\n#endif\n    T((\"TABSIZE = %d\", my_tabsize));\n#else /* !USE_TERM_DRIVER */\n    TERMINAL *termp = cur_term;\n    int my_tabsize;\n    bool useEnv = _nc_prescreen.use_env;\n    bool useTioctl = _nc_prescreen.use_tioctl;\n\n    /* figure out the size of the screen */\n    T((\"screen size: terminfo lines = %d columns = %d\", lines, columns));\n\n    *linep = (int) lines;\n    *colp = (int) columns;\n\n#if NCURSES_SP_FUNCS\n    if (sp) {\n\tuseEnv = sp->_use_env;\n\tuseTioctl = sp->use_tioctl;\n    }\n#endif\n\n    if (useEnv || useTioctl) {\n#ifdef __EMX__\n\t{\n\t    int screendata[2];\n\t    _scrsize(screendata);\n\t    *colp = screendata[0];\n\t    *linep = ((sp != 0 && sp->_filtered)\n\t\t      ? 1\n\t\t      : screendata[1]);\n\t    T((\"EMX screen size: environment LINES = %d COLUMNS = %d\",\n\t       *linep, *colp));\n\t}\n#endif\n#if HAVE_SIZECHANGE\n\t/* try asking the OS */\n\tif (NC_ISATTY(cur_term->Filedes)) {\n\t    STRUCT_WINSIZE size;\n\n\t    errno = 0;\n\t    do {\n\t\tif (ioctl(cur_term->Filedes, IOCTL_WINSIZE, &size) >= 0) {\n\t\t    *linep = ((sp != 0 && sp->_filtered)\n\t\t\t      ? 1\n\t\t\t      : WINSIZE_ROWS(size));\n\t\t    *colp = WINSIZE_COLS(size);\n\t\t    T((\"SYS screen size: environment LINES = %d COLUMNS = %d\",\n\t\t       *linep, *colp));\n\t\t    break;\n\t\t}\n\t    } while\n\t\t(errno == EINTR);\n\t}\n#endif /* HAVE_SIZECHANGE */\n\n\tif (useEnv) {\n\t    int value;\n\n\t    if (useTioctl) {\n\t\t/*\n\t\t * If environment variables are used, update them.\n\t\t */\n\t\tif ((sp == 0 || !sp->_filtered) && _nc_getenv_num(\"LINES\") > 0) {\n\t\t    _nc_setenv_num(\"LINES\", *linep);\n\t\t}\n\t\tif (_nc_getenv_num(\"COLUMNS\") > 0) {\n\t\t    _nc_setenv_num(\"COLUMNS\", *colp);\n\t\t}\n\t    }\n\n\t    /*\n\t     * Finally, look for environment variables.\n\t     *\n\t     * Solaris lets users override either dimension with an environment\n\t     * variable.\n\t     */\n\t    if ((value = _nc_getenv_num(\"LINES\")) > 0) {\n\t\t*linep = value;\n\t\tT((\"screen size: environment LINES = %d\", *linep));\n\t    }\n\t    if ((value = _nc_getenv_num(\"COLUMNS\")) > 0) {\n\t\t*colp = value;\n\t\tT((\"screen size: environment COLUMNS = %d\", *colp));\n\t    }\n\t}\n\n\t/* if we can't get dynamic info about the size, use static */\n\tif (*linep <= 0) {\n\t    *linep = (int) lines;\n\t}\n\tif (*colp <= 0) {\n\t    *colp = (int) columns;\n\t}\n\n\t/* the ultimate fallback, assume fixed 24x80 size */\n\tif (*linep <= 0) {\n\t    *linep = 24;\n\t}\n\tif (*colp <= 0) {\n\t    *colp = 80;\n\t}\n\n\t/*\n\t * Put the derived values back in the screen-size caps, so\n\t * tigetnum() and tgetnum() will do the right thing.\n\t */\n\tlines = (NCURSES_INT2) (*linep);\n\tcolumns = (NCURSES_INT2) (*colp);\n#if NCURSES_EXT_NUMBERS\n#define OldNumber(termp,name) \\\n\t(termp)->type.Numbers[(&name - (termp)->type2.Numbers)]\n\tOldNumber(termp, lines) = (short) (*linep);\n\tOldNumber(termp, columns) = (short) (*colp);\n#endif\n    }\n\n    T((\"screen size is %dx%d\", *linep, *colp));\n\n    if (VALID_NUMERIC(init_tabs))\n\tmy_tabsize = (int) init_tabs;\n    else\n\tmy_tabsize = 8;\n\n#if USE_REENTRANT\n    if (sp != 0)\n\tsp->_TABSIZE = my_tabsize;\n#else\n    TABSIZE = my_tabsize;\n#endif\n    T((\"TABSIZE = %d\", TABSIZE));\n#endif /* USE_TERM_DRIVER */\n}\n\n#if USE_SIZECHANGE\nNCURSES_EXPORT(void)\n_nc_update_screensize(SCREEN *sp)\n{\n    int new_lines;\n    int new_cols;\n\n#ifdef USE_TERM_DRIVER\n    int old_lines;\n    int old_cols;\n\n    assert(sp != 0);\n\n    CallDriver_2(sp, td_getsize, &old_lines, &old_cols);\n\n#else\n    TERMINAL *termp = cur_term;\n    int old_lines = lines;\n    int old_cols = columns;\n#endif\n\n    TINFO_GET_SIZE(sp, sp->_term, &new_lines, &new_cols);\n\n    /*\n     * See is_term_resized() and resizeterm().\n     * We're doing it this way because those functions belong to the upper\n     * ncurses library, while this resides in the lower terminfo library.\n     */\n    if (sp != 0 && sp->_resize != 0) {\n\tif ((new_lines != old_lines) || (new_cols != old_cols)) {\n\t    sp->_resize(NCURSES_SP_ARGx new_lines, new_cols);\n\t} else if (sp->_sig_winch && (sp->_ungetch != 0)) {\n\t    sp->_ungetch(SP_PARM, KEY_RESIZE);\t/* so application can know this */\n\t}\n\tsp->_sig_winch = FALSE;\n    }\n}\n#endif\n\n/****************************************************************************\n *\n * Terminal setup\n *\n ****************************************************************************/\n\n#if NCURSES_USE_DATABASE || NCURSES_USE_TERMCAP\n/*\n * Return 1 if entry found, 0 if not found, -1 if database not accessible,\n * just like tgetent().\n */\nint\n_nc_setup_tinfo(const char *const tn, TERMTYPE2 *const tp)\n{\n    char filename[PATH_MAX];\n    int status = _nc_read_entry2(tn, filename, tp);\n\n    /*\n     * If we have an entry, force all of the cancelled strings to null\n     * pointers so we don't have to test them in the rest of the library.\n     * (The terminfo compiler bypasses this logic, since it must know if\n     * a string is cancelled, for merging entries).\n     */\n    if (status == TGETENT_YES) {\n\tunsigned n;\n\tfor_each_boolean(n, tp) {\n\t    if (!VALID_BOOLEAN(tp->Booleans[n]))\n\t\ttp->Booleans[n] = FALSE;\n\t}\n\tfor_each_string(n, tp) {\n\t    if (tp->Strings[n] == CANCELLED_STRING)\n\t\ttp->Strings[n] = ABSENT_STRING;\n\t}\n    }\n    return (status);\n}\n#endif\n\n/*\n**\tTake the real command character out of the CC environment variable\n**\tand substitute it in for the prototype given in 'command_character'.\n*/\nvoid\n_nc_tinfo_cmdch(TERMINAL *termp, int proto)\n{\n    char *tmp;\n\n    /*\n     * Only use the character if the string is a single character,\n     * since it is fairly common for developers to set the C compiler\n     * name as an environment variable - using the same symbol.\n     */\n    if ((tmp = getenv(\"CC\")) != 0 && strlen(tmp) == 1) {\n\tunsigned i;\n\tchar CC = *tmp;\n\n\tfor_each_string(i, &(termp->type)) {\n\t    for (tmp = termp->type.Strings[i]; tmp && *tmp; tmp++) {\n\t\tif (UChar(*tmp) == proto)\n\t\t    *tmp = CC;\n\t    }\n\t}\n    }\n}\n\n/*\n * Find the locale which is in effect.\n */\nNCURSES_EXPORT(char *)\n_nc_get_locale(void)\n{\n    char *env;\n#if HAVE_LOCALE_H\n    /*\n     * This is preferable to using getenv() since it ensures that we are using\n     * the locale which was actually initialized by the application.\n     */\n    env = setlocale(LC_CTYPE, 0);\n#else\n    if (((env = getenv(\"LC_ALL\")) != 0 && *env != '\\0')\n\t|| ((env = getenv(\"LC_CTYPE\")) != 0 && *env != '\\0')\n\t|| ((env = getenv(\"LANG\")) != 0 && *env != '\\0')) {\n\t;\n    }\n#endif\n    T((\"_nc_get_locale %s\", _nc_visbuf(env)));\n    return env;\n}\n\n/*\n * Check if we are running in a UTF-8 locale.\n */\nNCURSES_EXPORT(int)\n_nc_unicode_locale(void)\n{\n    int result = 0;\n#if defined(__MINGW32__) && USE_WIDEC_SUPPORT\n    result = 1;\n#elif HAVE_LANGINFO_CODESET\n    char *env = nl_langinfo(CODESET);\n    result = !strcmp(env, \"UTF-8\");\n    T((\"_nc_unicode_locale(%s) ->%d\", env, result));\n#else\n    char *env = _nc_get_locale();\n    if (env != 0) {\n\tif (strstr(env, \".UTF-8\") != 0) {\n\t    result = 1;\n\t    T((\"_nc_unicode_locale(%s) ->%d\", env, result));\n\t}\n    }\n#endif\n    return result;\n}\n\n#define CONTROL_N(s) ((s) != 0 && strstr(s, \"\\016\") != 0)\n#define CONTROL_O(s) ((s) != 0 && strstr(s, \"\\017\") != 0)\n\n/*\n * Check for known broken cases where a UTF-8 locale breaks the alternate\n * character set.\n */\nNCURSES_EXPORT(int)\n_nc_locale_breaks_acs(TERMINAL *termp)\n{\n    const char *env_name = \"NCURSES_NO_UTF8_ACS\";\n    const char *env;\n    int value;\n    int result = 0;\n\n    T((T_CALLED(\"_nc_locale_breaks_acs:%d\"), result));\n    if (getenv(env_name) != 0) {\n\tresult = _nc_getenv_num(env_name);\n    } else if ((value = tigetnum(\"U8\")) >= 0) {\n\tresult = value;\t\t/* use extension feature */\n    } else if ((env = getenv(\"TERM\")) != 0) {\n\tif (strstr(env, \"linux\")) {\n\t    result = 1;\t\t/* always broken */\n\t} else if (strstr(env, \"screen\") != 0\n\t\t   && ((env = getenv(\"TERMCAP\")) != 0\n\t\t       && strstr(env, \"screen\") != 0)\n\t\t   && strstr(env, \"hhII00\") != 0) {\n\t    if (CONTROL_N(enter_alt_charset_mode) ||\n\t\tCONTROL_O(enter_alt_charset_mode) ||\n\t\tCONTROL_N(set_attributes) ||\n\t\tCONTROL_O(set_attributes)) {\n\t\tresult = 1;\n\t    }\n\t}\n    }\n    returnCode(result);\n}\n\nNCURSES_EXPORT(int)\nTINFO_SETUP_TERM(TERMINAL **tp,\n\t\t NCURSES_CONST char *tname,\n\t\t int Filedes,\n\t\t int *errret,\n\t\t int reuse)\n{\n#ifdef USE_TERM_DRIVER\n    TERMINAL_CONTROL_BLOCK *TCB = 0;\n#endif\n    TERMINAL *termp;\n    SCREEN *sp = 0;\n    int code = ERR;\n\n    START_TRACE();\n\n#ifdef USE_TERM_DRIVER\n    T((T_CALLED(\"_nc_setupterm_ex(%p,%s,%d,%p)\"),\n       (void *) tp, _nc_visbuf(tname), Filedes, (void *) errret));\n\n    if (tp == 0) {\n\tret_error0(TGETENT_ERR,\n\t\t   \"Invalid parameter, internal error.\\n\");\n    } else\n\ttermp = *tp;\n#else\n    termp = cur_term;\n    T((T_CALLED(\"setupterm(%s,%d,%p)\"), _nc_visbuf(tname), Filedes, (void *) errret));\n#endif\n\n    if (tname == 0) {\n\ttname = getenv(\"TERM\");\n\tif (tname == 0 || *tname == '\\0') {\n#ifdef USE_TERM_DRIVER\n\t    tname = \"unknown\";\n#else\n\t    ret_error0(TGETENT_ERR, \"TERM environment variable not set.\\n\");\n#endif\n\t}\n    }\n\n    if (strlen(tname) > MAX_NAME_SIZE) {\n\tret_error(TGETENT_ERR,\n\t\t  \"TERM environment must be <= %d characters.\\n\",\n\t\t  MAX_NAME_SIZE);\n    }\n\n    T((\"your terminal name is %s\", tname));\n\n    /*\n     * Allow output redirection.  This is what SVr3 does.  If stdout is\n     * directed to a file, screen updates go to standard error.\n     */\n    if (Filedes == STDOUT_FILENO && !NC_ISATTY(Filedes))\n\tFiledes = STDERR_FILENO;\n\n    /*\n     * Check if we have already initialized to use this terminal.  If so, we\n     * do not need to re-read the terminfo entry, or obtain TTY settings.\n     *\n     * This is an improvement on SVr4 curses.  If an application mixes curses\n     * and termcap calls, it may call both initscr and tgetent.  This is not\n     * really a good thing to do, but can happen if someone tries using ncurses\n     * with the readline library.  The problem we are fixing is that when\n     * tgetent calls setupterm, the resulting Ottyb struct in cur_term is\n     * zeroed.  A subsequent call to endwin uses the zeroed terminal settings\n     * rather than the ones saved in initscr.  So we check if cur_term appears\n     * to contain terminal settings for the same output file as our current\n     * call - and copy those terminal settings.  (SVr4 curses does not do this,\n     * however applications that are working around the problem will still work\n     * properly with this feature).\n     */\n    if (reuse\n\t&& (termp != 0)\n\t&& termp->Filedes == Filedes\n\t&& termp->_termname != 0\n\t&& !strcmp(termp->_termname, tname)\n\t&& _nc_name_match(TerminalType(termp).term_names, tname, \"|\")) {\n\tT((\"reusing existing terminal information and mode-settings\"));\n\tcode = OK;\n#ifdef USE_TERM_DRIVER\n\tTCB = (TERMINAL_CONTROL_BLOCK *) termp;\n#endif\n    } else {\n#ifdef USE_TERM_DRIVER\n\tTERMINAL_CONTROL_BLOCK *my_tcb;\n\ttermp = 0;\n\tif ((my_tcb = typeCalloc(TERMINAL_CONTROL_BLOCK, 1)) != 0)\n\t    termp = &(my_tcb->term);\n#else\n\tint status;\n\n\ttermp = typeCalloc(TERMINAL, 1);\n#endif\n\tif (termp == 0) {\n\t    ret_error0(TGETENT_ERR,\n\t\t       \"Not enough memory to create terminal structure.\\n\");\n\t}\n#ifdef USE_TERM_DRIVER\n\tINIT_TERM_DRIVER();\n\tTCB = (TERMINAL_CONTROL_BLOCK *) termp;\n\tcode = _nc_globals.term_driver(TCB, tname, errret);\n\tif (code == OK) {\n\t    termp->Filedes = (short) Filedes;\n\t    termp->_termname = strdup(tname);\n\t} else {\n\t    _nc_free_termtype2(&TerminalType(termp));\n\t    free(my_tcb);\n\t    ret_error0(errret ? *errret : TGETENT_ERR,\n\t\t       \"Could not find any driver to handle this terminal.\\n\");\n\t}\n#else\n#if NCURSES_USE_DATABASE || NCURSES_USE_TERMCAP\n\tstatus = _nc_setup_tinfo(tname, &TerminalType(termp));\n#else\n\tstatus = TGETENT_NO;\n#endif\n\n\t/* try fallback list if entry on disk */\n\tif (status != TGETENT_YES) {\n\t    const TERMTYPE2 *fallback = _nc_fallback2(tname);\n\n\t    if (fallback) {\n\t\tTerminalType(termp) = *fallback;\n\t\tstatus = TGETENT_YES;\n\t    }\n\t}\n\n\tif (status != TGETENT_YES) {\n\t    del_curterm(termp);\n\t    if (status == TGETENT_ERR) {\n\t\tret_error0(status, \"terminals database is inaccessible\\n\");\n\t    } else if (status == TGETENT_NO) {\n\t\tret_error1(status, \"unknown terminal type.\\n\", tname);\n\t    }\n\t}\n#if NCURSES_EXT_NUMBERS\n\t_nc_export_termtype2(&termp->type, &TerminalType(termp));\n#endif\n#if !USE_REENTRANT\n\tsave_ttytype(termp);\n#endif\n\n\ttermp->Filedes = (short) Filedes;\n\ttermp->_termname = strdup(tname);\n\n\tset_curterm(termp);\n\n\tif (command_character)\n\t    _nc_tinfo_cmdch(termp, UChar(*command_character));\n\n\t/*\n\t * If an application calls setupterm() rather than initscr() or\n\t * newterm(), we will not have the def_prog_mode() call in\n\t * _nc_setupscreen().  Do it now anyway, so we can initialize the\n\t * baudrate.  Also get the shell-mode so that erasechar() works.\n\t */\n\tif (NC_ISATTY(Filedes)) {\n\t    NCURSES_SP_NAME(def_shell_mode) (NCURSES_SP_ARG);\n\t    NCURSES_SP_NAME(def_prog_mode) (NCURSES_SP_ARG);\n\t    baudrate();\n\t}\n\tcode = OK;\n#endif\n    }\n\n#ifdef USE_TERM_DRIVER\n    *tp = termp;\n    NCURSES_SP_NAME(set_curterm) (sp, termp);\n    TCB->drv->td_init(TCB);\n#else\n    sp = SP;\n#endif\n\n    /*\n     * We should always check the screensize, just in case.\n     */\n    TINFO_GET_SIZE(sp, termp, ptrLines(sp), ptrCols(sp));\n\n    if (errret)\n\t*errret = TGETENT_YES;\n\n#ifndef USE_TERM_DRIVER\n    if (generic_type) {\n\t/*\n\t * BSD 4.3's termcap contains mis-typed \"gn\" for wy99.  Do a sanity\n\t * check before giving up.\n\t */\n\tif ((VALID_STRING(cursor_address)\n\t     || (VALID_STRING(cursor_down) && VALID_STRING(cursor_home)))\n\t    && VALID_STRING(clear_screen)) {\n\t    ret_error1(TGETENT_YES, \"terminal is not really generic.\\n\", tname);\n\t} else {\n\t    del_curterm(termp);\n\t    ret_error1(TGETENT_NO, \"I need something more specific.\\n\", tname);\n\t}\n    } else if (hard_copy) {\n\tret_error1(TGETENT_YES, \"I can't handle hardcopy terminals.\\n\", tname);\n    }\n#endif\n    returnCode(code);\n}\n\n#ifdef USE_PTHREADS\n/*\n * Returns a non-null pointer unless a new screen should be allocated because\n * no match was found in the pre-screen cache.\n */\nNCURSES_EXPORT(SCREEN *)\n_nc_find_prescr(void)\n{\n    SCREEN *result = 0;\n    PRESCREEN_LIST *p;\n    for (p = _nc_prescreen.allocated; p != 0; p = p->next) {\n\tif (p->id == pthread_self()) {\n\t    result = p->sp;\n\t    break;\n\t}\n    }\n    return result;\n}\n\n/*\n * Tells ncurses to forget that this thread was associated with the pre-screen\n * cache.  It does not modify the pre-screen cache itself, since that is used\n * for creating new screens.\n */\nNCURSES_EXPORT(void)\n_nc_forget_prescr(void)\n{\n    PRESCREEN_LIST *p, *q;\n    for (p = _nc_prescreen.allocated, q = 0; p != 0; q = p, p = p->next) {\n\tif (p->id == pthread_self()) {\n\t    if (q) {\n\t\tq->next = p->next;\n\t    } else {\n\t\t_nc_prescreen.allocated = p->next;\n\t    }\n\t    free(p);\n\t    break;\n\t}\n    }\n}\n#endif /* USE_PTHREADS */\n\n#if NCURSES_SP_FUNCS\n/*\n * In case of handling multiple screens, we need to have a screen before\n * initialization in _nc_setupscreen takes place.  This is to extend the\n * substitute for some of the stuff in _nc_prescreen, especially for slk and\n * ripoff handling which should be done per screen.\n */\nNCURSES_EXPORT(SCREEN *)\nnew_prescr(void)\n{\n    SCREEN *sp;\n\n    START_TRACE();\n    T((T_CALLED(\"new_prescr()\")));\n\n    _nc_lock_global(screen);\n    if ((sp = _nc_find_prescr()) == 0) {\n\tsp = _nc_alloc_screen_sp();\n\tT((\"_nc_alloc_screen_sp %p\", (void *) sp));\n\tif (sp != 0) {\n#ifdef USE_PTHREADS\n\t    PRESCREEN_LIST *p = typeCalloc(PRESCREEN_LIST, 1);\n\t    if (p != 0) {\n\t\tp->id = pthread_self();\n\t\tp->sp = sp;\n\t\tp->next = _nc_prescreen.allocated;\n\t\t_nc_prescreen.allocated = p;\n\t    }\n#else\n\t    _nc_prescreen.allocated = sp;\n#endif\n\t    sp->rsp = sp->rippedoff;\n\t    sp->_filtered = _nc_prescreen.filter_mode;\n\t    sp->_use_env = _nc_prescreen.use_env;\n#if NCURSES_NO_PADDING\n\t    sp->_no_padding = _nc_prescreen._no_padding;\n#endif\n\t    sp->slk_format = 0;\n\t    sp->_slk = 0;\n\t    sp->_prescreen = TRUE;\n\t    SP_PRE_INIT(sp);\n#if USE_REENTRANT\n\t    sp->_TABSIZE = _nc_prescreen._TABSIZE;\n\t    sp->_ESCDELAY = _nc_prescreen._ESCDELAY;\n#endif\n\t}\n    } else {\n\tT((\"_nc_alloc_screen_sp %p (reuse)\", (void *) sp));\n    }\n    _nc_unlock_global(screen);\n    returnSP(sp);\n}\n#endif\n\n#ifdef USE_TERM_DRIVER\n/*\n * This entrypoint is called from tgetent() to allow a special case of reusing\n * the same TERMINAL data (see comment).\n */\nNCURSES_EXPORT(int)\n_nc_setupterm(NCURSES_CONST char *tname,\n\t      int Filedes,\n\t      int *errret,\n\t      int reuse)\n{\n    int rc = ERR;\n    TERMINAL *termp = 0;\n\n    _nc_lock_global(prescreen);\n    START_TRACE();\n    if (TINFO_SETUP_TERM(&termp, tname, Filedes, errret, reuse) == OK) {\n\t_nc_forget_prescr();\n\tif (NCURSES_SP_NAME(set_curterm) (CURRENT_SCREEN_PRE, termp) != 0) {\n\t    rc = OK;\n\t}\n    }\n    _nc_unlock_global(prescreen);\n    return rc;\n}\n#endif\n\n/*\n *\tsetupterm(termname, Filedes, errret)\n *\n *\tFind and read the appropriate object file for the terminal\n *\tMake cur_term point to the structure.\n */\nNCURSES_EXPORT(int)\nsetupterm(NCURSES_CONST char *tname, int Filedes, int *errret)\n{\n    START_TRACE();\n    return _nc_setupterm(tname, Filedes, errret, FALSE);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2003,2009 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_termname.c,v 1.12 2009/10/24 21:56:58 tom Exp $\")\n\nNCURSES_EXPORT(char *)\nNCURSES_SP_NAME(termname) (NCURSES_SP_DCL0)\n{\n    char *name = 0;\n\n    T((T_CALLED(\"termname(%p)\"), (void *) SP_PARM));\n\n#if NCURSES_SP_FUNCS\n    if (TerminalOf(SP_PARM) != 0) {\n\tname = TerminalOf(SP_PARM)->_termname;\n    }\n#else\n    if (cur_term != 0)\n\tname = cur_term->_termname;\n#endif\n\n    returnPtr(name);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(char *)\ntermname(void)\n{\n    return NCURSES_SP_NAME(termname) (CURRENT_SCREEN);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n ****************************************************************************/\n\n#include <curses.priv.h>\n\n#include <tic.h>\n\nMODULE_ID(\"$Id: lib_ti.c,v 1.32 2017/04/11 01:15:42 tom Exp $\")\n\n#if 0\nstatic bool\nsame_name(const char *a, const char *b)\n{\n    fprintf(stderr, \"compare(%s,%s)\\n\", a, b);\n    return !strcmp(a, b);\n}\n#else\n#define same_name(a,b) !strcmp(a,b)\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(tigetflag) (NCURSES_SP_DCLx NCURSES_CONST char *str)\n{\n    int result = ABSENT_BOOLEAN;\n\n    T((T_CALLED(\"tigetflag(%p, %s)\"), (void *) SP_PARM, str));\n\n    if (HasTInfoTerminal(SP_PARM)) {\n\tTERMTYPE2 *tp = &TerminalType(TerminalOf(SP_PARM));\n\tstruct name_table_entry const *entry_ptr;\n\tint j = -1;\n\n\tentry_ptr = _nc_find_type_entry(str, BOOLEAN, FALSE);\n\tif (entry_ptr != 0) {\n\t    j = entry_ptr->nte_index;\n\t}\n#if NCURSES_XNAMES\n\telse {\n\t    int i;\n\t    for_each_ext_boolean(i, tp) {\n\t\tconst char *capname = ExtBoolname(tp, i, boolnames);\n\t\tif (same_name(str, capname)) {\n\t\t    j = i;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tif (j >= 0) {\n\t    /* note: setupterm forces invalid booleans to false */\n\t    result = tp->Booleans[j];\n\t}\n    }\n\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ntigetflag(NCURSES_CONST char *str)\n{\n    return NCURSES_SP_NAME(tigetflag) (CURRENT_SCREEN, str);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(tigetnum) (NCURSES_SP_DCLx NCURSES_CONST char *str)\n{\n    int result = CANCELLED_NUMERIC;\t/* Solaris returns a -1 on error */\n\n    T((T_CALLED(\"tigetnum(%p, %s)\"), (void *) SP_PARM, str));\n\n    if (HasTInfoTerminal(SP_PARM)) {\n\tTERMTYPE2 *tp = &TerminalType(TerminalOf(SP_PARM));\n\tstruct name_table_entry const *entry_ptr;\n\tint j = -1;\n\n\tentry_ptr = _nc_find_type_entry(str, NUMBER, FALSE);\n\tif (entry_ptr != 0) {\n\t    j = entry_ptr->nte_index;\n\t}\n#if NCURSES_XNAMES\n\telse {\n\t    int i;\n\t    for_each_ext_number(i, tp) {\n\t\tconst char *capname = ExtNumname(tp, i, numnames);\n\t\tif (same_name(str, capname)) {\n\t\t    j = i;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tif (j >= 0) {\n\t    if (VALID_NUMERIC(tp->Numbers[j]))\n\t\tresult = tp->Numbers[j];\n\t    else\n\t\tresult = ABSENT_NUMERIC;\n\t}\n    }\n\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ntigetnum(NCURSES_CONST char *str)\n{\n    return NCURSES_SP_NAME(tigetnum) (CURRENT_SCREEN, str);\n}\n#endif\n\nNCURSES_EXPORT(char *)\nNCURSES_SP_NAME(tigetstr) (NCURSES_SP_DCLx NCURSES_CONST char *str)\n{\n    char *result = CANCELLED_STRING;\n\n    T((T_CALLED(\"tigetstr(%p, %s)\"), (void *) SP_PARM, str));\n\n    if (HasTInfoTerminal(SP_PARM)) {\n\tTERMTYPE2 *tp = &TerminalType(TerminalOf(SP_PARM));\n\tstruct name_table_entry const *entry_ptr;\n\tint j = -1;\n\n\tentry_ptr = _nc_find_type_entry(str, STRING, FALSE);\n\tif (entry_ptr != 0) {\n\t    j = entry_ptr->nte_index;\n\t}\n#if NCURSES_XNAMES\n\telse {\n\t    int i;\n\t    for_each_ext_string(i, tp) {\n\t\tconst char *capname = ExtStrname(tp, i, strnames);\n\t\tif (same_name(str, capname)) {\n\t\t    j = i;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tif (j >= 0) {\n\t    /* note: setupterm forces cancelled strings to null */\n\t    result = tp->Strings[j];\n\t}\n    }\n\n    returnPtr(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(char *)\ntigetstr(NCURSES_CONST char *str)\n{\n    return NCURSES_SP_NAME(tigetstr) (CURRENT_SCREEN, str);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey, 1996 on                                       *\n ****************************************************************************/\n\n/*\n *\ttparm.c\n *\n */\n\n#include <curses.priv.h>\n\n#include <ctype.h>\n#include <tic.h>\n\nMODULE_ID(\"$Id: lib_tparm.c,v 1.104 2017/08/02 01:23:51 tom Exp $\")\n\n/*\n *\tchar *\n *\ttparm(string, ...)\n *\n *\tSubstitute the given parameters into the given string by the following\n *\trules (taken from terminfo(5)):\n *\n *\t     Cursor addressing and other strings  requiring  parame-\n *\tters in the terminal are described by a parameterized string\n *\tcapability, with escapes like %x in  it.   For  example,  to\n *\taddress  the  cursor, the cup capability is given, using two\n *\tparameters: the row and column to  address  to.   (Rows  and\n *\tcolumns  are  numbered  from  zero and refer to the physical\n *\tscreen visible to the user, not to any  unseen  memory.)  If\n *\tthe terminal has memory relative cursor addressing, that can\n *\tbe indicated by\n *\n *\t     The parameter mechanism uses  a  stack  and  special  %\n *\tcodes  to manipulate it.  Typically a sequence will push one\n *\tof the parameters onto the stack and then print it  in  some\n *\tformat.  Often more complex operations are necessary.\n *\n *\t     The % encodings have the following meanings:\n *\n *\t     %%        outputs `%'\n *\t     %c        print pop() like %c in printf()\n *\t     %s        print pop() like %s in printf()\n *           %[[:]flags][width[.precision]][doxXs]\n *                     as in printf, flags are [-+#] and space\n *                     The ':' is used to avoid making %+ or %-\n *                     patterns (see below).\n *\n *\t     %p[1-9]   push ith parm\n *\t     %P[a-z]   set dynamic variable [a-z] to pop()\n *\t     %g[a-z]   get dynamic variable [a-z] and push it\n *\t     %P[A-Z]   set static variable [A-Z] to pop()\n *\t     %g[A-Z]   get static variable [A-Z] and push it\n *\t     %l        push strlen(pop)\n *\t     %'c'      push char constant c\n *\t     %{nn}     push integer constant nn\n *\n *\t     %+ %- %* %/ %m\n *\t               arithmetic (%m is mod): push(pop() op pop())\n *\t     %& %| %^  bit operations: push(pop() op pop())\n *\t     %= %> %<  logical operations: push(pop() op pop())\n *\t     %A %O     logical and & or operations for conditionals\n *\t     %! %~     unary operations push(op pop())\n *\t     %i        add 1 to first two parms (for ANSI terminals)\n *\n *\t     %? expr %t thenpart %e elsepart %;\n *\t               if-then-else, %e elsepart is optional.\n *\t               else-if's are possible ala Algol 68:\n *\t               %? c1 %t b1 %e c2 %t b2 %e c3 %t b3 %e c4 %t b4 %e b5 %;\n *\n *\tFor those of the above operators which are binary and not commutative,\n *\tthe stack works in the usual way, with\n *\t\t\t%gx %gy %m\n *\tresulting in x mod y, not the reverse.\n */\n\nNCURSES_EXPORT_VAR(int) _nc_tparm_err = 0;\n\n#define TPS(var) _nc_prescreen.tparm_state.var\n#define popcount _nc_popcount\t/* workaround for NetBSD 6.0 defect */\n\n#if NO_LEAKS\nNCURSES_EXPORT(void)\n_nc_free_tparm(void)\n{\n    if (TPS(out_buff) != 0) {\n\tFreeAndNull(TPS(out_buff));\n\tTPS(out_size) = 0;\n\tTPS(out_used) = 0;\n\tFreeAndNull(TPS(fmt_buff));\n\tTPS(fmt_size) = 0;\n    }\n}\n#endif\n\nstatic NCURSES_INLINE void\nget_space(size_t need)\n{\n    need += TPS(out_used);\n    if (need > TPS(out_size)) {\n\tTPS(out_size) = need * 2;\n\tTYPE_REALLOC(char, TPS(out_size), TPS(out_buff));\n    }\n}\n\nstatic NCURSES_INLINE void\nsave_text(const char *fmt, const char *s, int len)\n{\n    size_t s_len = strlen(s);\n    if (len > (int) s_len)\n\ts_len = (size_t) len;\n\n    get_space(s_len + 1);\n\n    _nc_SPRINTF(TPS(out_buff) + TPS(out_used),\n\t\t_nc_SLIMIT(TPS(out_size) - TPS(out_used))\n\t\tfmt, s);\n    TPS(out_used) += strlen(TPS(out_buff) + TPS(out_used));\n}\n\nstatic NCURSES_INLINE void\nsave_number(const char *fmt, int number, int len)\n{\n    if (len < 30)\n\tlen = 30;\t\t/* actually log10(MAX_INT)+1 */\n\n    get_space((size_t) len + 1);\n\n    _nc_SPRINTF(TPS(out_buff) + TPS(out_used),\n\t\t_nc_SLIMIT(TPS(out_size) - TPS(out_used))\n\t\tfmt, number);\n    TPS(out_used) += strlen(TPS(out_buff) + TPS(out_used));\n}\n\nstatic NCURSES_INLINE void\nsave_char(int c)\n{\n    if (c == 0)\n\tc = 0200;\n    get_space((size_t) 1);\n    TPS(out_buff)[TPS(out_used)++] = (char) c;\n}\n\nstatic NCURSES_INLINE void\nnpush(int x)\n{\n    if (TPS(stack_ptr) < STACKSIZE) {\n\tTPS(stack)[TPS(stack_ptr)].num_type = TRUE;\n\tTPS(stack)[TPS(stack_ptr)].data.num = x;\n\tTPS(stack_ptr)++;\n    } else {\n\tDEBUG(2, (\"npush: stack overflow: %s\", _nc_visbuf(TPS(tparam_base))));\n\t_nc_tparm_err++;\n    }\n}\n\nstatic NCURSES_INLINE int\nnpop(void)\n{\n    int result = 0;\n    if (TPS(stack_ptr) > 0) {\n\tTPS(stack_ptr)--;\n\tif (TPS(stack)[TPS(stack_ptr)].num_type)\n\t    result = TPS(stack)[TPS(stack_ptr)].data.num;\n    } else {\n\tDEBUG(2, (\"npop: stack underflow: %s\", _nc_visbuf(TPS(tparam_base))));\n\t_nc_tparm_err++;\n    }\n    return result;\n}\n\nstatic NCURSES_INLINE void\nspush(char *x)\n{\n    if (TPS(stack_ptr) < STACKSIZE) {\n\tTPS(stack)[TPS(stack_ptr)].num_type = FALSE;\n\tTPS(stack)[TPS(stack_ptr)].data.str = x;\n\tTPS(stack_ptr)++;\n    } else {\n\tDEBUG(2, (\"spush: stack overflow: %s\", _nc_visbuf(TPS(tparam_base))));\n\t_nc_tparm_err++;\n    }\n}\n\nstatic NCURSES_INLINE char *\nspop(void)\n{\n    static char dummy[] = \"\";\t/* avoid const-cast */\n    char *result = dummy;\n    if (TPS(stack_ptr) > 0) {\n\tTPS(stack_ptr)--;\n\tif (!TPS(stack)[TPS(stack_ptr)].num_type\n\t    && TPS(stack)[TPS(stack_ptr)].data.str != 0)\n\t    result = TPS(stack)[TPS(stack_ptr)].data.str;\n    } else {\n\tDEBUG(2, (\"spop: stack underflow: %s\", _nc_visbuf(TPS(tparam_base))));\n\t_nc_tparm_err++;\n    }\n    return result;\n}\n\nstatic NCURSES_INLINE const char *\nparse_format(const char *s, char *format, int *len)\n{\n    *len = 0;\n    if (format != 0) {\n\tbool done = FALSE;\n\tbool allowminus = FALSE;\n\tbool dot = FALSE;\n\tbool err = FALSE;\n\tchar *fmt = format;\n\tint my_width = 0;\n\tint my_prec = 0;\n\tint value = 0;\n\n\t*len = 0;\n\t*format++ = '%';\n\twhile (*s != '\\0' && !done) {\n\t    switch (*s) {\n\t    case 'c':\t\t/* FALLTHRU */\n\t    case 'd':\t\t/* FALLTHRU */\n\t    case 'o':\t\t/* FALLTHRU */\n\t    case 'x':\t\t/* FALLTHRU */\n\t    case 'X':\t\t/* FALLTHRU */\n\t    case 's':\n#ifdef EXP_XTERM_1005\n\t    case 'u':\n#endif\n\t\t*format++ = *s;\n\t\tdone = TRUE;\n\t\tbreak;\n\t    case '.':\n\t\t*format++ = *s++;\n\t\tif (dot) {\n\t\t    err = TRUE;\n\t\t} else {\t/* value before '.' is the width */\n\t\t    dot = TRUE;\n\t\t    my_width = value;\n\t\t}\n\t\tvalue = 0;\n\t\tbreak;\n\t    case '#':\n\t\t*format++ = *s++;\n\t\tbreak;\n\t    case ' ':\n\t\t*format++ = *s++;\n\t\tbreak;\n\t    case ':':\n\t\ts++;\n\t\tallowminus = TRUE;\n\t\tbreak;\n\t    case '-':\n\t\tif (allowminus) {\n\t\t    *format++ = *s++;\n\t\t} else {\n\t\t    done = TRUE;\n\t\t}\n\t\tbreak;\n\t    default:\n\t\tif (isdigit(UChar(*s))) {\n\t\t    value = (value * 10) + (*s - '0');\n\t\t    if (value > 10000)\n\t\t\terr = TRUE;\n\t\t    *format++ = *s++;\n\t\t} else {\n\t\t    done = TRUE;\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * If we found an error, ignore (and remove) the flags.\n\t */\n\tif (err) {\n\t    my_width = my_prec = value = 0;\n\t    format = fmt;\n\t    *format++ = '%';\n\t    *format++ = *s;\n\t}\n\n\t/*\n\t * Any value after '.' is the precision.  If we did not see '.', then\n\t * the value is the width.\n\t */\n\tif (dot)\n\t    my_prec = value;\n\telse\n\t    my_width = value;\n\n\t*format = '\\0';\n\t/* return maximum string length in print */\n\t*len = (my_width > my_prec) ? my_width : my_prec;\n    }\n    return s;\n}\n\n#define isUPPER(c) ((c) >= 'A' && (c) <= 'Z')\n#define isLOWER(c) ((c) >= 'a' && (c) <= 'z')\n#define tc_BUMP()  if (level < 0 && number < 2) number++\n\n/*\n * Analyze the string to see how many parameters we need from the varargs list,\n * and what their types are.  We will only accept string parameters if they\n * appear as a %l or %s format following an explicit parameter reference (e.g.,\n * %p2%s).  All other parameters are numbers.\n *\n * 'number' counts coarsely the number of pop's we see in the string, and\n * 'popcount' shows the highest parameter number in the string.  We would like\n * to simply use the latter count, but if we are reading termcap strings, there\n * may be cases that we cannot see the explicit parameter numbers.\n */\nNCURSES_EXPORT(int)\n_nc_tparm_analyze(const char *string, char *p_is_s[NUM_PARM], int *popcount)\n{\n    size_t len2;\n    int i;\n    int lastpop = -1;\n    int len;\n    int number = 0;\n    int level = -1;\n    const char *cp = string;\n    static char dummy[] = \"\";\n\n    if (cp == 0)\n\treturn 0;\n\n    if ((len2 = strlen(cp)) > TPS(fmt_size)) {\n\tTPS(fmt_size) = len2 + TPS(fmt_size) + 2;\n\tTPS(fmt_buff) = typeRealloc(char, TPS(fmt_size), TPS(fmt_buff));\n\tif (TPS(fmt_buff) == 0)\n\t    return 0;\n    }\n\n    memset(p_is_s, 0, sizeof(p_is_s[0]) * NUM_PARM);\n    *popcount = 0;\n\n    while ((cp - string) < (int) len2) {\n\tif (*cp == '%') {\n\t    cp++;\n\t    cp = parse_format(cp, TPS(fmt_buff), &len);\n\t    switch (*cp) {\n\t    default:\n\t\tbreak;\n\n\t    case 'd':\t\t/* FALLTHRU */\n\t    case 'o':\t\t/* FALLTHRU */\n\t    case 'x':\t\t/* FALLTHRU */\n\t    case 'X':\t\t/* FALLTHRU */\n\t    case 'c':\t\t/* FALLTHRU */\n#ifdef EXP_XTERM_1005\n\t    case 'u':\n#endif\n\t\tif (lastpop <= 0) {\n\t\t    tc_BUMP();\n\t\t}\n\t\tlevel -= 1;\n\t\tlastpop = -1;\n\t\tbreak;\n\n\t    case 'l':\n\t    case 's':\n\t\tif (lastpop > 0) {\n\t\t    level -= 1;\n\t\t    p_is_s[lastpop - 1] = dummy;\n\t\t}\n\t\ttc_BUMP();\n\t\tbreak;\n\n\t    case 'p':\n\t\tcp++;\n\t\ti = (UChar(*cp) - '0');\n\t\tif (i >= 0 && i <= NUM_PARM) {\n\t\t    ++level;\n\t\t    lastpop = i;\n\t\t    if (lastpop > *popcount)\n\t\t\t*popcount = lastpop;\n\t\t}\n\t\tbreak;\n\n\t    case 'P':\n\t\t++cp;\n\t\tbreak;\n\n\t    case 'g':\n\t\t++level;\n\t\tcp++;\n\t\tbreak;\n\n\t    case S_QUOTE:\n\t\t++level;\n\t\tcp += 2;\n\t\tlastpop = -1;\n\t\tbreak;\n\n\t    case L_BRACE:\n\t\t++level;\n\t\tcp++;\n\t\twhile (isdigit(UChar(*cp))) {\n\t\t    cp++;\n\t\t}\n\t\tbreak;\n\n\t    case '+':\n\t    case '-':\n\t    case '*':\n\t    case '/':\n\t    case 'm':\n\t    case 'A':\n\t    case 'O':\n\t    case '&':\n\t    case '|':\n\t    case '^':\n\t    case '=':\n\t    case '<':\n\t    case '>':\n\t\ttc_BUMP();\n\t\tlevel -= 1;\t/* pop 2, operate, push 1 */\n\t\tlastpop = -1;\n\t\tbreak;\n\n\t    case '!':\n\t    case '~':\n\t\ttc_BUMP();\n\t\tlastpop = -1;\n\t\tbreak;\n\n\t    case 'i':\n\t\t/* will add 1 to first (usually two) parameters */\n\t\tbreak;\n\t    }\n\t}\n\tif (*cp != '\\0')\n\t    cp++;\n    }\n\n    if (number > NUM_PARM)\n\tnumber = NUM_PARM;\n    return number;\n}\n\nstatic NCURSES_INLINE char *\ntparam_internal(int use_TPARM_ARG, const char *string, va_list ap)\n{\n    char *p_is_s[NUM_PARM];\n    TPARM_ARG param[NUM_PARM];\n    int popcount = 0;\n    int number;\n    int num_args;\n    int len;\n    int level;\n    int x, y;\n    int i;\n    const char *cp = string;\n    size_t len2;\n    bool termcap_hack;\n    bool incremented_two;\n\n    if (cp == NULL)\n\treturn NULL;\n\n    TPS(out_used) = 0;\n    len2 = strlen(cp);\n\n    /*\n     * Find the highest parameter-number referred to in the format string.\n     * Use this value to limit the number of arguments copied from the\n     * variable-length argument list.\n     */\n    number = _nc_tparm_analyze(cp, p_is_s, &popcount);\n    if (TPS(fmt_buff) == 0)\n\treturn NULL;\n\n    incremented_two = FALSE;\n\n    if (number > NUM_PARM)\n\tnumber = NUM_PARM;\n    if (popcount > NUM_PARM)\n\tpopcount = NUM_PARM;\n    num_args = max(popcount, number);\n\n    for (i = 0; i < num_args; i++) {\n\t/*\n\t * A few caps (such as plab_norm) have string-valued parms.\n\t * We'll have to assume that the caller knows the difference, since\n\t * a char* and an int may not be the same size on the stack.  The\n\t * normal prototype for this uses 9 long's, which is consistent with\n\t * our va_arg() usage.\n\t */\n\tif (p_is_s[i] != 0) {\n\t    p_is_s[i] = va_arg(ap, char *);\n\t    param[i] = 0;\n\t} else if (use_TPARM_ARG) {\n\t    param[i] = va_arg(ap, TPARM_ARG);\n\t} else {\n\t    param[i] = (TPARM_ARG) va_arg(ap, int);\n\t}\n    }\n\n    /*\n     * This is a termcap compatibility hack.  If there are no explicit pop\n     * operations in the string, load the stack in such a way that\n     * successive pops will grab successive parameters.  That will make\n     * the expansion of (for example) \\E[%d;%dH work correctly in termcap\n     * style, which means tparam() will expand termcap strings OK.\n     */\n    TPS(stack_ptr) = 0;\n    termcap_hack = FALSE;\n    if (popcount == 0) {\n\ttermcap_hack = TRUE;\n\tfor (i = number - 1; i >= 0; i--) {\n\t    if (p_is_s[i])\n\t\tspush(p_is_s[i]);\n\t    else\n\t\tnpush((int) param[i]);\n\t}\n    }\n#ifdef TRACE\n    if (USE_TRACEF(TRACE_CALLS)) {\n\tfor (i = 0; i < num_args; i++) {\n\t    if (p_is_s[i] != 0) {\n\t\tsave_text(\", %s\", _nc_visbuf(p_is_s[i]), 0);\n\t    } else if ((long) param[i] > MAX_OF_TYPE(NCURSES_INT2) ||\n\t\t       (long) param[i] < 0) {\n\t\t_tracef(\"BUG: problem with tparm parameter #%d of %d\",\n\t\t\ti + 1, num_args);\n\t\tbreak;\n\t    } else {\n\t\tsave_number(\", %d\", (int) param[i], 0);\n\t    }\n\t}\n\t_tracef(T_CALLED(\"%s(%s%s)\"), TPS(tname), _nc_visbuf(cp), TPS(out_buff));\n\tTPS(out_used) = 0;\n\t_nc_unlock_global(tracef);\n    }\n#endif /* TRACE */\n\n    while ((cp - string) < (int) len2) {\n\tif (*cp != '%') {\n\t    save_char(UChar(*cp));\n\t} else {\n\t    TPS(tparam_base) = cp++;\n\t    cp = parse_format(cp, TPS(fmt_buff), &len);\n\t    switch (*cp) {\n\t    default:\n\t\tbreak;\n\t    case '%':\n\t\tsave_char('%');\n\t\tbreak;\n\n\t    case 'd':\t\t/* FALLTHRU */\n\t    case 'o':\t\t/* FALLTHRU */\n\t    case 'x':\t\t/* FALLTHRU */\n\t    case 'X':\t\t/* FALLTHRU */\n\t\tsave_number(TPS(fmt_buff), npop(), len);\n\t\tbreak;\n\n\t    case 'c':\t\t/* FALLTHRU */\n\t\tsave_char(npop());\n\t\tbreak;\n\n#ifdef EXP_XTERM_1005\n\t    case 'u':\n\t\t{\n\t\t    unsigned char target[10];\n\t\t    unsigned source = (unsigned) npop();\n\t\t    int rc = _nc_conv_to_utf8(target, source, (unsigned)\n\t\t\t\t\t      sizeof(target));\n\t\t    int n;\n\t\t    for (n = 0; n < rc; ++n) {\n\t\t\tsave_char(target[n]);\n\t\t    }\n\t\t}\n\t\tbreak;\n#endif\n\t    case 'l':\n\t\tnpush((int) strlen(spop()));\n\t\tbreak;\n\n\t    case 's':\n\t\tsave_text(TPS(fmt_buff), spop(), len);\n\t\tbreak;\n\n\t    case 'p':\n\t\tcp++;\n\t\ti = (UChar(*cp) - '1');\n\t\tif (i >= 0 && i < NUM_PARM) {\n\t\t    if (p_is_s[i]) {\n\t\t\tspush(p_is_s[i]);\n\t\t    } else {\n\t\t\tnpush((int) param[i]);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case 'P':\n\t\tcp++;\n\t\tif (isUPPER(*cp)) {\n\t\t    i = (UChar(*cp) - 'A');\n\t\t    TPS(static_vars)[i] = npop();\n\t\t} else if (isLOWER(*cp)) {\n\t\t    i = (UChar(*cp) - 'a');\n\t\t    TPS(dynamic_var)[i] = npop();\n\t\t}\n\t\tbreak;\n\n\t    case 'g':\n\t\tcp++;\n\t\tif (isUPPER(*cp)) {\n\t\t    i = (UChar(*cp) - 'A');\n\t\t    npush(TPS(static_vars)[i]);\n\t\t} else if (isLOWER(*cp)) {\n\t\t    i = (UChar(*cp) - 'a');\n\t\t    npush(TPS(dynamic_var)[i]);\n\t\t}\n\t\tbreak;\n\n\t    case S_QUOTE:\n\t\tcp++;\n\t\tnpush(UChar(*cp));\n\t\tcp++;\n\t\tbreak;\n\n\t    case L_BRACE:\n\t\tnumber = 0;\n\t\tcp++;\n\t\twhile (isdigit(UChar(*cp))) {\n\t\t    number = (number * 10) + (UChar(*cp) - '0');\n\t\t    cp++;\n\t\t}\n\t\tnpush(number);\n\t\tbreak;\n\n\t    case '+':\n\t\tnpush(npop() + npop());\n\t\tbreak;\n\n\t    case '-':\n\t\ty = npop();\n\t\tx = npop();\n\t\tnpush(x - y);\n\t\tbreak;\n\n\t    case '*':\n\t\tnpush(npop() * npop());\n\t\tbreak;\n\n\t    case '/':\n\t\ty = npop();\n\t\tx = npop();\n\t\tnpush(y ? (x / y) : 0);\n\t\tbreak;\n\n\t    case 'm':\n\t\ty = npop();\n\t\tx = npop();\n\t\tnpush(y ? (x % y) : 0);\n\t\tbreak;\n\n\t    case 'A':\n\t\ty = npop();\n\t\tx = npop();\n\t\tnpush(y && x);\n\t\tbreak;\n\n\t    case 'O':\n\t\ty = npop();\n\t\tx = npop();\n\t\tnpush(y || x);\n\t\tbreak;\n\n\t    case '&':\n\t\tnpush(npop() & npop());\n\t\tbreak;\n\n\t    case '|':\n\t\tnpush(npop() | npop());\n\t\tbreak;\n\n\t    case '^':\n\t\tnpush(npop() ^ npop());\n\t\tbreak;\n\n\t    case '=':\n\t\ty = npop();\n\t\tx = npop();\n\t\tnpush(x == y);\n\t\tbreak;\n\n\t    case '<':\n\t\ty = npop();\n\t\tx = npop();\n\t\tnpush(x < y);\n\t\tbreak;\n\n\t    case '>':\n\t\ty = npop();\n\t\tx = npop();\n\t\tnpush(x > y);\n\t\tbreak;\n\n\t    case '!':\n\t\tnpush(!npop());\n\t\tbreak;\n\n\t    case '~':\n\t\tnpush(~npop());\n\t\tbreak;\n\n\t    case 'i':\n\t\t/*\n\t\t * Increment the first two parameters -- if they are numbers\n\t\t * rather than strings.  As a side effect, assign into the\n\t\t * stack; if this is termcap, then the stack was populated\n\t\t * using the termcap hack above rather than via the terminfo\n\t\t * 'p' case.\n\t\t */\n\t\tif (!incremented_two) {\n\t\t    incremented_two = TRUE;\n\t\t    if (p_is_s[0] == 0) {\n\t\t\tparam[0]++;\n\t\t\tif (termcap_hack)\n\t\t\t    TPS(stack)[0].data.num = (int) param[0];\n\t\t    }\n\t\t    if (p_is_s[1] == 0) {\n\t\t\tparam[1]++;\n\t\t\tif (termcap_hack)\n\t\t\t    TPS(stack)[1].data.num = (int) param[1];\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case '?':\n\t\tbreak;\n\n\t    case 't':\n\t\tx = npop();\n\t\tif (!x) {\n\t\t    /* scan forward for %e or %; at level zero */\n\t\t    cp++;\n\t\t    level = 0;\n\t\t    while (*cp) {\n\t\t\tif (*cp == '%') {\n\t\t\t    cp++;\n\t\t\t    if (*cp == '?')\n\t\t\t\tlevel++;\n\t\t\t    else if (*cp == ';') {\n\t\t\t\tif (level > 0)\n\t\t\t\t    level--;\n\t\t\t\telse\n\t\t\t\t    break;\n\t\t\t    } else if (*cp == 'e' && level == 0)\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (*cp)\n\t\t\t    cp++;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case 'e':\n\t\t/* scan forward for a %; at level zero */\n\t\tcp++;\n\t\tlevel = 0;\n\t\twhile (*cp) {\n\t\t    if (*cp == '%') {\n\t\t\tcp++;\n\t\t\tif (*cp == '?')\n\t\t\t    level++;\n\t\t\telse if (*cp == ';') {\n\t\t\t    if (level > 0)\n\t\t\t\tlevel--;\n\t\t\t    else\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\n\t\t    if (*cp)\n\t\t\tcp++;\n\t\t}\n\t\tbreak;\n\n\t    case ';':\n\t\tbreak;\n\n\t    }\t\t\t/* endswitch (*cp) */\n\t}\t\t\t/* endelse (*cp == '%') */\n\n\tif (*cp == '\\0')\n\t    break;\n\n\tcp++;\n    }\t\t\t\t/* endwhile (*cp) */\n\n    get_space((size_t) 1);\n    TPS(out_buff)[TPS(out_used)] = '\\0';\n\n    T((T_RETURN(\"%s\"), _nc_visbuf(TPS(out_buff))));\n    return (TPS(out_buff));\n}\n\n#if NCURSES_TPARM_VARARGS\n#define tparm_varargs tparm\n#else\n#define tparm_proto tparm\n#endif\n\nNCURSES_EXPORT(char *)\ntparm_varargs(NCURSES_CONST char *string,...)\n{\n    va_list ap;\n    char *result;\n\n    _nc_tparm_err = 0;\n    va_start(ap, string);\n#ifdef TRACE\n    TPS(tname) = \"tparm\";\n#endif /* TRACE */\n    result = tparam_internal(TRUE, string, ap);\n    va_end(ap);\n    return result;\n}\n\n#if !NCURSES_TPARM_VARARGS\nNCURSES_EXPORT(char *)\ntparm_proto(NCURSES_CONST char *string,\n\t    TPARM_ARG a1,\n\t    TPARM_ARG a2,\n\t    TPARM_ARG a3,\n\t    TPARM_ARG a4,\n\t    TPARM_ARG a5,\n\t    TPARM_ARG a6,\n\t    TPARM_ARG a7,\n\t    TPARM_ARG a8,\n\t    TPARM_ARG a9)\n{\n    return tparm_varargs(string, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n}\n#endif /* NCURSES_TPARM_VARARGS */\n\nNCURSES_EXPORT(char *)\ntiparm(const char *string,...)\n{\n    va_list ap;\n    char *result;\n\n    _nc_tparm_err = 0;\n    va_start(ap, string);\n#ifdef TRACE\n    TPS(tname) = \"tiparm\";\n#endif /* TRACE */\n    result = tparam_internal(FALSE, string, ap);\n    va_end(ap);\n    return result;\n}\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n *\ttputs.c\n *\t\tdelay_output()\n *\t\t_nc_outch()\n *\t\ttputs()\n *\n */\n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\n#include <ctype.h>\n#include <termcap.h>\t\t/* ospeed */\n#include <tic.h>\n\nMODULE_ID(\"$Id: lib_tputs.c,v 1.100 2017/06/24 15:15:55 tom Exp $\")\n\nNCURSES_EXPORT_VAR(char) PC = 0;              /* used by termcap library */\nNCURSES_EXPORT_VAR(NCURSES_OSPEED) ospeed = 0;        /* used by termcap library */\n\nNCURSES_EXPORT_VAR(int) _nc_nulls_sent = 0;   /* used by 'tack' program */\n\n#if NCURSES_NO_PADDING\nNCURSES_EXPORT(void)\n_nc_set_no_padding(SCREEN *sp)\n{\n    bool no_padding = (getenv(\"NCURSES_NO_PADDING\") != 0);\n\n    if (sp)\n\tsp->_no_padding = no_padding;\n    else\n\t_nc_prescreen._no_padding = no_padding;\n\n    TR(TRACE_CHARPUT | TRACE_MOVE, (\"padding will%s be used\",\n\t\t\t\t    GetNoPadding(sp) ? \" not\" : \"\"));\n}\n#endif\n\n#if NCURSES_SP_FUNCS\n#define SetOutCh(func) if (SP_PARM) SP_PARM->_outch = func; else _nc_prescreen._outch = func\n#define GetOutCh()     (SP_PARM ? SP_PARM->_outch : _nc_prescreen._outch)\n#else\n#define SetOutCh(func) static_outch = func\n#define GetOutCh()     static_outch\nstatic NCURSES_SP_OUTC static_outch = NCURSES_SP_NAME(_nc_outch);\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(delay_output) (NCURSES_SP_DCLx int ms)\n{\n    T((T_CALLED(\"delay_output(%p,%d)\"), (void *) SP_PARM, ms));\n\n    if (!HasTInfoTerminal(SP_PARM))\n\treturnCode(ERR);\n\n    if (no_pad_char) {\n\tNCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n\tnapms(ms);\n    } else {\n\tNCURSES_SP_OUTC my_outch = GetOutCh();\n\tregister int nullcount;\n\n\tnullcount = (ms * _nc_baudrate(ospeed)) / (BAUDBYTE * 1000);\n\tfor (_nc_nulls_sent += nullcount; nullcount > 0; nullcount--)\n\t    my_outch(NCURSES_SP_ARGx PC);\n\tif (my_outch == NCURSES_SP_NAME(_nc_outch))\n\t    NCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n    }\n\n    returnCode(OK);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ndelay_output(int ms)\n{\n    return NCURSES_SP_NAME(delay_output) (CURRENT_SCREEN, ms);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_flush) (NCURSES_SP_DCL0)\n{\n    if (SP_PARM != 0 && SP_PARM->_ofd >= 0) {\n\tif (SP_PARM->out_inuse) {\n\t    char *buf = SP_PARM->out_buffer;\n\t    size_t amount = SP->out_inuse;\n\n\t    SP->out_inuse = 0;\n\t    while (amount) {\n\t\tssize_t res = write(SP_PARM->_ofd, buf, amount);\n\n\t\tif (res > 0) {\n\t\t    /* if the write was incomplete, try again */\n\t\t    amount -= (size_t) res;\n\t\t    buf += res;\n\t\t} else if (errno == EAGAIN) {\n\t\t    continue;\n\t\t} else if (errno == EINTR) {\n\t\t    continue;\n\t\t} else {\n\t\t    break;\t/* an error we can not recover from */\n\t\t}\n\t    }\n\t}\n    } else {\n\tfflush(stdout);\n    }\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_flush(void)\n{\n    NCURSES_SP_NAME(_nc_flush) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_outch) (NCURSES_SP_DCLx int ch)\n{\n    int rc = OK;\n\n    COUNT_OUTCHARS(1);\n\n    if (HasTInfoTerminal(SP_PARM)\n\t&& SP_PARM != 0) {\n\tif (SP_PARM->out_buffer != 0) {\n\t    if (SP_PARM->out_inuse + 1 >= SP_PARM->out_limit)\n\t\tNCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n\t    SP_PARM->out_buffer[SP_PARM->out_inuse++] = (char) ch;\n\t} else {\n\t    char tmp = (char) ch;\n\t    /*\n\t     * POSIX says write() is safe in a signal handler, but the\n\t     * buffered I/O is not.\n\t     */\n\t    if (write(fileno(NC_OUTPUT(SP_PARM)), &tmp, (size_t) 1) == -1)\n\t\trc = ERR;\n\t}\n    } else {\n\tchar tmp = (char) ch;\n\tif (write(fileno(stdout), &tmp, (size_t) 1) == -1)\n\t    rc = ERR;\n    }\n    return rc;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_outch(int ch)\n{\n    return NCURSES_SP_NAME(_nc_outch) (CURRENT_SCREEN, ch);\n}\n#endif\n\n/*\n * This is used for the putp special case.\n */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_putchar) (NCURSES_SP_DCLx int ch)\n{\n    (void) SP_PARM;\n    return putchar(ch);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_putchar(int ch)\n{\n    return putchar(ch);\n}\n#endif\n\n/*\n * putp is special - per documentation it calls tputs with putchar as the\n * parameter for outputting characters.  This means that it uses stdio, which\n * is not signal-safe.  Applications call this entrypoint; we do not call it\n * from within the library.\n */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(putp) (NCURSES_SP_DCLx const char *string)\n{\n    return NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t   string, 1, NCURSES_SP_NAME(_nc_putchar));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nputp(const char *string)\n{\n    return NCURSES_SP_NAME(putp) (CURRENT_SCREEN, string);\n}\n#endif\n\n/*\n * Use these entrypoints rather than \"putp\" within the library.\n */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_putp) (NCURSES_SP_DCLx\n\t\t\t   const char *name GCC_UNUSED,\n\t\t\t   const char *string)\n{\n    int rc = ERR;\n\n    if (string != 0) {\n\tTPUTS_TRACE(name);\n\trc = NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t     string, 1, NCURSES_SP_NAME(_nc_outch));\n    }\n    return rc;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_putp(const char *name, const char *string)\n{\n    return NCURSES_SP_NAME(_nc_putp) (CURRENT_SCREEN, name, string);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(tputs) (NCURSES_SP_DCLx\n\t\t\tconst char *string,\n\t\t\tint affcnt,\n\t\t\tNCURSES_SP_OUTC outc)\n{\n    NCURSES_SP_OUTC my_outch = GetOutCh();\n    bool always_delay;\n    bool normal_delay;\n    int number;\n#if BSD_TPUTS\n    int trailpad;\n#endif /* BSD_TPUTS */\n\n#ifdef TRACE\n    if (USE_TRACEF(TRACE_TPUTS)) {\n\tchar addrbuf[32];\n\n\tif (outc == NCURSES_SP_NAME(_nc_outch))\n\t    _nc_STRCPY(addrbuf, \"_nc_outch\", sizeof(addrbuf));\n\telse\n\t    _nc_SPRINTF(addrbuf, _nc_SLIMIT(sizeof(addrbuf)) \"%p\", TR_FUNC(outc));\n\tif (_nc_tputs_trace) {\n\t    _tracef(\"tputs(%s = %s, %d, %s) called\", _nc_tputs_trace,\n\t\t    _nc_visbuf(string), affcnt, addrbuf);\n\t} else {\n\t    _tracef(\"tputs(%s, %d, %s) called\", _nc_visbuf(string), affcnt, addrbuf);\n\t}\n\tTPUTS_TRACE(NULL);\n\t_nc_unlock_global(tracef);\n    }\n#endif /* TRACE */\n\n    if (SP_PARM != 0 && !HasTInfoTerminal(SP_PARM))\n\treturn ERR;\n\n    if (!VALID_STRING(string))\n\treturn ERR;\n\n    if (\n#if NCURSES_SP_FUNCS\n\t   (SP_PARM != 0 && SP_PARM->_term == 0)\n#else\n\t   cur_term == 0\n#endif\n\t) {\n\talways_delay = FALSE;\n\tnormal_delay = TRUE;\n    } else {\n\talways_delay = (string == bell) || (string == flash_screen);\n\tnormal_delay =\n\t    !xon_xoff\n\t    && padding_baud_rate\n#if NCURSES_NO_PADDING\n\t    && !GetNoPadding(SP_PARM)\n#endif\n\t    && (_nc_baudrate(ospeed) >= padding_baud_rate);\n    }\n\n#if BSD_TPUTS\n    /*\n     * This ugly kluge deals with the fact that some ancient BSD programs\n     * (like nethack) actually do the likes of tputs(\"50\") to get delays.\n     */\n    trailpad = 0;\n    if (isdigit(UChar(*string))) {\n\twhile (isdigit(UChar(*string))) {\n\t    trailpad = trailpad * 10 + (*string - '0');\n\t    string++;\n\t}\n\ttrailpad *= 10;\n\tif (*string == '.') {\n\t    string++;\n\t    if (isdigit(UChar(*string))) {\n\t\ttrailpad += (*string - '0');\n\t\tstring++;\n\t    }\n\t    while (isdigit(UChar(*string)))\n\t\tstring++;\n\t}\n\n\tif (*string == '*') {\n\t    trailpad *= affcnt;\n\t    string++;\n\t}\n    }\n#endif /* BSD_TPUTS */\n\n    SetOutCh(outc);\t\t/* redirect delay_output() */\n    while (*string) {\n\tif (*string != '$')\n\t    (*outc) (NCURSES_SP_ARGx *string);\n\telse {\n\t    string++;\n\t    if (*string != '<') {\n\t\t(*outc) (NCURSES_SP_ARGx '$');\n\t\tif (*string)\n\t\t    (*outc) (NCURSES_SP_ARGx *string);\n\t    } else {\n\t\tbool mandatory;\n\n\t\tstring++;\n\t\tif ((!isdigit(UChar(*string)) && *string != '.')\n\t\t    || !strchr(string, '>')) {\n\t\t    (*outc) (NCURSES_SP_ARGx '$');\n\t\t    (*outc) (NCURSES_SP_ARGx '<');\n\t\t    continue;\n\t\t}\n\n\t\tnumber = 0;\n\t\twhile (isdigit(UChar(*string))) {\n\t\t    number = number * 10 + (*string - '0');\n\t\t    string++;\n\t\t}\n\t\tnumber *= 10;\n\t\tif (*string == '.') {\n\t\t    string++;\n\t\t    if (isdigit(UChar(*string))) {\n\t\t\tnumber += (*string - '0');\n\t\t\tstring++;\n\t\t    }\n\t\t    while (isdigit(UChar(*string)))\n\t\t\tstring++;\n\t\t}\n\n\t\tmandatory = FALSE;\n\t\twhile (*string == '*' || *string == '/') {\n\t\t    if (*string == '*') {\n\t\t\tnumber *= affcnt;\n\t\t\tstring++;\n\t\t    } else {\t/* if (*string == '/') */\n\t\t\tmandatory = TRUE;\n\t\t\tstring++;\n\t\t    }\n\t\t}\n\n\t\tif (number > 0\n\t\t    && (always_delay\n\t\t\t|| normal_delay\n\t\t\t|| mandatory))\n\t\t    NCURSES_SP_NAME(delay_output) (NCURSES_SP_ARGx number / 10);\n\n\t    }\t\t\t/* endelse (*string == '<') */\n\t}\t\t\t/* endelse (*string == '$') */\n\n\tif (*string == '\\0')\n\t    break;\n\n\tstring++;\n    }\n\n#if BSD_TPUTS\n    /*\n     * Emit any BSD-style prefix padding that we've accumulated now.\n     */\n    if (trailpad > 0\n\t&& (always_delay || normal_delay))\n\tdelay_output(trailpad / 10);\n#endif /* BSD_TPUTS */\n\n    SetOutCh(my_outch);\n    return OK;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_outc_wrapper(SCREEN *sp, int c)\n{\n    if (0 == sp) {\n\treturn fputc(c, stdout);\n    } else {\n\treturn sp->jump(c);\n    }\n}\n\nNCURSES_EXPORT(int)\ntputs(const char *string, int affcnt, int (*outc) (int))\n{\n    SetSafeOutcWrapper(outc);\n    return NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx string, affcnt, _nc_outc_wrapper);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                                                 *\n ****************************************************************************/\n\n/*\n *\tlib_trace.c - Tracing/Debugging routines\n *\n * The _tracef() function is originally from pcurses (by Pavel Curtis) in 1982. \n * pcurses allowed one to enable/disable tracing using traceon() and traceoff()\n * functions.  ncurses provides a trace() function which allows one to\n * selectively enable or disable several tracing features.\n */\n\n#include <curses.priv.h>\n#include <tic.h>\n\n#include <ctype.h>\n\nMODULE_ID(\"$Id: lib_trace.c,v 1.86 2017/01/14 17:53:42 tom Exp $\")\n\nNCURSES_EXPORT_VAR(unsigned) _nc_tracing = 0; /* always define this */\n\n#ifdef TRACE\n\n#if USE_REENTRANT\nNCURSES_EXPORT(const char *)\nNCURSES_PUBLIC_VAR(_nc_tputs_trace) (void)\n{\n    return CURRENT_SCREEN ? CURRENT_SCREEN->_tputs_trace : _nc_prescreen._tputs_trace;\n}\nNCURSES_EXPORT(long)\nNCURSES_PUBLIC_VAR(_nc_outchars) (void)\n{\n    return CURRENT_SCREEN ? CURRENT_SCREEN->_outchars : _nc_prescreen._outchars;\n}\nNCURSES_EXPORT(void)\n_nc_set_tputs_trace(const char *s)\n{\n    if (CURRENT_SCREEN)\n\tCURRENT_SCREEN->_tputs_trace = s;\n    else\n\t_nc_prescreen._tputs_trace = s;\n}\nNCURSES_EXPORT(void)\n_nc_count_outchars(long increment)\n{\n    if (CURRENT_SCREEN)\n\tCURRENT_SCREEN->_outchars += increment;\n    else\n\t_nc_prescreen._outchars += increment;\n}\n#else\nNCURSES_EXPORT_VAR(const char *) _nc_tputs_trace = \"\";\nNCURSES_EXPORT_VAR(long) _nc_outchars = 0;\n#endif\n\n#define MyFP\t\t_nc_globals.trace_fp\n#define MyFD\t\t_nc_globals.trace_fd\n#define MyInit\t\t_nc_globals.trace_opened\n#define MyPath\t\t_nc_globals.trace_fname\n#define MyLevel\t\t_nc_globals.trace_level\n#define MyNested\t_nc_globals.nested_tracef\n\nNCURSES_EXPORT(void)\ntrace(const unsigned int tracelevel)\n{\n    if ((MyFP == 0) && tracelevel) {\n\tMyInit = TRUE;\n\tif (MyFD >= 0) {\n\t    MyFP = fdopen(MyFD, \"wb\");\n\t} else {\n\t    if (MyPath[0] == '\\0') {\n\t\tsize_t size = sizeof(MyPath) - 12;\n\t\tif (getcwd(MyPath, size) == 0) {\n\t\t    perror(\"curses: Can't get working directory\");\n\t\t    exit(EXIT_FAILURE);\n\t\t}\n\t\tMyPath[size] = '\\0';\n\t\tassert(strlen(MyPath) <= size);\n\t\t_nc_STRCAT(MyPath, \"/trace\", sizeof(MyPath));\n\t\tif (_nc_is_dir_path(MyPath)) {\n\t\t    _nc_STRCAT(MyPath, \".log\", sizeof(MyPath));\n\t\t}\n\t    }\n\t    if (_nc_access(MyPath, W_OK) < 0\n\t\t|| (MyFD = open(MyPath, O_CREAT | O_EXCL | O_RDWR, 0600)) < 0\n\t\t|| (MyFP = fdopen(MyFD, \"wb\")) == 0) {\n\t\t;\t\t/* EMPTY */\n\t    }\n\t}\n\t_nc_tracing = tracelevel;\n\t/* Try to set line-buffered mode, or (failing that) unbuffered,\n\t * so that the trace-output gets flushed automatically at the\n\t * end of each line.  This is useful in case the program dies. \n\t */\n\tif (MyFP != 0) {\n#if HAVE_SETVBUF\t\t/* ANSI */\n\t    (void) setvbuf(MyFP, (char *) 0, _IOLBF, (size_t) 0);\n#elif HAVE_SETBUF /* POSIX */\n\t    (void) setbuffer(MyFP, (char *) 0);\n#endif\n\t}\n\t_tracef(\"TRACING NCURSES version %s.%d (tracelevel=%#x)\",\n\t\tNCURSES_VERSION,\n\t\tNCURSES_VERSION_PATCH,\n\t\ttracelevel);\n    } else if (tracelevel == 0) {\n\tif (MyFP != 0) {\n\t    MyFD = dup(MyFD);\t/* allow reopen of same file */\n\t    fclose(MyFP);\n\t    MyFP = 0;\n\t}\n\t_nc_tracing = tracelevel;\n    } else if (_nc_tracing != tracelevel) {\n\t_nc_tracing = tracelevel;\n\t_tracef(\"tracelevel=%#x\", tracelevel);\n    }\n}\n\nstatic void\n_nc_va_tracef(const char *fmt, va_list ap)\n{\n    static const char Called[] = T_CALLED(\"\");\n    static const char Return[] = T_RETURN(\"\");\n\n    bool before = FALSE;\n    bool after = FALSE;\n    unsigned doit = _nc_tracing;\n    int save_err = errno;\n    FILE *fp = MyFP;\n\n#ifdef TRACE\n    /* verbose-trace in the command-line utilities relies on this */\n    if (fp == 0 && !MyInit && _nc_tracing >= DEBUG_LEVEL(1))\n\tfp = stderr;\n#endif\n\n    if (strlen(fmt) >= sizeof(Called) - 1) {\n\tif (!strncmp(fmt, Called, sizeof(Called) - 1)) {\n\t    before = TRUE;\n\t    MyLevel++;\n\t} else if (!strncmp(fmt, Return, sizeof(Return) - 1)) {\n\t    after = TRUE;\n\t}\n\tif (before || after) {\n\t    if ((MyLevel <= 1)\n\t\t|| (doit & TRACE_ICALLS) != 0)\n\t\tdoit &= (TRACE_CALLS | TRACE_CCALLS);\n\t    else\n\t\tdoit = 0;\n\t}\n    }\n\n    if (doit != 0 && fp != 0) {\n#ifdef USE_PTHREADS\n\t/*\n\t * TRACE_ICALLS is \"really\" needed to show normal use with threaded\n\t * applications, since anything can be running during a napms(),\n\t * making it appear in the hierarchical trace as it other functions\n\t * are being called.\n\t *\n\t * Rather than add the complication of a per-thread stack, just\n\t * show the thread-id in each line of the trace.\n\t */\n# if USE_WEAK_SYMBOLS\n\tif ((pthread_self))\n# endif\n#ifdef __MINGW32__\n\t    fprintf(fp, \"%#lx:\", (long) (intptr_t) pthread_self().p);\n#else\n\t    fprintf(fp, \"%#lx:\", (long) (intptr_t) pthread_self());\n#endif\n#endif\n\tif (before || after) {\n\t    int n;\n\t    for (n = 1; n < MyLevel; n++)\n\t\tfputs(\"+ \", fp);\n\t}\n\tvfprintf(fp, fmt, ap);\n\tfputc('\\n', fp);\n\tfflush(fp);\n    }\n\n    if (after && MyLevel)\n\tMyLevel--;\n\n    errno = save_err;\n}\n\nNCURSES_EXPORT(void)\n_tracef(const char *fmt,...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    _nc_va_tracef(fmt, ap);\n    va_end(ap);\n}\n\n/* Trace 'bool' return-values */\nNCURSES_EXPORT(NCURSES_BOOL)\n_nc_retrace_bool(int code)\n{\n    T((T_RETURN(\"%s\"), code ? \"TRUE\" : \"FALSE\"));\n    return code;\n}\n\n/* Trace 'char' return-values */\nNCURSES_EXPORT(char)\n_nc_retrace_char(int code)\n{\n    T((T_RETURN(\"%c\"), code));\n    return (char) code;\n}\n\n/* Trace 'int' return-values */\nNCURSES_EXPORT(int)\n_nc_retrace_int(int code)\n{\n    T((T_RETURN(\"%d\"), code));\n    return code;\n}\n\n/* Trace 'unsigned' return-values */\nNCURSES_EXPORT(unsigned)\n_nc_retrace_unsigned(unsigned code)\n{\n    T((T_RETURN(\"%#x\"), code));\n    return code;\n}\n\n/* Trace 'char*' return-values */\nNCURSES_EXPORT(char *)\n_nc_retrace_ptr(char *code)\n{\n    T((T_RETURN(\"%s\"), _nc_visbuf(code)));\n    return code;\n}\n\n/* Trace 'const char*' return-values */\nNCURSES_EXPORT(const char *)\n_nc_retrace_cptr(const char *code)\n{\n    T((T_RETURN(\"%s\"), _nc_visbuf(code)));\n    return code;\n}\n\n/* Trace 'NCURSES_CONST void*' return-values */\nNCURSES_EXPORT(NCURSES_CONST void *)\n_nc_retrace_cvoid_ptr(NCURSES_CONST void *code)\n{\n    T((T_RETURN(\"%p\"), code));\n    return code;\n}\n\n/* Trace 'void*' return-values */\nNCURSES_EXPORT(void *)\n_nc_retrace_void_ptr(void *code)\n{\n    T((T_RETURN(\"%p\"), code));\n    return code;\n}\n\n/* Trace 'SCREEN *' return-values */\nNCURSES_EXPORT(SCREEN *)\n_nc_retrace_sp(SCREEN *code)\n{\n    T((T_RETURN(\"%p\"), (void *) code));\n    return code;\n}\n\n/* Trace 'WINDOW *' return-values */\nNCURSES_EXPORT(WINDOW *)\n_nc_retrace_win(WINDOW *code)\n{\n    T((T_RETURN(\"%p\"), (void *) code));\n    return code;\n}\n\n#if USE_REENTRANT\n/*\n * Check if the given trace-mask is enabled.\n *\n * This function may be called from within one of the functions that fills\n * in parameters for _tracef(), but in that case we do not want to lock the\n * mutex, since it is already locked.\n */\nNCURSES_EXPORT(int)\n_nc_use_tracef(unsigned mask)\n{\n    bool result = FALSE;\n\n    _nc_lock_global(tst_tracef);\n    if (!MyNested++) {\n\tif ((result = (_nc_tracing & (mask))) != 0\n\t    && _nc_try_global(tracef) == 0) {\n\t    /* we will call _nc_locked_tracef(), no nesting so far */\n\t} else {\n\t    /* we will not call _nc_locked_tracef() */\n\t    MyNested = 0;\n\t}\n    } else {\n\t/* we may call _nc_locked_tracef(), but with nested_tracef > 0 */\n\tresult = (_nc_tracing & (mask));\n    }\n    _nc_unlock_global(tst_tracef);\n    return result;\n}\n\n/*\n * We call this if _nc_use_tracef() returns true, which means we must unlock\n * the tracef mutex.\n */\nNCURSES_EXPORT(void)\n_nc_locked_tracef(const char *fmt,...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    _nc_va_tracef(fmt, ap);\n    va_end(ap);\n\n    if (--(MyNested) == 0) {\n\t_nc_unlock_global(tracef);\n    }\n}\n#endif /* USE_REENTRANT */\n\n#endif /* TRACE */\n","/****************************************************************************\n * Copyright (c) 1998-2017,2018 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas Dickey                           1996-on                 *\n *     and: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Juergen Pfeifer                                                 *\n ****************************************************************************/\n\n/*\n *\tlib_traceatr.c - Tracing/Debugging routines (attributes)\n */\n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_traceatr.c,v 1.91 2018/01/07 02:22:01 tom Exp $\")\n\n#define COLOR_OF(c) ((c < 0) ? \"default\" : (c > 7 ? color_of(c) : colors[c].name))\n\n#define TRACE_BUF_SIZE(num) (_nc_globals.tracebuf_ptr[num].size)\n#define COLOR_BUF_SIZE(num) (sizeof(my_buffer[num]))\n\n#ifdef TRACE\n\nstatic const char l_brace[] = StringOf(L_BRACE);\nstatic const char r_brace[] = StringOf(R_BRACE);\n\n#ifndef USE_TERMLIB\n\n#define my_buffer _nc_globals.traceatr_color_buf\n#define my_select _nc_globals.traceatr_color_sel\n#define my_cached _nc_globals.traceatr_color_last\n\nstatic char *\ncolor_of(int c)\n{\n    if (c != my_cached) {\n\tmy_cached = c;\n\tmy_select = !my_select;\n\tif (isDefaultColor(c))\n\t    _nc_STRCPY(my_buffer[my_select], \"default\",\n\t\t       COLOR_BUF_SIZE(my_select));\n\telse\n\t    _nc_SPRINTF(my_buffer[my_select],\n\t\t\t_nc_SLIMIT(COLOR_BUF_SIZE(my_select))\n\t\t\t\"color%d\", c);\n    }\n    return my_buffer[my_select];\n}\n\n#undef my_buffer\n#undef my_select\n#endif /* !USE_TERMLIB */\n\nNCURSES_EXPORT(char *)\n_traceattr2(int bufnum, chtype newmode)\n{\n#define DATA(name) { name, { #name } }\n    static const struct {\n\tunsigned int val;\n\tconst char name[14];\n    } names[] =\n    {\n\tDATA(A_STANDOUT),\n\t    DATA(A_UNDERLINE),\n\t    DATA(A_REVERSE),\n\t    DATA(A_BLINK),\n\t    DATA(A_DIM),\n\t    DATA(A_BOLD),\n\t    DATA(A_ALTCHARSET),\n\t    DATA(A_INVIS),\n\t    DATA(A_PROTECT),\n\t    DATA(A_CHARTEXT),\n\t    DATA(A_NORMAL),\n\t    DATA(A_COLOR),\n#if USE_ITALIC\n\t    DATA(A_ITALIC),\n#endif\n    }\n#ifndef USE_TERMLIB\n    ,\n\tcolors[] =\n    {\n\tDATA(COLOR_BLACK),\n\t    DATA(COLOR_RED),\n\t    DATA(COLOR_GREEN),\n\t    DATA(COLOR_YELLOW),\n\t    DATA(COLOR_BLUE),\n\t    DATA(COLOR_MAGENTA),\n\t    DATA(COLOR_CYAN),\n\t    DATA(COLOR_WHITE),\n    }\n#endif /* !USE_TERMLIB */\n    ;\n#undef DATA\n    char *result = _nc_trace_buf(bufnum, (size_t) BUFSIZ);\n\n    if (result != 0) {\n\tsize_t n;\n\tunsigned save_nc_tracing = _nc_tracing;\n\n\t_nc_tracing = 0;\n\n\t_nc_STRCPY(result, l_brace, TRACE_BUF_SIZE(bufnum));\n\n\tfor (n = 0; n < SIZEOF(names); n++) {\n\n\t    if ((newmode & names[n].val) != 0) {\n\t\tif (result[1] != '\\0')\n\t\t    (void) _nc_trace_bufcat(bufnum, \"|\");\n\t\tresult = _nc_trace_bufcat(bufnum, names[n].name);\n\n\t\tif (names[n].val == A_COLOR) {\n\t\t    char temp[80];\n\t\t    short pairnum = (short) PairNumber(newmode);\n#ifdef USE_TERMLIB\n\t\t    /* pair_content lives in libncurses */\n\t\t    _nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t\t\"{%d}\", pairnum);\n#else\n\t\t    NCURSES_COLOR_T fg, bg;\n\n\t\t    if (pair_content(pairnum, &fg, &bg) == OK) {\n\t\t\t_nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t\t    \"{%d = {%s, %s}}\",\n\t\t\t\t    pairnum,\n\t\t\t\t    COLOR_OF(fg),\n\t\t\t\t    COLOR_OF(bg));\n\t\t    } else {\n\t\t\t_nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t\t    \"{%d}\", pairnum);\n\t\t    }\n#endif\n\t\t    result = _nc_trace_bufcat(bufnum, temp);\n\t\t}\n\t    }\n\t}\n\tif (ChAttrOf(newmode) == A_NORMAL) {\n\t    if (result != 0 && result[1] != '\\0')\n\t\t(void) _nc_trace_bufcat(bufnum, \"|\");\n\t    (void) _nc_trace_bufcat(bufnum, \"A_NORMAL\");\n\t}\n\n\t_nc_tracing = save_nc_tracing;\n\tresult = _nc_trace_bufcat(bufnum, r_brace);\n    }\n    return result;\n}\n\nNCURSES_EXPORT(char *)\n_traceattr(attr_t newmode)\n{\n    return _traceattr2(0, newmode);\n}\n\n/* Trace 'int' return-values */\nNCURSES_EXPORT(int)\n_nc_retrace_int_attr_t(attr_t code)\n{\n    T((T_RETURN(\"%s\"), _traceattr(code)));\n    return (int) code;\n}\n\n/* Trace 'attr_t' return-values */\nNCURSES_EXPORT(attr_t)\n_nc_retrace_attr_t(attr_t code)\n{\n    T((T_RETURN(\"%s\"), _traceattr(code)));\n    return code;\n}\n\nconst char *\n_nc_altcharset_name(attr_t attr, chtype ch)\n{\n#define DATA(code, name) { code, { #name } }\n    typedef struct {\n\tunsigned int val;\n\tconst char name[13];\n    } ALT_NAMES;\n#if NCURSES_SP_FUNCS\n    SCREEN *sp = CURRENT_SCREEN;\n#endif\n    static const ALT_NAMES names[] =\n    {\n\tDATA('l', ACS_ULCORNER),\t/* upper left corner */\n\tDATA('m', ACS_LLCORNER),\t/* lower left corner */\n\tDATA('k', ACS_URCORNER),\t/* upper right corner */\n\tDATA('j', ACS_LRCORNER),\t/* lower right corner */\n\tDATA('t', ACS_LTEE),\t/* tee pointing right */\n\tDATA('u', ACS_RTEE),\t/* tee pointing left */\n\tDATA('v', ACS_BTEE),\t/* tee pointing up */\n\tDATA('w', ACS_TTEE),\t/* tee pointing down */\n\tDATA('q', ACS_HLINE),\t/* horizontal line */\n\tDATA('x', ACS_VLINE),\t/* vertical line */\n\tDATA('n', ACS_PLUS),\t/* large plus or crossover */\n\tDATA('o', ACS_S1),\t/* scan line 1 */\n\tDATA('s', ACS_S9),\t/* scan line 9 */\n\tDATA('`', ACS_DIAMOND),\t/* diamond */\n\tDATA('a', ACS_CKBOARD),\t/* checker board (stipple) */\n\tDATA('f', ACS_DEGREE),\t/* degree symbol */\n\tDATA('g', ACS_PLMINUS),\t/* plus/minus */\n\tDATA('~', ACS_BULLET),\t/* bullet */\n\tDATA(',', ACS_LARROW),\t/* arrow pointing left */\n\tDATA('+', ACS_RARROW),\t/* arrow pointing right */\n\tDATA('.', ACS_DARROW),\t/* arrow pointing down */\n\tDATA('-', ACS_UARROW),\t/* arrow pointing up */\n\tDATA('h', ACS_BOARD),\t/* board of squares */\n\tDATA('i', ACS_LANTERN),\t/* lantern symbol */\n\tDATA('0', ACS_BLOCK),\t/* solid square block */\n\tDATA('p', ACS_S3),\t/* scan line 3 */\n\tDATA('r', ACS_S7),\t/* scan line 7 */\n\tDATA('y', ACS_LEQUAL),\t/* less/equal */\n\tDATA('z', ACS_GEQUAL),\t/* greater/equal */\n\tDATA('{', ACS_PI),\t/* Pi */\n\tDATA('|', ACS_NEQUAL),\t/* not equal */\n\tDATA('}', ACS_STERLING),\t/* UK pound sign */\n    };\n#undef DATA\n\n    const char *result = 0;\n\n#if NCURSES_SP_FUNCS\n    (void) sp;\n#endif\n    if (SP_PARM != 0 && (attr & A_ALTCHARSET) && (acs_chars != 0)) {\n\tchar *cp;\n\tchar *found = 0;\n\n\tfor (cp = acs_chars; cp[0] && cp[1]; cp += 2) {\n\t    if (ChCharOf(UChar(cp[1])) == ChCharOf(ch)) {\n\t\tfound = cp;\n\t\t/* don't exit from loop - there may be redefinitions */\n\t    }\n\t}\n\n\tif (found != 0) {\n\t    size_t n;\n\n\t    ch = ChCharOf(UChar(*found));\n\t    for (n = 0; n < SIZEOF(names); ++n) {\n\t\tif (names[n].val == ch) {\n\t\t    result = names[n].name;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n    return result;\n}\n\nNCURSES_EXPORT(char *)\n_tracechtype2(int bufnum, chtype ch)\n{\n    char *result = _nc_trace_buf(bufnum, (size_t) BUFSIZ);\n\n    if (result != 0) {\n\tconst char *found;\n\n\t_nc_STRCPY(result, l_brace, TRACE_BUF_SIZE(bufnum));\n\tif ((found = _nc_altcharset_name(ChAttrOf(ch), ch)) != 0) {\n\t    (void) _nc_trace_bufcat(bufnum, found);\n\t} else\n\t    (void) _nc_trace_bufcat(bufnum,\n\t\t\t\t    _nc_tracechar(CURRENT_SCREEN,\n\t\t\t\t\t\t  (int) ChCharOf(ch)));\n\n\tif (ChAttrOf(ch) != A_NORMAL) {\n\t    (void) _nc_trace_bufcat(bufnum, \" | \");\n\t    (void) _nc_trace_bufcat(bufnum,\n\t\t\t\t    _traceattr2(bufnum + 20, ChAttrOf(ch)));\n\t}\n\n\tresult = _nc_trace_bufcat(bufnum, r_brace);\n    }\n    return result;\n}\n\nNCURSES_EXPORT(char *)\n_tracechtype(chtype ch)\n{\n    return _tracechtype2(0, ch);\n}\n\n/* Trace 'chtype' return-values */\nNCURSES_EXPORT(chtype)\n_nc_retrace_chtype(chtype code)\n{\n    T((T_RETURN(\"%s\"), _tracechtype(code)));\n    return code;\n}\n\n#if USE_WIDEC_SUPPORT\nNCURSES_EXPORT(char *)\n_tracecchar_t2(int bufnum, const cchar_t *ch)\n{\n    char *result = _nc_trace_buf(bufnum, (size_t) BUFSIZ);\n\n    if (result != 0) {\n\t_nc_STRCPY(result, l_brace, TRACE_BUF_SIZE(bufnum));\n\tif (ch != 0) {\n\t    const char *found;\n\t    attr_t attr = AttrOfD(ch);\n\n\t    if ((found = _nc_altcharset_name(attr, (chtype) CharOfD(ch))) != 0) {\n\t\t(void) _nc_trace_bufcat(bufnum, found);\n\t\tattr &= ~A_ALTCHARSET;\n\t    } else if (isWidecExt(CHDEREF(ch))) {\n\t\t(void) _nc_trace_bufcat(bufnum, \"{NAC}\");\n\t\tattr &= ~A_CHARTEXT;\n\t    } else {\n\t\tPUTC_DATA;\n\t\tint n;\n\n\t\t(void) _nc_trace_bufcat(bufnum, \"{ \");\n\t\tfor (PUTC_i = 0; PUTC_i < CCHARW_MAX; ++PUTC_i) {\n\t\t    PUTC_ch = ch->chars[PUTC_i];\n\t\t    if (PUTC_ch == L'\\0') {\n\t\t\tif (PUTC_i == 0)\n\t\t\t    (void) _nc_trace_bufcat(bufnum, \"\\\\000\");\n\t\t\tbreak;\n\t\t    }\n\t\t    PUTC_INIT;\n\t\t    PUTC_n = (int) wcrtomb(PUTC_buf, ch->chars[PUTC_i], &PUT_st);\n\t\t    if (PUTC_n <= 0) {\n\t\t\tif (PUTC_ch != L'\\0') {\n\t\t\t    /* it could not be a multibyte sequence */\n\t\t\t    (void) _nc_trace_bufcat(bufnum,\n\t\t\t\t\t\t    _nc_tracechar(CURRENT_SCREEN,\n\t\t\t\t\t\t\t\t  UChar(ch->chars[PUTC_i])));\n\t\t\t}\n\t\t\tbreak;\n\t\t    } else if (ch->chars[PUTC_i] > 255) {\n\t\t\tchar temp[80];\n\t\t\t_nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t\t    \"{%d:\\\\u%lx}\",\n\t\t\t\t    wcwidth(ch->chars[PUTC_i]),\n\t\t\t\t    (unsigned long) ch->chars[PUTC_i]);\n\t\t\t(void) _nc_trace_bufcat(bufnum, temp);\n\t\t\tbreak;\n\t\t    }\n\t\t    for (n = 0; n < PUTC_n; n++) {\n\t\t\tif (n)\n\t\t\t    (void) _nc_trace_bufcat(bufnum, \", \");\n\t\t\t(void) _nc_trace_bufcat(bufnum,\n\t\t\t\t\t\t_nc_tracechar(CURRENT_SCREEN,\n\t\t\t\t\t\t\t      UChar(PUTC_buf[n])));\n\t\t    }\n\t\t}\n\t\t(void) _nc_trace_bufcat(bufnum, \" }\");\n\t    }\n\t    if (attr != A_NORMAL) {\n\t\t(void) _nc_trace_bufcat(bufnum, \" | \");\n\t\t(void) _nc_trace_bufcat(bufnum, _traceattr2(bufnum + 20, attr));\n\t    }\n#if NCURSES_EXT_COLORS\n\t    /*\n\t     * Just in case the extended color is different from the chtype\n\t     * value, trace both.\n\t     */\n\t    if (ch->ext_color != PairNumber(attr)) {\n\t\tchar temp[80];\n\t\t_nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t    \" X_COLOR{%d:%d}\", ch->ext_color, PairNumber(attr));\n\t\t(void) _nc_trace_bufcat(bufnum, temp);\n\t    }\n#endif\n\t}\n\n\tresult = _nc_trace_bufcat(bufnum, r_brace);\n    }\n    return result;\n}\n\nNCURSES_EXPORT(char *)\n_tracecchar_t(const cchar_t *ch)\n{\n    return _tracecchar_t2(0, ch);\n}\n#endif\n\n#else\nEMPTY_MODULE(_nc_lib_traceatr)\n#endif /* TRACE */\n","/****************************************************************************\n * Copyright (c) 1998-2012,2015 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n ****************************************************************************/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_tracebits.c,v 1.26 2015/04/19 14:58:39 tom Exp $\")\n\n#if HAVE_SYS_TERMIO_H\n#include <sys/termio.h>\t\t/* needed for ISC */\n#endif\n\n#ifdef __EMX__\n#include <io.h>\n#endif\n\n/* may be undefined if we're using termio.h */\n#ifndef TOSTOP\n#define TOSTOP 0\n#endif\n\n#ifndef IEXTEN\n#define IEXTEN 0\n#endif\n\n#ifndef ONLCR\n#define ONLCR 0\n#endif\n\n#ifndef OCRNL\n#define OCRNL 0\n#endif\n\n#ifndef ONOCR\n#define ONOCR 0\n#endif\n\n#ifndef ONLRET\n#define ONLRET 0\n#endif\n\n#ifdef TRACE\n\ntypedef struct {\n    unsigned int val;\n    const char name[8];\n} BITNAMES;\n\n#define TRACE_BUF_SIZE(num) (_nc_globals.tracebuf_ptr[num].size)\n\nstatic void\nlookup_bits(char *buf, const BITNAMES * table, const char *label, unsigned int val)\n{\n    const BITNAMES *sp;\n\n    _nc_STRCAT(buf, label, TRACE_BUF_SIZE(0));\n    _nc_STRCAT(buf, \": {\", TRACE_BUF_SIZE(0));\n    for (sp = table; sp->name[0]; sp++)\n\tif (sp->val != 0\n\t    && (val & sp->val) == sp->val) {\n\t    _nc_STRCAT(buf, sp->name, TRACE_BUF_SIZE(0));\n\t    _nc_STRCAT(buf, \", \", TRACE_BUF_SIZE(0));\n\t}\n    if (buf[strlen(buf) - 2] == ',')\n\tbuf[strlen(buf) - 2] = '\\0';\n    _nc_STRCAT(buf, \"} \", TRACE_BUF_SIZE(0));\n}\n\nNCURSES_EXPORT(char *)\n_nc_trace_ttymode(TTY * tty)\n/* describe the state of the terminal control bits exactly */\n{\n    char *buf;\n\n#ifdef TERMIOS\n#define DATA(name)        { name, { #name } }\n#define DATA2(name,name2) { name, { #name2 } }\n#define DATAX()           { 0,    { \"\" } }\n    static const BITNAMES iflags[] =\n    {\n\tDATA(BRKINT),\n\tDATA(IGNBRK),\n\tDATA(IGNPAR),\n\tDATA(PARMRK),\n\tDATA(INPCK),\n\tDATA(ISTRIP),\n\tDATA(INLCR),\n\tDATA(IGNCR),\n\tDATA(ICRNL),\n\tDATA(IXON),\n\tDATA(IXOFF),\n\tDATAX()\n#define ALLIN\t(BRKINT|IGNBRK|IGNPAR|PARMRK|INPCK|ISTRIP|INLCR|IGNCR|ICRNL|IXON|IXOFF)\n    }, oflags[] =\n    {\n\tDATA(OPOST),\n\tDATA2(OFLAGS_TABS, XTABS),\n\tDATA(ONLCR),\n\tDATA(OCRNL),\n\tDATA(ONOCR),\n\tDATA(ONLRET),\n\tDATAX()\n#define ALLOUT\t(OPOST|OFLAGS_TABS|ONLCR|OCRNL|ONOCR|ONLRET)\n    }, cflags[] =\n    {\n\tDATA(CLOCAL),\n\tDATA(CREAD),\n\tDATA(CSTOPB),\n#if !defined(CS5) || !defined(CS8)\n\tDATA(CSIZE),\n#endif\n\tDATA(HUPCL),\n\tDATA(PARENB),\n\tDATA2(PARODD | PARENB, PARODD),\n\tDATAX()\n#define ALLCTRL\t(CLOCAL|CREAD|CSIZE|CSTOPB|HUPCL|PARENB|PARODD)\n    }, lflags[] =\n    {\n\tDATA(ECHO),\n\tDATA2(ECHOE | ECHO, ECHOE),\n\tDATA2(ECHOK | ECHO, ECHOK),\n\tDATA(ECHONL),\n\tDATA(ICANON),\n\tDATA(ISIG),\n\tDATA(NOFLSH),\n\tDATA(TOSTOP),\n\tDATA(IEXTEN),\n\tDATAX()\n#define ALLLOCAL\t(ECHO|ECHONL|ICANON|ISIG|NOFLSH|TOSTOP|IEXTEN)\n    };\n\n    buf = _nc_trace_buf(0,\n\t\t\t8 + sizeof(iflags) +\n\t\t\t8 + sizeof(oflags) +\n\t\t\t8 + sizeof(cflags) +\n\t\t\t8 + sizeof(lflags) +\n\t\t\t8);\n    if (buf != 0) {\n\n\tif (tty->c_iflag & ALLIN)\n\t    lookup_bits(buf, iflags, \"iflags\", tty->c_iflag);\n\n\tif (tty->c_oflag & ALLOUT)\n\t    lookup_bits(buf, oflags, \"oflags\", tty->c_oflag);\n\n\tif (tty->c_cflag & ALLCTRL)\n\t    lookup_bits(buf, cflags, \"cflags\", tty->c_cflag);\n\n#if defined(CS5) && defined(CS8)\n\t{\n\t    static const struct {\n\t\tint value;\n\t\tconst char name[5];\n\t    } csizes[] = {\n#define CS_DATA(name) { name, { #name \" \" } }\n\t\tCS_DATA(CS5),\n#ifdef CS6\n\t\t    CS_DATA(CS6),\n#endif\n#ifdef CS7\n\t\t    CS_DATA(CS7),\n#endif\n\t\t    CS_DATA(CS8),\n\t    };\n\t    const char *result = \"CSIZE? \";\n\t    int value = (int) (tty->c_cflag & CSIZE);\n\t    unsigned n;\n\n\t    if (value != 0) {\n\t\tfor (n = 0; n < SIZEOF(csizes); n++) {\n\t\t    if (csizes[n].value == value) {\n\t\t\tresult = csizes[n].name;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    _nc_STRCAT(buf, result, TRACE_BUF_SIZE(0));\n\t}\n#endif\n\n\tif (tty->c_lflag & ALLLOCAL)\n\t    lookup_bits(buf, lflags, \"lflags\", tty->c_lflag);\n    }\n#else\n    /* reference: ttcompat(4M) on SunOS 4.1 */\n#ifndef EVENP\n#define EVENP 0\n#endif\n#ifndef LCASE\n#define LCASE 0\n#endif\n#ifndef LLITOUT\n#define LLITOUT 0\n#endif\n#ifndef ODDP\n#define ODDP 0\n#endif\n#ifndef TANDEM\n#define TANDEM 0\n#endif\n\n    static const BITNAMES cflags[] =\n    {\n\tDATA(CBREAK),\n\tDATA(CRMOD),\n\tDATA(ECHO),\n\tDATA(EVENP),\n\tDATA(LCASE),\n\tDATA(LLITOUT),\n\tDATA(ODDP),\n\tDATA(RAW),\n\tDATA(TANDEM),\n\tDATA(XTABS),\n\tDATAX()\n#define ALLCTRL\t(CBREAK|CRMOD|ECHO|EVENP|LCASE|LLITOUT|ODDP|RAW|TANDEM|XTABS)\n    };\n\n    buf = _nc_trace_buf(0,\n\t\t\t8 + sizeof(cflags));\n    if (buf != 0) {\n\tif (tty->sg_flags & ALLCTRL) {\n\t    lookup_bits(buf, cflags, \"cflags\", tty->sg_flags);\n\t}\n    }\n#endif\n    return (buf);\n}\n\nNCURSES_EXPORT(char *)\n_nc_tracebits(void)\n{\n    return _nc_trace_ttymode(&(cur_term->Nttyb));\n}\n#else\nEMPTY_MODULE(_nc_empty_lib_tracebits)\n#endif /* TRACE */\n","/****************************************************************************\n * Copyright (c) 1998-2009,2012 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n ****************************************************************************/\n\n/*\n *\tlib_tracechr.c - Tracing/Debugging routines\n */\n#include <curses.priv.h>\n\n#include <ctype.h>\n\nMODULE_ID(\"$Id: lib_tracechr.c,v 1.22 2012/02/22 22:40:24 tom Exp $\")\n\n#ifdef TRACE\n\n#define MyBufSize sizeof(_nc_globals.tracechr_buf)\n\nNCURSES_EXPORT(char *)\n_nc_tracechar(SCREEN *sp, int ch)\n{\n    NCURSES_CONST char *name;\n    char *MyBuffer = ((sp != 0)\n\t\t      ? sp->tracechr_buf\n\t\t      : _nc_globals.tracechr_buf);\n\n    if (ch > KEY_MIN || ch < 0) {\n\tname = safe_keyname(SP_PARM, ch);\n\tif (name == 0 || *name == '\\0')\n\t    name = \"NULL\";\n\t_nc_SPRINTF(MyBuffer, _nc_SLIMIT(MyBufSize)\n\t\t    \"'%.30s' = %#03o\", name, ch);\n    } else if (!is8bits(ch) || !isprint(UChar(ch))) {\n\t/*\n\t * workaround for glibc bug:\n\t * sprintf changes the result from unctrl() to an empty string if it\n\t * does not correspond to a valid multibyte sequence.\n\t */\n\t_nc_SPRINTF(MyBuffer, _nc_SLIMIT(MyBufSize)\n\t\t    \"%#03o\", ch);\n    } else {\n\tname = safe_unctrl(SP_PARM, (chtype) ch);\n\tif (name == 0 || *name == 0)\n\t    name = \"null\";\t/* shouldn't happen */\n\t_nc_SPRINTF(MyBuffer, _nc_SLIMIT(MyBufSize)\n\t\t    \"'%.30s' = %#03o\", name, ch);\n    }\n    return (MyBuffer);\n}\n\nNCURSES_EXPORT(char *)\n_tracechar(int ch)\n{\n    return _nc_tracechar(CURRENT_SCREEN, ch);\n}\n#else\nEMPTY_MODULE(_nc_lib_tracechr)\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/*\n *\t\tdef_prog_mode()\n *\t\tdef_shell_mode()\n *\t\treset_prog_mode()\n *\t\treset_shell_mode()\n *\t\tsavetty()\n *\t\tresetty()\n */\n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_ttyflags.c,v 1.33 2017/04/02 14:30:26 tom Exp $\")\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_get_tty_mode) (NCURSES_SP_DCLx TTY * buf)\n{\n    TERMINAL *termp = TerminalOf(SP_PARM);\n    int result = OK;\n\n    if (buf == 0 || termp == 0) {\n\tresult = ERR;\n    } else {\n\n#ifdef USE_TERM_DRIVER\n\tif (SP_PARM != 0) {\n\t    result = CallDriver_2(SP_PARM, td_sgmode, FALSE, buf);\n\t} else {\n\t    result = ERR;\n\t}\n#else\n\tfor (;;) {\n\t    if (GET_TTY(termp->Filedes, buf) != 0) {\n\t\tif (errno == EINTR)\n\t\t    continue;\n\t\tresult = ERR;\n\t    }\n\t    break;\n\t}\n#endif\n\n\tTR(TRACE_BITS, (\"_nc_get_tty_mode(%d): %s\",\n\t\t\ttermp ? termp->Filedes : -1,\n\t\t\t_nc_trace_ttymode(buf)));\n    }\n    if (result == ERR && buf != 0)\n\tmemset(buf, 0, sizeof(*buf));\n\n    return (result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_get_tty_mode(TTY * buf)\n{\n    return NCURSES_SP_NAME(_nc_get_tty_mode) (CURRENT_SCREEN, buf);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_DCLx TTY * buf)\n{\n    int result = OK;\n\n    if (buf == 0 || SP_PARM == 0) {\n\tresult = ERR;\n    } else {\n\tTERMINAL *termp = TerminalOf(SP_PARM);\n\n\tif (0 == termp) {\n\t    result = ERR;\n\t} else {\n#ifdef USE_TERM_DRIVER\n\t    result = CallDriver_2(SP_PARM, td_sgmode, TRUE, buf);\n#else\n\t    for (;;) {\n\t\tif ((SET_TTY(termp->Filedes, buf) != 0)\n#if USE_KLIBC_KBD\n\t\t    && !NC_ISATTY(termp->Filedes)\n#endif\n\t\t    ) {\n\t\t    if (errno == EINTR)\n\t\t\tcontinue;\n\t\t    if ((errno == ENOTTY) && (SP_PARM != 0))\n\t\t\tSP_PARM->_notty = TRUE;\n\t\t    result = ERR;\n\t\t}\n\t\tbreak;\n\t    }\n#endif\n\t}\n\tTR(TRACE_BITS, (\"_nc_set_tty_mode(%d): %s\",\n\t\t\ttermp ? termp->Filedes : -1,\n\t\t\t_nc_trace_ttymode(buf)));\n    }\n    return (result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_set_tty_mode(TTY * buf)\n{\n    return NCURSES_SP_NAME(_nc_set_tty_mode) (CURRENT_SCREEN, buf);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(def_shell_mode) (NCURSES_SP_DCL0)\n{\n    int rc = ERR;\n    TERMINAL *termp = TerminalOf(SP_PARM);\n\n    T((T_CALLED(\"def_shell_mode(%p) ->term %p\"),\n       (void *) SP_PARM, (void *) termp));\n\n    if (termp != 0) {\n#ifdef USE_TERM_DRIVER\n\trc = CallDriver_2(SP_PARM, td_mode, FALSE, TRUE);\n#else\n\t/*\n\t * If XTABS was on, remove the tab and backtab capabilities.\n\t */\n\tif (_nc_get_tty_mode(&termp->Ottyb) == OK) {\n#ifdef TERMIOS\n\t    if (termp->Ottyb.c_oflag & OFLAGS_TABS)\n\t\ttab = back_tab = NULL;\n#else\n\t    if (termp->Ottyb.sg_flags & XTABS)\n\t\ttab = back_tab = NULL;\n#endif\n\t    rc = OK;\n\t}\n#endif\n    }\n    returnCode(rc);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ndef_shell_mode(void)\n{\n    return NCURSES_SP_NAME(def_shell_mode) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(def_prog_mode) (NCURSES_SP_DCL0)\n{\n    int rc = ERR;\n    TERMINAL *termp = TerminalOf(SP_PARM);\n\n    T((T_CALLED(\"def_prog_mode(%p) ->term %p\"), (void *) SP_PARM, (void *) termp));\n\n    if (termp != 0) {\n#ifdef USE_TERM_DRIVER\n\trc = CallDriver_2(SP_PARM, td_mode, TRUE, TRUE);\n#else\n\t/*\n\t * Turn off the XTABS bit in the tty structure if it was on.\n\t */\n\tif (_nc_get_tty_mode(&termp->Nttyb) == OK) {\n#ifdef TERMIOS\n\t    termp->Nttyb.c_oflag &= (unsigned) (~OFLAGS_TABS);\n#else\n\t    termp->Nttyb.sg_flags &= (unsigned) (~XTABS);\n#endif\n\t    rc = OK;\n\t}\n#endif\n    }\n    returnCode(rc);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ndef_prog_mode(void)\n{\n    return NCURSES_SP_NAME(def_prog_mode) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(reset_prog_mode) (NCURSES_SP_DCL0)\n{\n    int rc = ERR;\n    TERMINAL *termp = TerminalOf(SP_PARM);\n\n    T((T_CALLED(\"reset_prog_mode(%p) ->term %p\"), (void *) SP_PARM, (void *) termp));\n\n    if (termp != 0) {\n#ifdef USE_TERM_DRIVER\n\trc = CallDriver_2(SP_PARM, td_mode, TRUE, FALSE);\n#else\n\tif (_nc_set_tty_mode(&termp->Nttyb) == OK) {\n\t    if (SP_PARM) {\n\t\tif (SP_PARM->_keypad_on)\n\t\t    _nc_keypad(SP_PARM, TRUE);\n\t    }\n\t    rc = OK;\n\t}\n#endif\n    }\n    returnCode(rc);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nreset_prog_mode(void)\n{\n    return NCURSES_SP_NAME(reset_prog_mode) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(reset_shell_mode) (NCURSES_SP_DCL0)\n{\n    int rc = ERR;\n    TERMINAL *termp = TerminalOf(SP_PARM);\n\n    T((T_CALLED(\"reset_shell_mode(%p) ->term %p\"),\n       (void *) SP_PARM, (void *) termp));\n\n    if (termp != 0) {\n#ifdef USE_TERM_DRIVER\n\trc = CallDriver_2(SP_PARM, td_mode, FALSE, FALSE);\n#else\n\tif (SP_PARM) {\n\t    _nc_keypad(SP_PARM, FALSE);\n\t    _nc_flush();\n\t}\n\trc = _nc_set_tty_mode(&termp->Ottyb);\n#endif\n    }\n    returnCode(rc);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nreset_shell_mode(void)\n{\n    return NCURSES_SP_NAME(reset_shell_mode) (CURRENT_SCREEN);\n}\n#endif\n\nstatic TTY *\nsaved_tty(NCURSES_SP_DCL0)\n{\n    TTY *result = 0;\n\n    if (SP_PARM != 0) {\n\tresult = (TTY *) & (SP_PARM->_saved_tty);\n    } else {\n\tif (_nc_prescreen.saved_tty == 0) {\n\t    _nc_prescreen.saved_tty = typeCalloc(TTY, 1);\n\t}\n\tresult = _nc_prescreen.saved_tty;\n    }\n    return result;\n}\n\n/*\n**\tsavetty()  and  resetty()\n**\n*/\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(savetty) (NCURSES_SP_DCL0)\n{\n    T((T_CALLED(\"savetty(%p)\"), (void *) SP_PARM));\n    returnCode(NCURSES_SP_NAME(_nc_get_tty_mode) (NCURSES_SP_ARGx saved_tty(NCURSES_SP_ARG)));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nsavetty(void)\n{\n    return NCURSES_SP_NAME(savetty) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(resetty) (NCURSES_SP_DCL0)\n{\n    T((T_CALLED(\"resetty(%p)\"), (void *) SP_PARM));\n    returnCode(NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx saved_tty(NCURSES_SP_ARG)));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nresetty(void)\n{\n    return NCURSES_SP_NAME(resetty) (CURRENT_SCREEN);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2015,2016 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n ****************************************************************************/\n\n/*\n**\tlib_twait.c\n**\n**\tThe routine _nc_timed_wait().\n**\n**\t(This file was originally written by Eric Raymond; however except for\n**\tcomments, none of the original code remains - T.Dickey).\n*/\n\n#include <curses.priv.h>\n\n#if defined __HAIKU__ && defined __BEOS__\n#undef __BEOS__\n#endif\n\n#ifdef __BEOS__\n#undef false\n#undef true\n#include <OS.h>\n#endif\n\n#if USE_KLIBC_KBD\n#define INCL_KBD\n#include <os2.h>\n#endif\n\n#if USE_FUNC_POLL\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# endif\n#elif HAVE_SELECT\n# if HAVE_SYS_TIME_H && HAVE_SYS_TIME_SELECT\n#  include <sys/time.h>\n# endif\n# if HAVE_SYS_SELECT_H\n#  include <sys/select.h>\n# endif\n#endif\n#ifdef __MINGW32__\n#  include <sys/time.h>\n#endif\n#undef CUR\n\nMODULE_ID(\"$Id: lib_twait.c,v 1.71 2016/05/28 23:32:40 tom Exp $\")\n\nstatic long\n_nc_gettime(TimeType * t0, int first)\n{\n    long res;\n\n#if PRECISE_GETTIME\n    TimeType t1;\n    gettimeofday(&t1, (struct timezone *) 0);\n    if (first) {\n\t*t0 = t1;\n\tres = 0;\n    } else {\n\t/* .tv_sec and .tv_usec are unsigned, be careful when subtracting */\n\tif (t0->tv_usec > t1.tv_usec) {\n\t    t1.tv_usec += 1000000;\t/* Convert 1s in 1e6 microsecs */\n\t    t1.tv_sec--;\n\t}\n\tres = (t1.tv_sec - t0->tv_sec) * 1000\n\t    + (t1.tv_usec - t0->tv_usec) / 1000;\n    }\n#else\n    time_t t1 = time((time_t *) 0);\n    if (first) {\n\t*t0 = t1;\n    }\n    res = (long) ((t1 - *t0) * 1000);\n#endif\n    TR(TRACE_IEVENT, (\"%s time: %ld msec\", first ? \"get\" : \"elapsed\", res));\n    return res;\n}\n\n#ifdef NCURSES_WGETCH_EVENTS\nNCURSES_EXPORT(int)\n_nc_eventlist_timeout(_nc_eventlist * evl)\n{\n    int event_delay = -1;\n\n    if (evl != 0) {\n\tint n;\n\n\tfor (n = 0; n < evl->count; ++n) {\n\t    _nc_event *ev = evl->events[n];\n\n\t    if (ev->type == _NC_EVENT_TIMEOUT_MSEC) {\n\t\tevent_delay = (int) ev->data.timeout_msec;\n\t\tif (event_delay < 0)\n\t\t    event_delay = INT_MAX;\t/* FIXME Is this defined? */\n\t    }\n\t}\n    }\n    return event_delay;\n}\n#endif /* NCURSES_WGETCH_EVENTS */\n\n#if (USE_FUNC_POLL || HAVE_SELECT)\n#  define MAYBE_UNUSED\n#else\n#  define MAYBE_UNUSED GCC_UNUSED\n#endif\n\n#if (USE_FUNC_POLL || HAVE_SELECT)\n#  define MAYBE_UNUSED\n#else\n#  define MAYBE_UNUSED GCC_UNUSED\n#endif\n\n/*\n * Wait a specified number of milliseconds, returning nonzero if the timer\n * didn't expire before there is activity on the specified file descriptors.\n * The file-descriptors are specified by the mode:\n *\tTW_NONE    0 - none (absolute time)\n *\tTW_INPUT   1 - ncurses' normal input-descriptor\n *\tTW_MOUSE   2 - mouse descriptor, if any\n *\tTW_ANY     3 - either input or mouse.\n *      TW_EVENT   4 -\n * Experimental:  if NCURSES_WGETCH_EVENTS is defined, (mode & 4) determines\n * whether to pay attention to evl argument.  If set, the smallest of\n * millisecond and of timeout of evl is taken.\n *\n * We return a mask that corresponds to the mode (e.g., 2 for mouse activity).\n *\n * If the milliseconds given are -1, the wait blocks until activity on the\n * descriptors.\n */\nNCURSES_EXPORT(int)\n_nc_timed_wait(SCREEN *sp MAYBE_UNUSED,\n\t       int mode MAYBE_UNUSED,\n\t       int milliseconds,\n\t       int *timeleft\n\t       EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    int count;\n    int result = TW_NONE;\n    TimeType t0;\n#if (USE_FUNC_POLL || HAVE_SELECT)\n    int fd;\n#endif\n\n#ifdef NCURSES_WGETCH_EVENTS\n    int timeout_is_event = 0;\n    int n;\n#endif\n\n#if USE_FUNC_POLL\n#define MIN_FDS 2\n    struct pollfd fd_list[MIN_FDS];\n    struct pollfd *fds = fd_list;\n#elif defined(__BEOS__)\n#elif HAVE_SELECT\n    fd_set set;\n#endif\n\n#if USE_KLIBC_KBD\n    fd_set saved_set;\n    KBDKEYINFO ki;\n    struct timeval tv;\n#endif\n\n    long starttime, returntime;\n\n    TR(TRACE_IEVENT, (\"start twait: %d milliseconds, mode: %d\",\n\t\t      milliseconds, mode));\n\n#ifdef NCURSES_WGETCH_EVENTS\n    if (mode & TW_EVENT) {\n\tint event_delay = _nc_eventlist_timeout(evl);\n\n\tif (event_delay >= 0\n\t    && (milliseconds >= event_delay || milliseconds < 0)) {\n\t    milliseconds = event_delay;\n\t    timeout_is_event = 1;\n\t}\n    }\n#endif\n\n#if PRECISE_GETTIME && HAVE_NANOSLEEP\n  retry:\n#endif\n    starttime = _nc_gettime(&t0, TRUE);\n\n    count = 0;\n    (void) count;\n\n#ifdef NCURSES_WGETCH_EVENTS\n    if ((mode & TW_EVENT) && evl)\n\tevl->result_flags = 0;\n#endif\n\n#if USE_FUNC_POLL\n    memset(fd_list, 0, sizeof(fd_list));\n\n#ifdef NCURSES_WGETCH_EVENTS\n    if ((mode & TW_EVENT) && evl) {\n\tif (fds == fd_list)\n\t    fds = typeMalloc(struct pollfd, MIN_FDS + evl->count);\n\tif (fds == 0)\n\t    return TW_NONE;\n    }\n#endif\n\n    if (mode & TW_INPUT) {\n\tfds[count].fd = sp->_ifd;\n\tfds[count].events = POLLIN;\n\tcount++;\n    }\n    if ((mode & TW_MOUSE)\n\t&& (fd = sp->_mouse_fd) >= 0) {\n\tfds[count].fd = fd;\n\tfds[count].events = POLLIN;\n\tcount++;\n    }\n#ifdef NCURSES_WGETCH_EVENTS\n    if ((mode & TW_EVENT) && evl) {\n\tfor (n = 0; n < evl->count; ++n) {\n\t    _nc_event *ev = evl->events[n];\n\n\t    if (ev->type == _NC_EVENT_FILE\n\t\t&& (ev->data.fev.flags & _NC_EVENT_FILE_READABLE)) {\n\t\tfds[count].fd = ev->data.fev.fd;\n\t\tfds[count].events = POLLIN;\n\t\tcount++;\n\t    }\n\t}\n    }\n#endif\n\n    result = poll(fds, (size_t) count, milliseconds);\n\n#ifdef NCURSES_WGETCH_EVENTS\n    if ((mode & TW_EVENT) && evl) {\n\tint c;\n\n\tif (!result)\n\t    count = 0;\n\n\tfor (n = 0; n < evl->count; ++n) {\n\t    _nc_event *ev = evl->events[n];\n\n\t    if (ev->type == _NC_EVENT_FILE\n\t\t&& (ev->data.fev.flags & _NC_EVENT_FILE_READABLE)) {\n\t\tev->data.fev.result = 0;\n\t\tfor (c = 0; c < count; c++)\n\t\t    if (fds[c].fd == ev->data.fev.fd\n\t\t\t&& fds[c].revents & POLLIN) {\n\t\t\tev->data.fev.result |= _NC_EVENT_FILE_READABLE;\n\t\t\tevl->result_flags |= _NC_EVENT_FILE_READABLE;\n\t\t    }\n\t    } else if (ev->type == _NC_EVENT_TIMEOUT_MSEC\n\t\t       && !result && timeout_is_event) {\n\t\tevl->result_flags |= _NC_EVENT_TIMEOUT_MSEC;\n\t    }\n\t}\n    }\n#endif\n\n#elif defined(__BEOS__)\n    /*\n     * BeOS's select() is declared in socket.h, so the configure script does\n     * not see it.  That's just as well, since that function works only for\n     * sockets.  This (using snooze and ioctl) was distilled from Be's patch\n     * for ncurses which uses a separate thread to simulate select().\n     *\n     * FIXME: the return values from the ioctl aren't very clear if we get\n     * interrupted.\n     *\n     * FIXME: this assumes mode&1 if milliseconds < 0 (see lib_getch.c).\n     */\n    result = TW_NONE;\n    if (mode & TW_INPUT) {\n\tint step = (milliseconds < 0) ? 0 : 5000;\n\tbigtime_t d;\n\tbigtime_t useconds = milliseconds * 1000;\n\tint n, howmany;\n\n\tif (useconds <= 0)\t/* we're here to go _through_ the loop */\n\t    useconds = 1;\n\n\tfor (d = 0; d < useconds; d += step) {\n\t    n = 0;\n\t    howmany = ioctl(0, 'ichr', &n);\n\t    if (howmany >= 0 && n > 0) {\n\t\tresult = 1;\n\t\tbreak;\n\t    }\n\t    if (useconds > 1 && step > 0) {\n\t\tsnooze(step);\n\t\tmilliseconds -= (step / 1000);\n\t\tif (milliseconds <= 0) {\n\t\t    milliseconds = 0;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    } else if (milliseconds > 0) {\n\tsnooze(milliseconds * 1000);\n\tmilliseconds = 0;\n    }\n#elif HAVE_SELECT\n    /*\n     * select() modifies the fd_set arguments; do this in the\n     * loop.\n     */\n    FD_ZERO(&set);\n\n#if !USE_KLIBC_KBD\n    if (mode & TW_INPUT) {\n\tFD_SET(sp->_ifd, &set);\n\tcount = sp->_ifd + 1;\n    }\n#endif\n    if ((mode & TW_MOUSE)\n\t&& (fd = sp->_mouse_fd) >= 0) {\n\tFD_SET(fd, &set);\n\tcount = max(fd, count) + 1;\n    }\n#ifdef NCURSES_WGETCH_EVENTS\n    if ((mode & TW_EVENT) && evl) {\n\tfor (n = 0; n < evl->count; ++n) {\n\t    _nc_event *ev = evl->events[n];\n\n\t    if (ev->type == _NC_EVENT_FILE\n\t\t&& (ev->data.fev.flags & _NC_EVENT_FILE_READABLE)) {\n\t\tFD_SET(ev->data.fev.fd, &set);\n\t\tcount = max(ev->data.fev.fd + 1, count);\n\t    }\n\t}\n    }\n#endif\n\n#if USE_KLIBC_KBD\n    for (saved_set = set;; set = saved_set) {\n\tif ((mode & TW_INPUT)\n\t    && (sp->_extended_key\n\t\t|| (KbdPeek(&ki, 0) == 0\n\t\t    && (ki.fbStatus & KBDTRF_FINAL_CHAR_IN)))) {\n\t    FD_ZERO(&set);\n\t    FD_SET(sp->_ifd, &set);\n\t    result = 1;\n\t    break;\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = (milliseconds == 0) ? 0 : (10 * 1000);\n\n\tif ((result = select(count, &set, NULL, NULL, &tv)) != 0)\n\t    break;\n\n\t/* Time out ? */\n\tif (milliseconds >= 0 && _nc_gettime(&t0, FALSE) >= milliseconds) {\n\t    result = 0;\n\t    break;\n\t}\n    }\n#else\n    if (milliseconds >= 0) {\n\tstruct timeval ntimeout;\n\tntimeout.tv_sec = milliseconds / 1000;\n\tntimeout.tv_usec = (milliseconds % 1000) * 1000;\n\tresult = select(count, &set, NULL, NULL, &ntimeout);\n    } else {\n\tresult = select(count, &set, NULL, NULL, NULL);\n    }\n#endif\n\n#ifdef NCURSES_WGETCH_EVENTS\n    if ((mode & TW_EVENT) && evl) {\n\tevl->result_flags = 0;\n\tfor (n = 0; n < evl->count; ++n) {\n\t    _nc_event *ev = evl->events[n];\n\n\t    if (ev->type == _NC_EVENT_FILE\n\t\t&& (ev->data.fev.flags & _NC_EVENT_FILE_READABLE)) {\n\t\tev->data.fev.result = 0;\n\t\tif (FD_ISSET(ev->data.fev.fd, &set)) {\n\t\t    ev->data.fev.result |= _NC_EVENT_FILE_READABLE;\n\t\t    evl->result_flags |= _NC_EVENT_FILE_READABLE;\n\t\t}\n\t    } else if (ev->type == _NC_EVENT_TIMEOUT_MSEC\n\t\t       && !result && timeout_is_event)\n\t\tevl->result_flags |= _NC_EVENT_TIMEOUT_MSEC;\n\t}\n    }\n#endif\n\n#endif /* USE_FUNC_POLL, etc */\n\n    returntime = _nc_gettime(&t0, FALSE);\n\n    if (milliseconds >= 0)\n\tmilliseconds -= (int) (returntime - starttime);\n\n#ifdef NCURSES_WGETCH_EVENTS\n    if (evl) {\n\tevl->result_flags = 0;\n\tfor (n = 0; n < evl->count; ++n) {\n\t    _nc_event *ev = evl->events[n];\n\n\t    if (ev->type == _NC_EVENT_TIMEOUT_MSEC) {\n\t\tlong diff = (returntime - starttime);\n\t\tif (ev->data.timeout_msec <= diff)\n\t\t    ev->data.timeout_msec = 0;\n\t\telse\n\t\t    ev->data.timeout_msec -= diff;\n\t    }\n\n\t}\n    }\n#endif\n\n#if PRECISE_GETTIME && HAVE_NANOSLEEP\n    /*\n     * If the timeout hasn't expired, and we've gotten no data,\n     * this is probably a system where 'select()' needs to be left\n     * alone so that it can complete.  Make this process sleep,\n     * then come back for more.\n     */\n    if (result == 0 && milliseconds > 100) {\n\tnapms(100);\t\t/* FIXME: this won't be right if I recur! */\n\tmilliseconds -= 100;\n\tgoto retry;\n    }\n#endif\n\n    /* return approximate time left in milliseconds */\n    if (timeleft)\n\t*timeleft = milliseconds;\n\n    TR(TRACE_IEVENT, (\"end twait: returned %d (%d), remaining time %d msec\",\n\t\t      result, errno, milliseconds));\n\n    /*\n     * Both 'poll()' and 'select()' return the number of file descriptors\n     * that are active.  Translate this back to the mask that denotes which\n     * file-descriptors, so that we don't need all of this system-specific\n     * code everywhere.\n     */\n    if (result != 0) {\n\tif (result > 0) {\n\t    result = 0;\n#if USE_FUNC_POLL\n\t    for (count = 0; count < MIN_FDS; count++) {\n\t\tif ((mode & (1 << count))\n\t\t    && (fds[count].revents & POLLIN)) {\n\t\t    result |= (1 << count);\n\t\t}\n\t    }\n#elif defined(__BEOS__)\n\t    result = TW_INPUT;\t/* redundant, but simple */\n#elif HAVE_SELECT\n\t    if ((mode & TW_MOUSE)\n\t\t&& (fd = sp->_mouse_fd) >= 0\n\t\t&& FD_ISSET(fd, &set))\n\t\tresult |= TW_MOUSE;\n\t    if ((mode & TW_INPUT)\n\t\t&& FD_ISSET(sp->_ifd, &set))\n\t\tresult |= TW_INPUT;\n#endif\n\t} else\n\t    result = 0;\n    }\n#ifdef NCURSES_WGETCH_EVENTS\n    if ((mode & TW_EVENT) && evl && evl->result_flags)\n\tresult |= TW_EVENT;\n#endif\n\n#if USE_FUNC_POLL\n#ifdef NCURSES_WGETCH_EVENTS\n    if (fds != fd_list)\n\tfree((char *) fds);\n#endif\n#endif\n\n    return (result);\n}\n","/****************************************************************************\n * Copyright (c) 1999-2013,2016 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey                    1999-on                     *\n ****************************************************************************/\n\n#include <curses.priv.h>\n#include <tic.h>\n\nMODULE_ID(\"$Id: name_match.c,v 1.24 2016/05/28 23:22:52 tom Exp $\")\n\n#define FirstName _nc_globals.first_name\n\n#if NCURSES_USE_TERMCAP && NCURSES_XNAMES\nstatic const char *\nskip_index(const char *name)\n{\n    if ((_nc_syntax == SYN_TERMCAP) && _nc_user_definable) {\n\tconst char *bar = strchr(name, '|');\n\tif (bar != 0 && (bar - name) == 2)\n\t    name = bar + 1;\n    }\n    return name;\n}\n#endif\n\n/*\n * Get the primary name from the given name list.  For terminfo, this is the\n * first name.  For termcap, this may be the second name, if the first one\n * happens to be two characters.\n */\nNCURSES_EXPORT(char *)\n_nc_first_name(const char *const sp)\n{\n#if NO_LEAKS\n    if (sp == 0) {\n\tif (FirstName != 0) {\n\t    FreeAndNull(FirstName);\n\t}\n    } else\n#endif\n    {\n\tif (FirstName == 0)\n\t    FirstName = typeMalloc(char, MAX_NAME_SIZE + 1);\n\n\tif (FirstName != 0) {\n\t    unsigned n;\n\t    const char *src = sp;\n#if NCURSES_USE_TERMCAP && NCURSES_XNAMES\n\t    src = skip_index(sp);\n#endif\n\t    for (n = 0; n < MAX_NAME_SIZE; n++) {\n\t\tif ((FirstName[n] = src[n]) == '\\0'\n\t\t    || (FirstName[n] == '|'))\n\t\t    break;\n\t    }\n\t    FirstName[n] = '\\0';\n\t}\n    }\n    return (FirstName);\n}\n\n/*\n * Is the given name matched in namelist?\n */\nNCURSES_EXPORT(int)\n_nc_name_match(const char *const namelst, const char *const name, const char *const delim)\n{\n    const char *s;\n\n    if ((s = namelst) != 0) {\n\twhile (*s != '\\0') {\n\t    const char *d, *t;\n\t    int code, found;\n\n\t    for (d = name; *d != '\\0'; d++) {\n\t\tif (*s != *d)\n\t\t    break;\n\t\ts++;\n\t    }\n\t    found = FALSE;\n\t    for (code = TRUE; *s != '\\0'; code = FALSE, s++) {\n\t\tfor (t = delim; *t != '\\0'; t++) {\n\t\t    if (*s == *t) {\n\t\t\tfound = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (found)\n\t\t    break;\n\t    }\n\t    if (code && *d == '\\0')\n\t\treturn code;\n\t    if (*s++ == 0)\n\t\tbreak;\n\t}\n    }\n    return FALSE;\n}\n","/****************************************************************************\n * Copyright (c) 2013-2014,2016 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey                        2013-on                 *\n ****************************************************************************/\n\n/*\n**\tSupport for obsolete/unusual features.\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: obsolete.c,v 1.4 2016/09/10 18:39:51 tom Exp $\")\n\n/*\n * Obsolete entrypoint retained for binary compatbility.\n */\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_set_buffer) (NCURSES_SP_DCLx FILE *ofp, int buffered)\n{\n#if NCURSES_SP_FUNCS\n    (void) SP_PARM;\n#endif\n    (void) ofp;\n    (void) buffered;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_set_buffer(FILE *ofp, int buffered)\n{\n    NCURSES_SP_NAME(_nc_set_buffer) (CURRENT_SCREEN, ofp, buffered);\n}\n#endif\n\n#if !HAVE_STRDUP\nNCURSES_EXPORT(char *)\n_nc_strdup(const char *s)\n{\n    char *result = 0;\n    if (s != 0) {\n\tsize_t need = strlen(s);\n\tresult = malloc(need + 1);\n\tif (result != 0) {\n\t    _nc_STRCPY(result, s, need);\n\t}\n    }\n    return result;\n}\n#endif\n\n#if USE_MY_MEMMOVE\n#define DST ((char *)s1)\n#define SRC ((const char *)s2)\nNCURSES_EXPORT(void *)\n_nc_memmove(void *s1, const void *s2, size_t n)\n{\n    if (n != 0) {\n\tif ((DST + n > SRC) && (SRC + n > DST)) {\n\t    static char *bfr;\n\t    static size_t length;\n\t    register size_t j;\n\t    if (length < n) {\n\t\tlength = (n * 3) / 2;\n\t\tbfr = typeRealloc(char, length, bfr);\n\t    }\n\t    for (j = 0; j < n; j++)\n\t\tbfr[j] = SRC[j];\n\t    s2 = bfr;\n\t}\n\twhile (n-- != 0)\n\t    DST[n] = SRC[n];\n    }\n    return s1;\n}\n#endif /* USE_MY_MEMMOVE */\n\n#ifdef EXP_XTERM_1005\nNCURSES_EXPORT(int)\n_nc_conv_to_utf8(unsigned char *target, unsigned source, unsigned limit)\n{\n#define CH(n) UChar((source) >> ((n) * 8))\n    int rc = 0;\n\n    if (source <= 0x0000007f)\n\trc = 1;\n    else if (source <= 0x000007ff)\n\trc = 2;\n    else if (source <= 0x0000ffff)\n\trc = 3;\n    else if (source <= 0x001fffff)\n\trc = 4;\n    else if (source <= 0x03ffffff)\n\trc = 5;\n    else\t\t\t/* (source <= 0x7fffffff) */\n\trc = 6;\n\n    if ((unsigned) rc > limit) {\t/* whatever it is, we cannot decode it */\n\trc = 0;\n    }\n\n    if (target != 0) {\n\tswitch (rc) {\n\tcase 1:\n\t    target[0] = CH(0);\n\t    break;\n\n\tcase 2:\n\t    target[1] = UChar(0x80 | (CH(0) & 0x3f));\n\t    target[0] = UChar(0xc0 | (CH(0) >> 6) | ((CH(1) & 0x07) << 2));\n\t    break;\n\n\tcase 3:\n\t    target[2] = UChar(0x80 | (CH(0) & 0x3f));\n\t    target[1] = UChar(0x80 | (CH(0) >> 6) | ((CH(1) & 0x0f) << 2));\n\t    target[0] = UChar(0xe0 | ((int) (CH(1) & 0xf0) >> 4));\n\t    break;\n\n\tcase 4:\n\t    target[3] = UChar(0x80 | (CH(0) & 0x3f));\n\t    target[2] = UChar(0x80 | (CH(0) >> 6) | ((CH(1) & 0x0f) << 2));\n\t    target[1] = UChar(0x80 |\n\t\t\t      ((int) (CH(1) & 0xf0) >> 4) |\n\t\t\t      ((int) (CH(2) & 0x03) << 4));\n\t    target[0] = UChar(0xf0 | ((int) (CH(2) & 0x1f) >> 2));\n\t    break;\n\n\tcase 5:\n\t    target[4] = UChar(0x80 | (CH(0) & 0x3f));\n\t    target[3] = UChar(0x80 | (CH(0) >> 6) | ((CH(1) & 0x0f) << 2));\n\t    target[2] = UChar(0x80 |\n\t\t\t      ((int) (CH(1) & 0xf0) >> 4) |\n\t\t\t      ((int) (CH(2) & 0x03) << 4));\n\t    target[1] = UChar(0x80 | (CH(2) >> 2));\n\t    target[0] = UChar(0xf8 | (CH(3) & 0x03));\n\t    break;\n\n\tcase 6:\n\t    target[5] = UChar(0x80 | (CH(0) & 0x3f));\n\t    target[4] = UChar(0x80 | (CH(0) >> 6) | ((CH(1) & 0x0f) << 2));\n\t    target[3] = UChar(0x80 | (CH(1) >> 4) | ((CH(2) & 0x03) << 4));\n\t    target[2] = UChar(0x80 | (CH(2) >> 2));\n\t    target[1] = UChar(0x80 | (CH(3) & 0x3f));\n\t    target[0] = UChar(0xfc | ((int) (CH(3) & 0x40) >> 6));\n\t    break;\n\t}\n    }\n\n    return rc;\t\t\t/* number of bytes needed in target */\n#undef CH\n}\n\nNCURSES_EXPORT(int)\n_nc_conv_to_utf32(unsigned *target, const char *source, unsigned limit)\n{\n#define CH(n) UChar((*target) >> ((n) * 8))\n    int rc = 0;\n    int j;\n    unsigned mask = 0;\n\n    /*\n     * Find the number of bytes we will need from the source.\n     */\n    if ((*source & 0x80) == 0) {\n\trc = 1;\n\tmask = (unsigned) *source;\n    } else if ((*source & 0xe0) == 0xc0) {\n\trc = 2;\n\tmask = (unsigned) (*source & 0x1f);\n    } else if ((*source & 0xf0) == 0xe0) {\n\trc = 3;\n\tmask = (unsigned) (*source & 0x0f);\n    } else if ((*source & 0xf8) == 0xf0) {\n\trc = 4;\n\tmask = (unsigned) (*source & 0x07);\n    } else if ((*source & 0xfc) == 0xf8) {\n\trc = 5;\n\tmask = (unsigned) (*source & 0x03);\n    } else if ((*source & 0xfe) == 0xfc) {\n\trc = 6;\n\tmask = (unsigned) (*source & 0x01);\n    }\n\n    if ((unsigned) rc > limit) {\t/* whatever it is, we cannot decode it */\n\trc = 0;\n    }\n\n    /*\n     * sanity-check.\n     */\n    if (rc > 1) {\n\tfor (j = 1; j < rc; j++) {\n\t    if ((source[j] & 0xc0) != 0x80)\n\t\tbreak;\n\t}\n\tif (j != rc) {\n\t    rc = 0;\n\t}\n    }\n\n    if (target != 0) {\n\tint shift = 0;\n\t*target = 0;\n\tfor (j = 1; j < rc; j++) {\n\t    *target |= (unsigned) (source[rc - j] & 0x3f) << shift;\n\t    shift += 6;\n\t}\n\t*target |= mask << shift;\n    }\n    return rc;\n#undef CH\n}\n#endif /* EXP_XTERM_1005 */\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n ****************************************************************************/\n\n/*\n *\tread_entry.c -- Routine for reading in a compiled terminfo file\n */\n\n#include <curses.priv.h>\n#include <hashed_db.h>\n\n#include <tic.h>\n\nMODULE_ID(\"$Id: read_entry.c,v 1.144 2017/10/23 21:20:06 tom Exp $\")\n\n#define TYPE_CALLOC(type,elts) typeCalloc(type, (unsigned)(elts))\n\n#define MyNumber(n) (short) LOW_MSB(n)\n\n#define SIZEOF_32BITS 4\n\n#if NCURSES_USE_DATABASE\n#if NCURSES_EXT_NUMBERS\nstatic size_t\nconvert_16bits(char *buf, NCURSES_INT2 *Numbers, int count)\n{\n    int i;\n    size_t j;\n    size_t size = SIZEOF_SHORT;\n    unsigned char ch;\n    for (i = 0; i < count; i++) {\n\tunsigned mask = 0xff;\n\tNumbers[i] = 0;\n\tfor (j = 0; j < size; ++j) {\n\t    ch = UChar(*buf++);\n\t    Numbers[i] |= (ch << (8 * j));\n\t    mask <<= 8;\n\t}\n\tif (ch & 0x80) {\n\t    while (mask != 0) {\n\t\tNumbers[i] |= (int) mask;\n\t\tmask <<= 8;\n\t    }\n\t}\n\tTR(TRACE_DATABASE, (\"get Numbers[%d]=%d\", i, Numbers[i]));\n    }\n    return size;\n}\n\nstatic size_t\nconvert_32bits(char *buf, NCURSES_INT2 *Numbers, int count)\n{\n    int i;\n    size_t j;\n    size_t size = SIZEOF_INT2;\n    unsigned char ch;\n\n    assert(sizeof(NCURSES_INT2) == size);\n    for (i = 0; i < count; i++) {\n\tNumbers[i] = 0;\n\tfor (j = 0; j < size; ++j) {\n\t    ch = UChar(*buf++);\n\t    Numbers[i] |= (ch << (8 * j));\n\t}\n\t/* \"unsigned\" and NCURSES_INT2 are the same size - no sign-extension */\n\tTR(TRACE_DATABASE, (\"get Numbers[%d]=%d\", i, Numbers[i]));\n    }\n    return size;\n}\n#else\nstatic size_t\nconvert_32bits(char *buf, NCURSES_INT2 *Numbers, int count)\n{\n    int i, j;\n    unsigned char ch;\n    for (i = 0; i < count; i++) {\n\tint value = 0;\n\tfor (j = 0; j < SIZEOF_32BITS; ++j) {\n\t    ch = UChar(*buf++);\n\t    value |= (ch << (8 * j));\n\t}\n\tif (value == -1)\n\t    Numbers[i] = ABSENT_NUMERIC;\n\telse if (value == -2)\n\t    Numbers[i] = CANCELLED_NUMERIC;\n\telse if (value > MAX_OF_TYPE(NCURSES_INT2))\n\t    Numbers[i] = MAX_OF_TYPE(NCURSES_INT2);\n\telse\n\t    Numbers[i] = (short) value;\n\tTR(TRACE_DATABASE, (\"get Numbers[%d]=%d\", i, Numbers[i]));\n    }\n    return SIZEOF_SHORT;\n}\n\nstatic size_t\nconvert_16bits(char *buf, NCURSES_INT2 *Numbers, int count)\n{\n    int i;\n    for (i = 0; i < count; i++) {\n\tif (IS_NEG1(buf + 2 * i))\n\t    Numbers[i] = ABSENT_NUMERIC;\n\telse if (IS_NEG2(buf + 2 * i))\n\t    Numbers[i] = CANCELLED_NUMERIC;\n\telse\n\t    Numbers[i] = MyNumber(buf + 2 * i);\n\tTR(TRACE_DATABASE, (\"get Numbers[%d]=%d\", i, Numbers[i]));\n    }\n    return SIZEOF_SHORT;\n}\n#endif\n\nstatic void\nconvert_strings(char *buf, char **Strings, int count, int size, char *table)\n{\n    int i;\n    char *p;\n\n    for (i = 0; i < count; i++) {\n\tif (IS_NEG1(buf + 2 * i)) {\n\t    Strings[i] = ABSENT_STRING;\n\t} else if (IS_NEG2(buf + 2 * i)) {\n\t    Strings[i] = CANCELLED_STRING;\n\t} else if (MyNumber(buf + 2 * i) > size) {\n\t    Strings[i] = ABSENT_STRING;\n\t} else {\n\t    Strings[i] = (MyNumber(buf + 2 * i) + table);\n\t    TR(TRACE_DATABASE, (\"Strings[%d] = %s\", i, _nc_visbuf(Strings[i])));\n\t}\n\n\t/* make sure all strings are NUL terminated */\n\tif (VALID_STRING(Strings[i])) {\n\t    for (p = Strings[i]; p <= table + size; p++)\n\t\tif (*p == '\\0')\n\t\t    break;\n\t    /* if there is no NUL, ignore the string */\n\t    if (p > table + size)\n\t\tStrings[i] = ABSENT_STRING;\n\t}\n    }\n}\n\nstatic int\nfake_read(char *src, int *offset, int limit, char *dst, unsigned want)\n{\n    int have = (limit - *offset);\n\n    if (have > 0) {\n\tif ((int) want > have)\n\t    want = (unsigned) have;\n\tmemcpy(dst, src + *offset, (size_t) want);\n\t*offset += (int) want;\n    } else {\n\twant = 0;\n    }\n    return (int) want;\n}\n\n#define Read(buf, count) fake_read(buffer, &offset, limit, (char *) buf, (unsigned) count)\n\n#define read_shorts(buf, count) \\\n\t(Read(buf, (count)*SIZEOF_SHORT) == (int) (count)*SIZEOF_SHORT)\n\n#define read_numbers(buf, count) \\\n\t(Read(buf, (count)*(unsigned)size_of_numbers) == (int) (count)*size_of_numbers)\n\n#define even_boundary(value) \\\n    if ((value) % 2 != 0) Read(buf, 1)\n#endif\n\nNCURSES_EXPORT(void)\n_nc_init_termtype(TERMTYPE2 *const tp)\n{\n    unsigned i;\n\n#if NCURSES_XNAMES\n    tp->num_Booleans = BOOLCOUNT;\n    tp->num_Numbers = NUMCOUNT;\n    tp->num_Strings = STRCOUNT;\n    tp->ext_Booleans = 0;\n    tp->ext_Numbers = 0;\n    tp->ext_Strings = 0;\n#endif\n    if (tp->Booleans == 0)\n\tTYPE_MALLOC(NCURSES_SBOOL, BOOLCOUNT, tp->Booleans);\n    if (tp->Numbers == 0)\n\tTYPE_MALLOC(NCURSES_INT2, NUMCOUNT, tp->Numbers);\n    if (tp->Strings == 0)\n\tTYPE_MALLOC(char *, STRCOUNT, tp->Strings);\n\n    for_each_boolean(i, tp)\n\ttp->Booleans[i] = FALSE;\n\n    for_each_number(i, tp)\n\ttp->Numbers[i] = ABSENT_NUMERIC;\n\n    for_each_string(i, tp)\n\ttp->Strings[i] = ABSENT_STRING;\n}\n\n#if NCURSES_USE_DATABASE\n#if NCURSES_XNAMES\nstatic bool\nvalid_shorts(char *buffer, int limit)\n{\n    bool result = FALSE;\n    int n;\n    for (n = 0; n < limit; ++n) {\n\tif (MyNumber(buffer + (n * 2)) > 0) {\n\t    result = TRUE;\n\t    break;\n\t}\n    }\n    return result;\n}\n#endif\n\n/*\n * Return TGETENT_YES if read, TGETENT_NO if not found or garbled.\n */\nNCURSES_EXPORT(int)\n_nc_read_termtype(TERMTYPE2 *ptr, char *buffer, int limit)\n{\n    int offset = 0;\n    int name_size, bool_count, num_count, str_count, str_size;\n    int i;\n    char buf[MAX_ENTRY_SIZE + 2];\n    char *string_table;\n    unsigned want, have;\n    bool need_ints;\n    size_t (*convert_numbers) (char *, NCURSES_INT2 *, int);\n    int size_of_numbers;\n    int max_entry_size = MAX_ENTRY_SIZE;\n\n    TR(TRACE_DATABASE,\n       (T_CALLED(\"_nc_read_termtype(ptr=%p, buffer=%p, limit=%d)\"),\n\t(void *) ptr, buffer, limit));\n\n    TR(TRACE_DATABASE, (\"READ termtype header @%d\", offset));\n\n    memset(ptr, 0, sizeof(*ptr));\n\n    /* grab the header */\n    if (!read_shorts(buf, 6)\n\t|| !IS_TIC_MAGIC(buf)) {\n\treturnDB(TGETENT_NO);\n    }\n#if NCURSES_EXT_NUMBERS\n    if ((need_ints = (LOW_MSB(buf) == MAGIC2))) {\n\tconvert_numbers = convert_32bits;\n\tsize_of_numbers = SIZEOF_INT2;\n    } else {\n\tmax_entry_size = MAX_ENTRY_SIZE1;\n\tconvert_numbers = convert_16bits;\n\tsize_of_numbers = SIZEOF_SHORT;\n    }\n#else\n    if ((need_ints = (LOW_MSB(buf) == MAGIC2))) {\n\tconvert_numbers = convert_32bits;\n\tsize_of_numbers = SIZEOF_32BITS;\n    } else {\n\tconvert_numbers = convert_16bits;\n\tsize_of_numbers = SIZEOF_INT2;\n    }\n#endif\n\n    /* *INDENT-EQLS* */\n    name_size  = MyNumber(buf + 2);\n    bool_count = MyNumber(buf + 4);\n    num_count  = MyNumber(buf + 6);\n    str_count  = MyNumber(buf + 8);\n    str_size   = MyNumber(buf + 10);\n\n    TR(TRACE_DATABASE,\n       (\"TERMTYPE name_size=%d, bool=%d/%d, num=%d/%d str=%d/%d(%d)\",\n\tname_size, bool_count, BOOLCOUNT, num_count, NUMCOUNT,\n\tstr_count, STRCOUNT, str_size));\n    if (name_size < 0\n\t|| bool_count < 0\n\t|| num_count < 0\n\t|| str_count < 0\n\t|| str_size < 0) {\n\treturnDB(TGETENT_NO);\n    }\n\n    want = (unsigned) (str_size + name_size + 1);\n    /* try to allocate space for the string table */\n    if (str_count * SIZEOF_SHORT >= max_entry_size\n\t|| (string_table = typeMalloc(char, want)) == 0) {\n\treturnDB(TGETENT_NO);\n    }\n\n    /* grab the name (a null-terminated string) */\n    want = min(MAX_NAME_SIZE, (unsigned) name_size);\n    ptr->str_table = string_table;\n    ptr->term_names = string_table;\n    if ((have = (unsigned) Read(ptr->term_names, want)) != want) {\n\tmemset(ptr->term_names + have, 0, (size_t) (want - have));\n    }\n    ptr->term_names[want] = '\\0';\n    string_table += (want + 1);\n\n    if (have > MAX_NAME_SIZE)\n\toffset = (int) (have - MAX_NAME_SIZE);\n\n    /* grab the booleans */\n    if ((ptr->Booleans = TYPE_CALLOC(NCURSES_SBOOL,\n\t\t\t\t     max(BOOLCOUNT, bool_count))) == 0\n\t|| Read(ptr->Booleans, (unsigned) bool_count) < bool_count) {\n\treturnDB(TGETENT_NO);\n    }\n\n    /*\n     * If booleans end on an odd byte, skip it.  The machine they\n     * originally wrote terminfo on must have been a 16-bit\n     * word-oriented machine that would trap out if you tried a\n     * word access off a 2-byte boundary.\n     */\n    even_boundary(name_size + bool_count);\n\n    /* grab the numbers */\n    if (!(ptr->Numbers = TYPE_CALLOC(NCURSES_INT2, max(NUMCOUNT, num_count)))\n\t|| !read_numbers(buf, num_count)) {\n\treturnDB(TGETENT_NO);\n    }\n    convert_numbers(buf, ptr->Numbers, num_count);\n\n    if ((ptr->Strings = TYPE_CALLOC(char *, max(STRCOUNT, str_count))) == 0) {\n\treturnDB(TGETENT_NO);\n    }\n\n    if (str_count) {\n\t/* grab the string offsets */\n\tif (!read_shorts(buf, str_count)) {\n\t    returnDB(TGETENT_NO);\n\t}\n\t/* finally, grab the string table itself */\n\tif (Read(string_table, (unsigned) str_size) != str_size) {\n\t    returnDB(TGETENT_NO);\n\t}\n\tconvert_strings(buf, ptr->Strings, str_count, str_size, string_table);\n    }\n#if NCURSES_XNAMES\n\n    ptr->num_Booleans = BOOLCOUNT;\n    ptr->num_Numbers = NUMCOUNT;\n    ptr->num_Strings = STRCOUNT;\n\n    /*\n     * Read extended entries, if any, after the normal end of terminfo data.\n     */\n    even_boundary(str_size);\n    TR(TRACE_DATABASE, (\"READ extended_header @%d\", offset));\n    if (_nc_user_definable && read_shorts(buf, 5) && valid_shorts(buf, 5)) {\n\tint ext_bool_count = MyNumber(buf + 0);\n\tint ext_num_count = MyNumber(buf + 2);\n\tint ext_str_count = MyNumber(buf + 4);\n\tint ext_str_size = MyNumber(buf + 6);\n\tint ext_str_limit = MyNumber(buf + 8);\n\tunsigned need = (unsigned) (ext_bool_count + ext_num_count + ext_str_count);\n\tint base = 0;\n\n\tif ((int) need >= (max_entry_size / 2)\n\t    || ext_str_size >= max_entry_size\n\t    || ext_str_limit >= max_entry_size\n\t    || ext_bool_count < 0\n\t    || ext_num_count < 0\n\t    || ext_str_count < 0\n\t    || ext_str_size < 0\n\t    || ext_str_limit < 0) {\n\t    returnDB(TGETENT_NO);\n\t}\n\n\tptr->num_Booleans = UShort(BOOLCOUNT + ext_bool_count);\n\tptr->num_Numbers = UShort(NUMCOUNT + ext_num_count);\n\tptr->num_Strings = UShort(STRCOUNT + ext_str_count);\n\n\tTYPE_REALLOC(NCURSES_SBOOL, ptr->num_Booleans, ptr->Booleans);\n\tTYPE_REALLOC(NCURSES_INT2, ptr->num_Numbers, ptr->Numbers);\n\tTYPE_REALLOC(char *, ptr->num_Strings, ptr->Strings);\n\n\tTR(TRACE_DATABASE, (\"extended header is %d/%d/%d(%d:%d)\",\n\t\t\t    ext_bool_count, ext_num_count, ext_str_count,\n\t\t\t    ext_str_size, ext_str_limit));\n\n\tTR(TRACE_DATABASE, (\"READ %d extended-booleans @%d\",\n\t\t\t    ext_bool_count, offset));\n\tif ((ptr->ext_Booleans = UShort(ext_bool_count)) != 0) {\n\t    if (Read(ptr->Booleans + BOOLCOUNT, (unsigned)\n\t\t     ext_bool_count) != ext_bool_count) {\n\t\treturnDB(TGETENT_NO);\n\t    }\n\t}\n\teven_boundary(ext_bool_count);\n\n\tTR(TRACE_DATABASE, (\"READ %d extended-numbers @%d\",\n\t\t\t    ext_num_count, offset));\n\tif ((ptr->ext_Numbers = UShort(ext_num_count)) != 0) {\n\t    if (!read_numbers(buf, ext_num_count)) {\n\t\treturnDB(TGETENT_NO);\n\t    }\n\t    TR(TRACE_DATABASE, (\"Before converting extended-numbers\"));\n\t    convert_numbers(buf, ptr->Numbers + NUMCOUNT, ext_num_count);\n\t}\n\n\tTR(TRACE_DATABASE, (\"READ extended-offsets @%d\", offset));\n\tif ((ext_str_count + (int) need) >= (max_entry_size / 2)) {\n\t    returnDB(TGETENT_NO);\n\t}\n\tif ((ext_str_count || need)\n\t    && !read_shorts(buf, ext_str_count + (int) need)) {\n\t    returnDB(TGETENT_NO);\n\t}\n\n\tTR(TRACE_DATABASE, (\"READ %d bytes of extended-strings @%d\",\n\t\t\t    ext_str_limit, offset));\n\n\tif (ext_str_limit) {\n\t    ptr->ext_str_table = typeMalloc(char, (size_t) ext_str_limit);\n\t    if (ptr->ext_str_table == 0) {\n\t\treturnDB(TGETENT_NO);\n\t    }\n\t    if (Read(ptr->ext_str_table, (unsigned) ext_str_limit) != ext_str_limit) {\n\t\treturnDB(TGETENT_NO);\n\t    }\n\t    TR(TRACE_DATABASE, (\"first extended-string is %s\", _nc_visbuf(ptr->ext_str_table)));\n\t}\n\n\tif ((ptr->ext_Strings = UShort(ext_str_count)) != 0) {\n\t    TR(TRACE_DATABASE,\n\t       (\"Before computing extended-string capabilities str_count=%d, ext_str_count=%d\",\n\t\tstr_count, ext_str_count));\n\t    convert_strings(buf, ptr->Strings + str_count, ext_str_count,\n\t\t\t    ext_str_limit, ptr->ext_str_table);\n\t    for (i = ext_str_count - 1; i >= 0; i--) {\n\t\tTR(TRACE_DATABASE, (\"MOVE from [%d:%d] %s\",\n\t\t\t\t    i, i + str_count,\n\t\t\t\t    _nc_visbuf(ptr->Strings[i + str_count])));\n\t\tptr->Strings[i + STRCOUNT] = ptr->Strings[i + str_count];\n\t\tif (VALID_STRING(ptr->Strings[i + STRCOUNT]))\n\t\t    base += (int) (strlen(ptr->Strings[i + STRCOUNT]) + 1);\n\t\tTR(TRACE_DATABASE, (\"... to    [%d] %s\",\n\t\t\t\t    i + STRCOUNT,\n\t\t\t\t    _nc_visbuf(ptr->Strings[i + STRCOUNT])));\n\t    }\n\t}\n\n\tif (need) {\n\t    if (ext_str_count >= (max_entry_size / 2)) {\n\t\treturnDB(TGETENT_NO);\n\t    }\n\t    if ((ptr->ext_Names = TYPE_CALLOC(char *, need)) == 0) {\n\t\treturnDB(TGETENT_NO);\n\t    }\n\t    TR(TRACE_DATABASE,\n\t       (\"ext_NAMES starting @%d in extended_strings, first = %s\",\n\t\tbase, _nc_visbuf(ptr->ext_str_table + base)));\n\t    convert_strings(buf + (2 * ext_str_count),\n\t\t\t    ptr->ext_Names,\n\t\t\t    (int) need,\n\t\t\t    ext_str_limit, ptr->ext_str_table + base);\n\t}\n\n\tTR(TRACE_DATABASE,\n\t   (\"...done reading terminfo bool %d(%d) num %d(%d) str %d(%d)\",\n\t    ptr->num_Booleans, ptr->ext_Booleans,\n\t    ptr->num_Numbers, ptr->ext_Numbers,\n\t    ptr->num_Strings, ptr->ext_Strings));\n\n\tTR(TRACE_DATABASE, (\"extend: num_Booleans:%d\", ptr->num_Booleans));\n    } else\n#endif /* NCURSES_XNAMES */\n    {\n\tTR(TRACE_DATABASE, (\"...done reading terminfo bool %d num %d str %d\",\n\t\t\t    bool_count, num_count, str_count));\n#if NCURSES_XNAMES\n\tTR(TRACE_DATABASE, (\"normal: num_Booleans:%d\", ptr->num_Booleans));\n#endif\n    }\n\n    for (i = bool_count; i < BOOLCOUNT; i++)\n\tptr->Booleans[i] = FALSE;\n    for (i = num_count; i < NUMCOUNT; i++)\n\tptr->Numbers[i] = ABSENT_NUMERIC;\n    for (i = str_count; i < STRCOUNT; i++)\n\tptr->Strings[i] = ABSENT_STRING;\n\n    returnDB(TGETENT_YES);\n}\n\n/*\n *\tint\n *\t_nc_read_file_entry(filename, ptr)\n *\n *\tRead the compiled terminfo entry in the given file into the\n *\tstructure pointed to by ptr, allocating space for the string\n *\ttable.\n */\nNCURSES_EXPORT(int)\n_nc_read_file_entry(const char *const filename, TERMTYPE2 *ptr)\n/* return 1 if read, 0 if not found or garbled */\n{\n    FILE *fp = 0;\n    int code;\n\n    if (_nc_access(filename, R_OK) < 0\n\t|| (fp = fopen(filename, \"rb\")) == 0) {\n\tTR(TRACE_DATABASE, (\"cannot open terminfo %s (errno=%d)\", filename, errno));\n\tcode = TGETENT_NO;\n    } else {\n\tint limit;\n\tchar buffer[MAX_ENTRY_SIZE + 1];\n\n\tif ((limit = (int) fread(buffer, sizeof(char), sizeof(buffer), fp))\n\t    > 0) {\n\n\t    TR(TRACE_DATABASE, (\"read terminfo %s\", filename));\n\t    if ((code = _nc_read_termtype(ptr, buffer, limit)) == TGETENT_NO) {\n\t\t_nc_free_termtype2(ptr);\n\t    }\n\t} else {\n\t    code = TGETENT_NO;\n\t}\n\tfclose(fp);\n    }\n\n    return (code);\n}\n\n#if USE_HASHED_DB\n/*\n * Return if if we can build the filename of a \".db\" file.\n */\nstatic bool\nmake_db_filename(char *filename, unsigned limit, const char *const path)\n{\n    static const char suffix[] = DBM_SUFFIX;\n\n    size_t lens = sizeof(suffix) - 1;\n    size_t size = strlen(path);\n    size_t test = lens + size;\n    bool result = FALSE;\n\n    if (test < limit) {\n\tif (size >= lens\n\t    && !strcmp(path + size - lens, suffix))\n\t    _nc_STRCPY(filename, path, limit);\n\telse\n\t    _nc_SPRINTF(filename, _nc_SLIMIT(limit) \"%s%s\", path, suffix);\n\tresult = TRUE;\n    }\n    return result;\n}\n#endif\n\n/*\n * Return true if we can build the name of a filesystem entry.\n */\nstatic bool\nmake_dir_filename(char *filename,\n\t\t  unsigned limit,\n\t\t  const char *const path,\n\t\t  const char *name)\n{\n    bool result = FALSE;\n\n#if NCURSES_USE_TERMCAP\n    if (_nc_is_dir_path(path))\n#endif\n    {\n\tunsigned need = (unsigned) (LEAF_LEN + 3 + strlen(path) + strlen(name));\n\n\tif (need <= limit) {\n\t    _nc_SPRINTF(filename, _nc_SLIMIT(limit)\n\t\t\t\"%s/\" LEAF_FMT \"/%s\", path, *name, name);\n\t    result = TRUE;\n\t}\n    }\n    return result;\n}\n\nstatic int\nlookup_b64(int *target, const char **source)\n{\n    int result = 3;\n    int j;\n    /*\n     * ncurses' quickdump writes only RFC 4648 \"url/filename-safe\" encoding,\n     * but accepts RFC-3548\n     */\n    for (j = 0; j < 4; ++j) {\n\tint ch = UChar(**source);\n\t*source += 1;\n\tif (ch >= 'A' && ch <= 'Z') {\n\t    target[j] = (ch - 'A');\n\t} else if (ch >= 'a' && ch <= 'z') {\n\t    target[j] = 26 + (ch - 'a');\n\t} else if (ch >= '0' && ch <= '9') {\n\t    target[j] = 52 + (ch - '0');\n\t} else if (ch == '-' || ch == '+') {\n\t    target[j] = 62;\n\t} else if (ch == '_' || ch == '/') {\n\t    target[j] = 63;\n\t} else if (ch == '=') {\n\t    target[j] = 64;\n\t    result--;\n\t} else {\n\t    result = -1;\n\t    break;\n\t}\n    }\n    return result;\n}\n\nstatic int\ndecode_hex(const char **source)\n{\n    int result = 0;\n    int nibble;\n    int ch;\n\n    for (nibble = 0; nibble < 2; ++nibble) {\n\tresult <<= 4;\n\tch = UChar(**source);\n\t*source += 1;\n\tif (ch >= '0' && ch <= '9') {\n\t    ch -= '0';\n\t} else if (ch >= 'A' && ch <= 'F') {\n\t    ch -= 'A';\n\t    ch += 10;\n\t} else if (ch >= 'a' && ch <= 'f') {\n\t    ch -= 'a';\n\t    ch += 10;\n\t} else {\n\t    result = -1;\n\t    break;\n\t}\n\tresult |= ch;\n    }\n    return result;\n}\n\nstatic int\ndecode_quickdump(char *target, const char *source)\n{\n    char *base = target;\n    int result = 0;\n\n    if (!strncmp(source, \"b64:\", 4)) {\n\tsource += 4;\n\twhile (*source != '\\0') {\n\t    int bits[4];\n\t    int ch = lookup_b64(bits, &source);\n\t    if (ch < 0 || (ch + target - base) >= MAX_ENTRY_SIZE) {\n\t\tresult = 0;\n\t\tbreak;\n\t    }\n\t    result += ch;\n\t    *target++ = (char) ((bits[0] << 2) | (bits[1] >> 4));\n\t    if (bits[2] < 64) {\n\t\t*target++ = (char) ((bits[1] << 4) | (bits[2] >> 2));\n\t\tif (bits[3] < 64) {\n\t\t    *target++ = (char) ((bits[2] << 6) | bits[3]);\n\t\t}\n\t    }\n\t}\n    } else if (!strncmp(source, \"hex:\", 4)) {\n\tsource += 4;\n\twhile (*source != '\\0') {\n\t    int ch = decode_hex(&source);\n\t    if (ch < 0 || (target - base) >= MAX_ENTRY_SIZE) {\n\t\tresult = 0;\n\t\tbreak;\n\t    }\n\t    *target++ = (char) ch;\n\t    ++result;\n\t}\n    }\n    return result;\n}\n\n/*\n * Build a terminfo pathname and try to read the data.  Returns TGETENT_YES on\n * success, TGETENT_NO on failure.\n */\nstatic int\n_nc_read_tic_entry(char *filename,\n\t\t   unsigned limit,\n\t\t   const char *const path,\n\t\t   const char *name,\n\t\t   TERMTYPE2 *const tp)\n{\n    int code = TGETENT_NO;\n#if USE_HASHED_DB\n    DB *capdbp;\n#endif\n    char buffer[MAX_ENTRY_SIZE + 1];\n    int used;\n\n    TR(TRACE_DATABASE,\n       (T_CALLED(\"_nc_read_tic_entry(file=%p, path=%s, name=%s)\"),\n\tfilename, path, name));\n\n    if ((used = decode_quickdump(buffer, path)) != 0\n\t&& (code = _nc_read_termtype(tp, buffer, used)) == TGETENT_YES\n\t&& _nc_name_match(tp->term_names, name, \"|\")) {\n\tTR(TRACE_DATABASE, (\"loaded quick-dump for %s\", name));\n    } else\n#if USE_HASHED_DB\n\tif (make_db_filename(filename, limit, path)\n\t    && (capdbp = _nc_db_open(filename, FALSE)) != 0) {\n\n\tDBT key, data;\n\tint reccnt = 0;\n\tchar *save = strdup(name);\n\n\tmemset(&key, 0, sizeof(key));\n\tkey.data = save;\n\tkey.size = strlen(save);\n\n\t/*\n\t * This lookup could return termcap data, which we do not want.  We are\n\t * looking for compiled (binary) terminfo data.\n\t *\n\t * cgetent uses a two-level lookup.  On the first it uses the given\n\t * name to return a record containing only the aliases for an entry. \n\t * On the second (using that list of aliases as a key), it returns the\n\t * content of the terminal description.  We expect second lookup to\n\t * return data beginning with the same set of aliases.\n\t *\n\t * For compiled terminfo, the list of aliases in the second case will\n\t * be null-terminated.  A termcap entry will not be, and will run on\n\t * into the description.  So we can easily distinguish between the two\n\t * (source/binary) by checking the lengths.\n\t */\n\twhile (_nc_db_get(capdbp, &key, &data) == 0) {\n\t    char *have = (char *) data.data;\n\t    used = (int) data.size - 1;\n\n\t    if (*have++ == 0) {\n\t\tif (data.size > key.size\n\t\t    && IS_TIC_MAGIC(have)) {\n\t\t    code = _nc_read_termtype(tp, have, used);\n\t\t    if (code == TGETENT_NO) {\n\t\t\t_nc_free_termtype2(tp);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Just in case we have a corrupt database, do not waste time with\n\t     * it.\n\t     */\n\t    if (++reccnt >= 3)\n\t\tbreak;\n\n\t    /*\n\t     * Prepare for the second level.\n\t     */\n\t    key.data = have;\n\t    key.size = used;\n\t}\n\n\tfree(save);\n    } else\t\t\t/* may be either filesystem or flat file */\n#endif\n    if (make_dir_filename(filename, limit, path, name)) {\n\tcode = _nc_read_file_entry(filename, tp);\n    }\n#if NCURSES_USE_TERMCAP\n    else if (code != TGETENT_YES) {\n\tcode = _nc_read_termcap_entry(name, tp);\n\t_nc_SPRINTF(filename, _nc_SLIMIT(PATH_MAX)\n\t\t    \"%.*s\", PATH_MAX - 1, _nc_get_source());\n    }\n#endif\n    returnDB(code);\n}\n#endif /* NCURSES_USE_DATABASE */\n\n/*\n * Find and read the compiled entry for a given terminal type, if it exists. \n * We take pains here to make sure no combination of environment variables and\n * terminal type name can be used to overrun the file buffer.\n */\nNCURSES_EXPORT(int)\n_nc_read_entry2(const char *const name, char *const filename, TERMTYPE2 *const tp)\n{\n    int code = TGETENT_NO;\n\n    _nc_SPRINTF(filename, _nc_SLIMIT(PATH_MAX)\n\t\t\"%.*s\", PATH_MAX - 1, name);\n\n    if (strlen(name) == 0\n\t|| strcmp(name, \".\") == 0\n\t|| strcmp(name, \"..\") == 0\n\t|| _nc_pathlast(name) != 0\n\t|| strchr(name, NCURSES_PATHSEP) != 0) {\n\tTR(TRACE_DATABASE, (\"illegal or missing entry name '%s'\", name));\n    } else {\n#if NCURSES_USE_DATABASE\n\tDBDIRS state;\n\tint offset;\n\tconst char *path;\n\n\t_nc_first_db(&state, &offset);\n\tcode = TGETENT_ERR;\n\twhile ((path = _nc_next_db(&state, &offset)) != 0) {\n\t    code = _nc_read_tic_entry(filename, PATH_MAX, path, name, tp);\n\t    if (code == TGETENT_YES) {\n\t\t_nc_last_db();\n\t\tbreak;\n\t    }\n\t}\n#elif NCURSES_USE_TERMCAP\n\tif (code != TGETENT_YES) {\n\t    code = _nc_read_termcap_entry(name, tp);\n\t    _nc_SPRINTF(filename, _nc_SLIMIT(PATH_MAX)\n\t\t\t\"%.*s\", PATH_MAX - 1, _nc_get_source());\n\t}\n#endif\n    }\n    return code;\n}\n\n#if NCURSES_EXT_NUMBERS\n/*\n * This entrypoint is used by tack.\n */\nNCURSES_EXPORT(int)\n_nc_read_entry(const char *const name, char *const filename, TERMTYPE *const tp)\n{\n    TERMTYPE2 dummy;\n    int rc;\n    rc = _nc_read_entry2(name, filename, &dummy);\n    if (rc == TGETENT_YES)\n\t_nc_export_termtype2(tp, &dummy);\n    return rc;\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 2000-2012,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey                                                *\n ****************************************************************************/\n\n/*\n**\tlib_mvcur.c\n**/\n\n#include <curses.priv.h>\n#include <tic.h>\n\nMODULE_ID(\"$Id: strings.c,v 1.9 2017/08/26 13:16:11 tom Exp $\")\n\n/****************************************************************************\n * Useful string functions (especially for mvcur)\n ****************************************************************************/\n\n#if !HAVE_STRSTR\nNCURSES_EXPORT(char *)\n_nc_strstr(const char *haystack, const char *needle)\n{\n    size_t len1 = strlen(haystack);\n    size_t len2 = strlen(needle);\n    char *result = 0;\n\n    while ((len1 != 0) && (len1-- >= len2)) {\n\tif (!strncmp(haystack, needle, len2)) {\n\t    result = (char *) haystack;\n\t    break;\n\t}\n\thaystack++;\n    }\n    return result;\n}\n#endif\n\n/*\n * Initialize the descriptor so we can append to it.  Note that 'src' may\n * be a null pointer (see _nc_str_null), so the corresponding strcat and\n * strcpy calls have to allow for this.\n */\nNCURSES_EXPORT(string_desc *)\n_nc_str_init(string_desc * dst, char *src, size_t len)\n{\n    if (dst != 0) {\n\tdst->s_head = src;\n\tdst->s_tail = src;\n\tdst->s_size = len - 1;\n\tdst->s_init = dst->s_size;\n\tif (src != 0)\n\t    *src = 0;\n    }\n    return dst;\n}\n\n/*\n * Initialize the descriptor for only tracking the amount of memory used.\n */\nNCURSES_EXPORT(string_desc *)\n_nc_str_null(string_desc * dst, size_t len)\n{\n    return _nc_str_init(dst, 0, len);\n}\n\n/*\n * Copy a descriptor\n */\nNCURSES_EXPORT(string_desc *)\n_nc_str_copy(string_desc * dst, string_desc * src)\n{\n    *dst = *src;\n    return dst;\n}\n\n/*\n * Replaces strcat into a fixed buffer, returning false on failure.\n */\nNCURSES_EXPORT(bool)\n_nc_safe_strcat(string_desc * dst, const char *src)\n{\n    if (PRESENT(src)) {\n\tsize_t len = strlen(src);\n\n\tif (len < dst->s_size) {\n\t    if (dst->s_tail != 0) {\n\t\t_nc_STRCPY(dst->s_tail, src, dst->s_size);\n\t\tdst->s_tail += len;\n\t    }\n\t    dst->s_size -= len;\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Replaces strcpy into a fixed buffer, returning false on failure.\n */\nNCURSES_EXPORT(bool)\n_nc_safe_strcpy(string_desc * dst, const char *src)\n{\n    if (PRESENT(src)) {\n\tsize_t len = strlen(src);\n\n\tif (len < dst->s_size) {\n\t    if (dst->s_head != 0) {\n\t\t_nc_STRCPY(dst->s_head, src, dst->s_size);\n\t\tdst->s_tail = dst->s_head + len;\n\t    }\n\t    dst->s_size = dst->s_init - len;\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n","/****************************************************************************\n * Copyright (c) 1998-2011,2012 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey                 1997-on                        *\n ****************************************************************************/\n/*\n *\ttrace_buf.c - Tracing/Debugging buffers (attributes)\n */\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: trace_buf.c,v 1.20 2012/02/22 22:34:31 tom Exp $\")\n\n#ifdef TRACE\n\n#define MyList _nc_globals.tracebuf_ptr\n#define MySize _nc_globals.tracebuf_used\n\nstatic char *\n_nc_trace_alloc(int bufnum, size_t want)\n{\n    char *result = 0;\n\n    if (bufnum >= 0) {\n\tif ((size_t) (bufnum + 1) > MySize) {\n\t    size_t need = (size_t) (bufnum + 1) * 2;\n\t    if ((MyList = typeRealloc(TRACEBUF, need, MyList)) != 0) {\n\t\twhile (need > MySize)\n\t\t    MyList[MySize++].text = 0;\n\t    }\n\t}\n\n\tif (MyList != 0) {\n\t    if (MyList[bufnum].text == 0\n\t\t|| want > MyList[bufnum].size) {\n\t\tMyList[bufnum].text = typeRealloc(char, want, MyList[bufnum].text);\n\t\tif (MyList[bufnum].text != 0)\n\t\t    MyList[bufnum].size = want;\n\t    }\n\t    result = MyList[bufnum].text;\n\t}\n    }\n#if NO_LEAKS\n    else {\n\tif (MySize) {\n\t    if (MyList) {\n\t\twhile (MySize--) {\n\t\t    if (MyList[MySize].text != 0) {\n\t\t\tfree(MyList[MySize].text);\n\t\t    }\n\t\t}\n\t\tfree(MyList);\n\t\tMyList = 0;\n\t    }\n\t    MySize = 0;\n\t}\n    }\n#endif\n    return result;\n}\n\n/*\n * (re)Allocate a buffer big enough for the caller's wants.\n */\nNCURSES_EXPORT(char *)\n_nc_trace_buf(int bufnum, size_t want)\n{\n    char *result = _nc_trace_alloc(bufnum, want);\n    if (result != 0)\n\t*result = '\\0';\n    return result;\n}\n\n/*\n * Append a new string to an existing buffer.\n */\nNCURSES_EXPORT(char *)\n_nc_trace_bufcat(int bufnum, const char *value)\n{\n    char *buffer = _nc_trace_alloc(bufnum, (size_t) 0);\n    if (buffer != 0) {\n\tsize_t have = strlen(buffer);\n\tsize_t need = strlen(value) + have;\n\n\tbuffer = _nc_trace_alloc(bufnum, 1 + need);\n\tif (buffer != 0)\n\t    _nc_STRCPY(buffer + have, value, need);\n\n    }\n    return buffer;\n}\n#else\nEMPTY_MODULE(_nc_empty_trace_buf)\n#endif /* TRACE */\n","/* generated by MKunctrl.awk */\n\n#include <curses.priv.h>\n#include <ctype.h>\n\n#undef unctrl\n\nNCURSES_EXPORT(NCURSES_CONST char *) safe_unctrl(SCREEN *sp, chtype ch)\n{\nstatic const short unctrl_table[] = {\n       0,   3,   6,   9,  12,  15,  18,  21,\n      24,  27,  30,  33,  36,  39,  42,  45,\n      48,  51,  54,  57,  60,  63,  66,  69,\n      72,  75,  78,  81,  84,  87,  90,  93,\n      96,  98, 100, 102, 104, 106, 108, 110,\n     112, 114, 116, 118, 120, 122, 124, 126,\n     128, 130, 132, 134, 136, 138, 140, 142,\n     144, 146, 148, 150, 152, 154, 156, 158,\n     160, 162, 164, 166, 168, 170, 172, 174,\n     176, 178, 180, 182, 184, 186, 188, 190,\n     192, 194, 196, 198, 200, 202, 204, 206,\n     208, 210, 212, 214, 216, 218, 220, 222,\n     224, 226, 228, 230, 232, 234, 236, 238,\n     240, 242, 244, 246, 248, 250, 252, 254,\n     256, 258, 260, 262, 264, 266, 268, 270,\n     272, 274, 276, 278, 280, 282, 284, 286,\n     289, 292, 295, 298, 301, 304, 307, 310,\n     313, 316, 319, 322, 325, 328, 331, 334,\n     337, 340, 343, 346, 349, 352, 355, 358,\n     361, 364, 367, 370, 373, 376, 379, 382,\n     385, 389, 393, 397, 401, 405, 409, 413,\n     417, 421, 425, 429, 433, 437, 441, 445,\n     449, 453, 457, 461, 465, 469, 473, 477,\n     481, 485, 489, 493, 497, 501, 505, 509,\n     513, 517, 521, 525, 529, 533, 537, 541,\n     545, 549, 553, 557, 561, 565, 569, 573,\n     577, 581, 585, 589, 593, 597, 601, 605,\n     609, 613, 617, 621, 625, 629, 633, 637,\n     641, 645, 649, 653, 657, 661, 665, 669,\n     673, 677, 681, 685, 689, 693, 697, 701,\n     705, 709, 713, 717, 721, 725, 729, 733,\n     737, 741, 745, 749, 753, 757, 761, 765,};\n\n#if NCURSES_EXT_FUNCS\nstatic const short unctrl_c1[] = {\n     768, 770, 772, 774, 776, 778, 780, 782,\n     784, 786, 788, 790, 792, 794, 796, 798,\n     800, 802, 804, 806, 808, 810, 812, 814,\n     816, 818, 820, 822, 824, 826, 828, 830,\n     832, 834, 836, 838, 840, 842, 844, 846,\n     848, 850, 852, 854, 856, 858, 860, 862,\n     864, 866, 868, 870, 872, 874, 876, 878,\n     880, 882, 884, 886, 888, 890, 892, 894,\n     896, 898, 900, 902, 904, 906, 908, 910,\n     912, 914, 916, 918, 920, 922, 924, 926,\n     928, 930, 932, 934, 936, 938, 940, 942,\n     944, 946, 948, 950, 952, 954, 956, 958,\n     960, 962, 964, 966, 968, 970, 972, 974,\n     976, 978, 980, 982, 984, 986, 988, 990,\n     992, 994, 996, 998,1000,1002,1004,1006,\n    1008,1010,1012,1014,1016,1018,1020,1022,};\n#endif /* NCURSES_EXT_FUNCS */\n\nstatic const char unctrl_blob[] = \n    \"^\\100\\0^\\101\\0^\\102\\0^\\103\\0^\\104\\0^\\105\\0^\\106\\0^\\107\\0\"\n    \"^\\110\\0^\\111\\0^\\112\\0^\\113\\0^\\114\\0^\\115\\0^\\116\\0^\\117\\0\"\n    \"^\\120\\0^\\121\\0^\\122\\0^\\123\\0^\\124\\0^\\125\\0^\\126\\0^\\127\\0\"\n    \"^\\130\\0^\\131\\0^\\132\\0^\\133\\0^\\134\\0^\\135\\0^\\136\\0^\\137\\0\"\n    \"\\040\\0\\041\\0\\042\\0\\043\\0\\044\\0\\045\\0\\046\\0\\047\\0\"\n    \"\\050\\0\\051\\0\\052\\0\\053\\0\\054\\0\\055\\0\\056\\0\\057\\0\"\n    \"\\060\\0\\061\\0\\062\\0\\063\\0\\064\\0\\065\\0\\066\\0\\067\\0\"\n    \"\\070\\0\\071\\0\\072\\0\\073\\0\\074\\0\\075\\0\\076\\0\\077\\0\"\n    \"\\100\\0\\101\\0\\102\\0\\103\\0\\104\\0\\105\\0\\106\\0\\107\\0\"\n    \"\\110\\0\\111\\0\\112\\0\\113\\0\\114\\0\\115\\0\\116\\0\\117\\0\"\n    \"\\120\\0\\121\\0\\122\\0\\123\\0\\124\\0\\125\\0\\126\\0\\127\\0\"\n    \"\\130\\0\\131\\0\\132\\0\\133\\0\\134\\0\\135\\0\\136\\0\\137\\0\"\n    \"\\140\\0\\141\\0\\142\\0\\143\\0\\144\\0\\145\\0\\146\\0\\147\\0\"\n    \"\\150\\0\\151\\0\\152\\0\\153\\0\\154\\0\\155\\0\\156\\0\\157\\0\"\n    \"\\160\\0\\161\\0\\162\\0\\163\\0\\164\\0\\165\\0\\166\\0\\167\\0\"\n    \"\\170\\0\\171\\0\\172\\0\\173\\0\\174\\0\\175\\0\\176\\0^?\\0\"\n    \"~\\100\\0~\\101\\0~\\102\\0~\\103\\0~\\104\\0~\\105\\0~\\106\\0~\\107\\0\"\n    \"~\\110\\0~\\111\\0~\\112\\0~\\113\\0~\\114\\0~\\115\\0~\\116\\0~\\117\\0\"\n    \"~\\120\\0~\\121\\0~\\122\\0~\\123\\0~\\124\\0~\\125\\0~\\126\\0~\\127\\0\"\n    \"~\\130\\0~\\131\\0~\\132\\0~\\133\\0~\\134\\0~\\135\\0~\\136\\0~\\137\\0\"\n    \"M-\\040\\0M-\\041\\0M-\\042\\0M-\\043\\0M-\\044\\0M-\\045\\0M-\\046\\0M-\\047\\0\"\n    \"M-\\050\\0M-\\051\\0M-\\052\\0M-\\053\\0M-\\054\\0M-\\055\\0M-\\056\\0M-\\057\\0\"\n    \"M-\\060\\0M-\\061\\0M-\\062\\0M-\\063\\0M-\\064\\0M-\\065\\0M-\\066\\0M-\\067\\0\"\n    \"M-\\070\\0M-\\071\\0M-\\072\\0M-\\073\\0M-\\074\\0M-\\075\\0M-\\076\\0M-\\077\\0\"\n    \"M-\\100\\0M-\\101\\0M-\\102\\0M-\\103\\0M-\\104\\0M-\\105\\0M-\\106\\0M-\\107\\0\"\n    \"M-\\110\\0M-\\111\\0M-\\112\\0M-\\113\\0M-\\114\\0M-\\115\\0M-\\116\\0M-\\117\\0\"\n    \"M-\\120\\0M-\\121\\0M-\\122\\0M-\\123\\0M-\\124\\0M-\\125\\0M-\\126\\0M-\\127\\0\"\n    \"M-\\130\\0M-\\131\\0M-\\132\\0M-\\133\\0M-\\134\\0M-\\135\\0M-\\136\\0M-\\137\\0\"\n    \"M-\\140\\0M-\\141\\0M-\\142\\0M-\\143\\0M-\\144\\0M-\\145\\0M-\\146\\0M-\\147\\0\"\n    \"M-\\150\\0M-\\151\\0M-\\152\\0M-\\153\\0M-\\154\\0M-\\155\\0M-\\156\\0M-\\157\\0\"\n    \"M-\\160\\0M-\\161\\0M-\\162\\0M-\\163\\0M-\\164\\0M-\\165\\0M-\\166\\0M-\\167\\0\"\n    \"M-\\170\\0M-\\171\\0M-\\172\\0M-\\173\\0M-\\174\\0M-\\175\\0M-\\176\\0~?\\0\"\n/* printable values in 128-255 range */\n    \"\\200\\0\\201\\0\\202\\0\\203\\0\\204\\0\\205\\0\\206\\0\\207\\0\"\n    \"\\210\\0\\211\\0\\212\\0\\213\\0\\214\\0\\215\\0\\216\\0\\217\\0\"\n    \"\\220\\0\\221\\0\\222\\0\\223\\0\\224\\0\\225\\0\\226\\0\\227\\0\"\n    \"\\230\\0\\231\\0\\232\\0\\233\\0\\234\\0\\235\\0\\236\\0\\237\\0\"\n    \"\\240\\0\\241\\0\\242\\0\\243\\0\\244\\0\\245\\0\\246\\0\\247\\0\"\n    \"\\250\\0\\251\\0\\252\\0\\253\\0\\254\\0\\255\\0\\256\\0\\257\\0\"\n    \"\\260\\0\\261\\0\\262\\0\\263\\0\\264\\0\\265\\0\\266\\0\\267\\0\"\n    \"\\270\\0\\271\\0\\272\\0\\273\\0\\274\\0\\275\\0\\276\\0\\277\\0\"\n    \"\\300\\0\\301\\0\\302\\0\\303\\0\\304\\0\\305\\0\\306\\0\\307\\0\"\n    \"\\310\\0\\311\\0\\312\\0\\313\\0\\314\\0\\315\\0\\316\\0\\317\\0\"\n    \"\\320\\0\\321\\0\\322\\0\\323\\0\\324\\0\\325\\0\\326\\0\\327\\0\"\n    \"\\330\\0\\331\\0\\332\\0\\333\\0\\334\\0\\335\\0\\336\\0\\337\\0\"\n    \"\\340\\0\\341\\0\\342\\0\\343\\0\\344\\0\\345\\0\\346\\0\\347\\0\"\n    \"\\350\\0\\351\\0\\352\\0\\353\\0\\354\\0\\355\\0\\356\\0\\357\\0\"\n    \"\\360\\0\\361\\0\\362\\0\\363\\0\\364\\0\\365\\0\\366\\0\\367\\0\"\n    \"\\370\\0\\371\\0\\372\\0\\373\\0\\374\\0\\375\\0\\376\\0\\377\\0\"\n;\n\n\tint check = (int) ChCharOf(ch);\n\tconst char *result;\n\n(void) sp;\n\tif (check >= 0 && check < (int)SIZEOF(unctrl_table)) {\n#if NCURSES_EXT_FUNCS\n\t\tif ((sp != 0)\n\t\t && (sp->_legacy_coding > 1)\n\t\t && (check >= 128)\n\t\t && (check < 160))\n\t\t\tresult = unctrl_blob + unctrl_c1[check - 128];\n\t\telse\n\t\tif ((check >= 160)\n\t\t && (check < 256)\n\t\t && ((sp != 0)\n\t\t  && ((sp->_legacy_coding > 0)\n\t\t   || (sp->_legacy_coding == 0\n\t\t       && isprint(check)))))\n\t\t\tresult = unctrl_blob + unctrl_c1[check - 128];\n\t\telse\n#endif /* NCURSES_EXT_FUNCS */\n\t\t\tresult = unctrl_blob + unctrl_table[check];\n\t} else {\n\t\tresult = 0;\n\t}\n\treturn (NCURSES_CONST char *)result;\n}\n\nNCURSES_EXPORT(NCURSES_CONST char *) unctrl (chtype ch)\n{\n\treturn safe_unctrl(CURRENT_SCREEN, ch);\n}\n","/****************************************************************************\n * Copyright (c) 2001-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey                        1996-on                 *\n *     and: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n ****************************************************************************/\n\n/*\n *\tvisbuf.c - Tracing/Debugging support routines\n */\n\n#define NEED_NCURSES_CH_T\n#include <curses.priv.h>\n\n#include <tic.h>\n#include <ctype.h>\n\nMODULE_ID(\"$Id: visbuf.c,v 1.49 2017/10/21 23:34:20 tom Exp $\")\n\n#define NUM_VISBUFS 4\n\n#define NormalLen(len) (size_t) (((size_t)(len) + 1) * 4)\n#define WideLen(len)   (size_t) (((size_t)(len) + 1) * 4 * (size_t) MB_CUR_MAX)\n\n#ifdef TRACE\nstatic const char d_quote[] = StringOf(D_QUOTE);\nstatic const char l_brace[] = StringOf(L_BRACE);\nstatic const char r_brace[] = StringOf(R_BRACE);\n#endif\n\n#if USE_STRING_HACKS && HAVE_SNPRINTF\n#define VisChar(tp, chr, limit) _nc_vischar(tp, chr, limit)\n#define LIMIT_ARG ,size_t limit\n#else\n#define VisChar(tp, chr, limit) _nc_vischar(tp, chr)\n#define LIMIT_ARG\t\t/* nothing */\n#endif\n\nstatic char *\n_nc_vischar(char *tp, unsigned c LIMIT_ARG)\n{\n    if (c == '\"' || c == '\\\\') {\n\t*tp++ = '\\\\';\n\t*tp++ = (char) c;\n    } else if (is7bits((int) c) && (isgraph((int) c) || c == ' ')) {\n\t*tp++ = (char) c;\n    } else if (c == '\\n') {\n\t*tp++ = '\\\\';\n\t*tp++ = 'n';\n    } else if (c == '\\r') {\n\t*tp++ = '\\\\';\n\t*tp++ = 'r';\n    } else if (c == '\\b') {\n\t*tp++ = '\\\\';\n\t*tp++ = 'b';\n    } else if (c == '\\033') {\n\t*tp++ = '\\\\';\n\t*tp++ = 'e';\n    } else if (UChar(c) == 0x7f) {\n\t*tp++ = '\\\\';\n\t*tp++ = '^';\n\t*tp++ = '?';\n    } else if (is7bits(c) && iscntrl(UChar(c))) {\n\t*tp++ = '\\\\';\n\t*tp++ = '^';\n\t*tp++ = (char) ('@' + c);\n    } else {\n\t_nc_SPRINTF(tp, _nc_SLIMIT(limit)\n\t\t    \"\\\\%03lo\", (unsigned long) ChCharOf(c));\n\ttp += strlen(tp);\n    }\n    *tp = 0;\n    return tp;\n}\n\nstatic const char *\n_nc_visbuf2n(int bufnum, const char *buf, int len)\n{\n    const char *vbuf = 0;\n    char *tp;\n    int count;\n\n    if (buf == 0)\n\treturn (\"(null)\");\n    if (buf == CANCELLED_STRING)\n\treturn (\"(cancelled)\");\n\n    if (len < 0)\n\tlen = (int) strlen(buf);\n\n    count = len;\n#ifdef TRACE\n    vbuf = tp = _nc_trace_buf(bufnum, NormalLen(len));\n#else\n    {\n\tstatic char *mybuf[NUM_VISBUFS];\n\tint c;\n\n\tif (bufnum < 0) {\n\t    for (c = 0; c < NUM_VISBUFS; ++c) {\n\t\tFreeAndNull(mybuf[c]);\n\t    }\n\t    tp = 0;\n\t} else {\n\t    mybuf[bufnum] = typeRealloc(char, NormalLen(len), mybuf[bufnum]);\n\t    vbuf = tp = mybuf[bufnum];\n\t}\n    }\n#endif\n    if (tp != 0) {\n\tint c;\n\n\t*tp++ = D_QUOTE;\n\twhile ((--count >= 0) && (c = *buf++) != '\\0') {\n\t    tp = VisChar(tp, UChar(c), NormalLen(len));\n\t}\n\t*tp++ = D_QUOTE;\n\t*tp = '\\0';\n    } else {\n\tvbuf = (\"(_nc_visbuf2n failed)\");\n    }\n    return (vbuf);\n}\n\nNCURSES_EXPORT(const char *)\n_nc_visbuf2(int bufnum, const char *buf)\n{\n    return _nc_visbuf2n(bufnum, buf, -1);\n}\n\nNCURSES_EXPORT(const char *)\n_nc_visbuf(const char *buf)\n{\n    return _nc_visbuf2(0, buf);\n}\n\nNCURSES_EXPORT(const char *)\n_nc_visbufn(const char *buf, int len)\n{\n    return _nc_visbuf2n(0, buf, len);\n}\n\n#ifdef TRACE\n#if USE_WIDEC_SUPPORT\n\n#if defined(USE_TERMLIB)\n#define _nc_wchstrlen _my_wchstrlen\nstatic int\n_nc_wchstrlen(const cchar_t *s)\n{\n    int result = 0;\n    while (CharOf(s[result]) != L'\\0') {\n\tresult++;\n    }\n    return result;\n}\n#endif\n\nstatic const char *\n_nc_viswbuf2n(int bufnum, const wchar_t *buf, int len)\n{\n    const char *vbuf;\n    char *tp;\n    int count;\n\n    if (buf == 0)\n\treturn (\"(null)\");\n\n    if (len < 0)\n\tlen = (int) wcslen(buf);\n\n    count = len;\n#ifdef TRACE\n    vbuf = tp = _nc_trace_buf(bufnum, WideLen(len));\n#else\n    {\n\tstatic char *mybuf[NUM_VISBUFS];\n\tmybuf[bufnum] = typeRealloc(char, WideLen(len), mybuf[bufnum]);\n\tvbuf = tp = mybuf[bufnum];\n    }\n#endif\n    if (tp != 0) {\n\twchar_t c;\n\n\t*tp++ = D_QUOTE;\n\twhile ((--count >= 0) && (c = *buf++) != '\\0') {\n\t    char temp[CCHARW_MAX + 80];\n\t    int j = wctomb(temp, c), k;\n\t    if (j <= 0) {\n\t\t_nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t    \"\\\\u%08X\", (unsigned) c);\n\t\tj = (int) strlen(temp);\n\t    }\n\t    for (k = 0; k < j; ++k) {\n\t\ttp = VisChar(tp, UChar(temp[k]), WideLen(len));\n\t    }\n\t}\n\t*tp++ = D_QUOTE;\n\t*tp = '\\0';\n    } else {\n\tvbuf = (\"(_nc_viswbuf2n failed)\");\n    }\n    return (vbuf);\n}\n\nNCURSES_EXPORT(const char *)\n_nc_viswbuf2(int bufnum, const wchar_t *buf)\n{\n    return _nc_viswbuf2n(bufnum, buf, -1);\n}\n\nNCURSES_EXPORT(const char *)\n_nc_viswbuf(const wchar_t *buf)\n{\n    return _nc_viswbuf2(0, buf);\n}\n\nNCURSES_EXPORT(const char *)\n_nc_viswbufn(const wchar_t *buf, int len)\n{\n    return _nc_viswbuf2n(0, buf, len);\n}\n\n/* this special case is used for wget_wstr() */\nNCURSES_EXPORT(const char *)\n_nc_viswibuf(const wint_t *buf)\n{\n    static wchar_t *mybuf;\n    static unsigned mylen;\n    unsigned n;\n\n    for (n = 0; buf[n] != 0; ++n) {\n\t;\t\t\t/* empty */\n    }\n    if (mylen < ++n) {\n\tmylen = n + 80;\n\tif (mybuf != 0)\n\t    mybuf = typeRealloc(wchar_t, mylen, mybuf);\n\telse\n\t    mybuf = typeMalloc(wchar_t, mylen);\n    }\n    if (mybuf != 0) {\n\tfor (n = 0; buf[n] != 0; ++n) {\n\t    mybuf[n] = (wchar_t) buf[n];\n\t}\n\tmybuf[n] = L'\\0';\n    }\n\n    return _nc_viswbuf2(0, mybuf);\n}\n#endif /* USE_WIDEC_SUPPORT */\n\n/* use these functions for displaying parts of a line within a window */\nNCURSES_EXPORT(const char *)\n_nc_viscbuf2(int bufnum, const NCURSES_CH_T * buf, int len)\n{\n    char *result = _nc_trace_buf(bufnum, (size_t) BUFSIZ);\n\n    if (result != 0) {\n\tint first = 0;\n\n#if USE_WIDEC_SUPPORT\n\tif (len < 0)\n\t    len = _nc_wchstrlen(buf);\n#endif /* USE_WIDEC_SUPPORT */\n\n\t/*\n\t * Display one or more strings followed by attributes.\n\t */\n\twhile (first < len) {\n\t    attr_t attr = AttrOf(buf[first]);\n\t    int last = len - 1;\n\t    int j;\n\n\t    for (j = first + 1; j < len; ++j) {\n\t\tif (!SameAttrOf(buf[j], buf[first])) {\n\t\t    last = j - 1;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    (void) _nc_trace_bufcat(bufnum, l_brace);\n\t    (void) _nc_trace_bufcat(bufnum, d_quote);\n\t    for (j = first; j <= last; ++j) {\n\t\tconst char *found = _nc_altcharset_name(attr, (chtype)\n\t\t\t\t\t\t\tCharOf(buf[j]));\n\t\tif (found != 0) {\n\t\t    (void) _nc_trace_bufcat(bufnum, found);\n\t\t    attr &= ~A_ALTCHARSET;\n\t\t} else\n#if USE_WIDEC_SUPPORT\n\t\tif (!isWidecExt(buf[j])) {\n\t\t    PUTC_DATA;\n\n\t\t    for (PUTC_i = 0; PUTC_i < CCHARW_MAX; ++PUTC_i) {\n\t\t\tint k;\n\t\t\tchar temp[80];\n\n\t\t\tPUTC_ch = buf[j].chars[PUTC_i];\n\t\t\tif (PUTC_ch == L'\\0') {\n\t\t\t    if (PUTC_i == 0)\n\t\t\t\t(void) _nc_trace_bufcat(bufnum, \"\\\\000\");\n\t\t\t    break;\n\t\t\t}\n\t\t\tPUTC_INIT;\n\t\t\tPUTC_n = (int) wcrtomb(PUTC_buf,\n\t\t\t\t\t       buf[j].chars[PUTC_i], &PUT_st);\n\t\t\tif (PUTC_n <= 0 || buf[j].chars[PUTC_i] > 255) {\n\t\t\t    _nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t\t\t\"{%d:\\\\u%lx}\",\n\t\t\t\t\twcwidth(buf[j].chars[PUTC_i]),\n\t\t\t\t\t(unsigned long) buf[j].chars[PUTC_i]);\n\t\t\t    (void) _nc_trace_bufcat(bufnum, temp);\n\t\t\t    break;\n\t\t\t}\n\t\t\tfor (k = 0; k < PUTC_n; k++) {\n\t\t\t    VisChar(temp, UChar(PUTC_buf[k]), sizeof(temp));\n\t\t\t    (void) _nc_trace_bufcat(bufnum, temp);\n\t\t\t}\n\t\t    }\n\t\t}\n#else\n\t\t{\n\t\t    char temp[80];\n\t\t    VisChar(temp, UChar(buf[j]), sizeof(temp));\n\t\t    (void) _nc_trace_bufcat(bufnum, temp);\n\t\t}\n#endif /* USE_WIDEC_SUPPORT */\n\t    }\n\t    (void) _nc_trace_bufcat(bufnum, d_quote);\n\t    if (attr != A_NORMAL) {\n\t\t(void) _nc_trace_bufcat(bufnum, \" | \");\n\t\t(void) _nc_trace_bufcat(bufnum, _traceattr2(bufnum + 20, attr));\n\t    }\n\t    result = _nc_trace_bufcat(bufnum, r_brace);\n\t    first = last + 1;\n\t}\n    }\n    return result;\n}\n\nNCURSES_EXPORT(const char *)\n_nc_viscbuf(const NCURSES_CH_T * buf, int len)\n{\n    return _nc_viscbuf2(0, buf, len);\n}\n#endif /* TRACE */\n","/****************************************************************************\n * Copyright (c) 1998-2015,2016 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Alexander V Lukyanov                    1997-1998               *\n ****************************************************************************/\n\n/******************************************************************************\n\nNAME\n   hardscroll.c -- hardware-scrolling optimization for ncurses\n\nSYNOPSIS\n   void _nc_scroll_optimize(void)\n\nDESCRIPTION\n\t\t\tOVERVIEW\n\nThis algorithm for computes optimum hardware scrolling to transform an\nold screen (curscr) into a new screen (newscr) via vertical line moves.\n\nBecause the screen has a `grain' (there are insert/delete/scroll line\noperations but no insert/delete/scroll column operations), it is efficient\nbreak the update algorithm into two pieces: a first stage that does only line\nmoves, optimizing the end product of user-invoked insertions, deletions, and\nscrolls; and a second phase (corresponding to the present doupdate code in\nncurses) that does only line transformations.\n\nThe common case we want hardware scrolling for is to handle line insertions\nand deletions in screen-oriented text-editors.  This two-stage approach will\naccomplish that at a low computation and code-size cost.\n\n\t\t\tLINE-MOVE COMPUTATION\n\nNow, to a discussion of the line-move computation.\n\nFor expository purposes, consider the screen lines to be represented by\nintegers 0..23 (with the understanding that the value of 23 may vary).\nLet a new line introduced by insertion, scrolling, or at the bottom of\nthe screen following a line delete be given the index -1.\n\nAssume that the real screen starts with lines 0..23.  Now, we have\nthe following possible line-oriented operations on the screen:\n\nInsertion: inserts a line at a given screen row, forcing all lines below\nto scroll forward.  The last screen line is lost.  For example, an insertion\nat line 5 would produce: 0..4 -1 5..23.\n\nDeletion: deletes a line at a given screen row, forcing all lines below\nto scroll forward.  The last screen line is made new.  For example, a deletion\nat line 7 would produce: 0..6 8..23 -1.\n\nScroll up: move a range of lines up 1.  The bottom line of the range\nbecomes new.  For example, scrolling up the region from 9 to 14 will\nproduce 0..8 10..14 -1 15..23.\n\nScroll down: move a range of lines down 1.  The top line of the range\nbecomes new.  For example, scrolling down the region from 12 to 16 will produce\n0..11 -1 12..15 17..23.\n\nNow, an obvious property of all these operations is that they preserve the\norder of old lines, though not their position in the sequence.\n\nThe key trick of this algorithm is that the original line indices described\nabove are actually maintained as _line[].oldindex fields in the window\nstructure, and stick to each line through scroll and insert/delete operations.\n\nThus, it is possible at update time to look at the oldnum fields and compute\nan optimal set of il/dl/scroll operations that will take the real screen\nlines to the virtual screen lines.  Once these vertical moves have been done,\nwe can hand off to the second stage of the update algorithm, which does line\ntransformations.\n\nNote that the move computation does not need to have the full generality\nof a diff algorithm (which it superficially resembles) because lines cannot\nbe moved out of order.\n\n\t\t\tTHE ALGORITHM\n\nThe scrolling is done in two passes. The first pass is from top to bottom\nscroling hunks UP. The second one is from bottom to top scrolling hunks DOWN.\nObviously enough, no lines to be scrolled will be destroyed. (lav)\n\nHOW TO TEST THIS:\n\nUse the following production:\n\nhardscroll: hardscroll.c\n\t$(CC) -g -DSCROLLDEBUG hardscroll.c -o hardscroll\n\nThen just type scramble vectors and watch.  The following test loads are\na representative sample of cases:\n\n-----------------------------  CUT HERE ------------------------------------\n# No lines moved\n 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23\n#\n# A scroll up\n 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -1\n#\n# A scroll down\n-1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22\n#\n# An insertion (after line 12)\n 0  1  2  3  4  5  6  7  8  9 10 11 12 -1 13 14 15 16 17 18 19 20 21 22\n#\n# A simple deletion (line 10)\n 0  1  2  3  4  5  6  7  8  9  11 12 13 14 15 16 17 18 19 20 21 22 23 -1\n#\n# A more complex case\n-1 -1 -1 -1 -1  3  4  5  6  7  -1 -1  8  9 10 11 12 13 14 15 16 17 -1 -1\n-----------------------------  CUT HERE ------------------------------------\n\nAUTHOR\n    Eric S. Raymond <esr@snark.thyrsus.com>, November 1994\n    New algorithm by Alexander V. Lukyanov <lav@yars.free.net>, Aug 1997\n\n*****************************************************************************/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: hardscroll.c,v 1.53 2016/05/28 23:32:40 tom Exp $\")\n\n#if defined(SCROLLDEBUG) || defined(HASHDEBUG)\n\n# undef screen_lines\n# define screen_lines(sp) MAXLINES\nNCURSES_EXPORT_VAR (int)\n  oldnums[MAXLINES];\n# define OLDNUM(sp,n)\toldnums[n]\n# define _tracef\tprintf\n# undef TR\n# define TR(n, a)\tif (_nc_tracing & (n)) { _tracef a ; putchar('\\n'); }\n\nextern\t\t\t\tNCURSES_EXPORT_VAR(unsigned) _nc_tracing;\n\n#else /* no debug */\n\n/* OLDNUM(n) indicates which line will be shifted to the position n.\n   if OLDNUM(n) == _NEWINDEX, then the line n in new, not shifted from\n   somewhere. */\nNCURSES_EXPORT_VAR (int *)\n  _nc_oldnums = 0;\t\t/* obsolete: keep for ABI compat */\n\n# if USE_HASHMAP\n#  define oldnums(sp)   (sp)->_oldnum_list\n#  define OLDNUM(sp,n)\toldnums(sp)[n]\n# else /* !USE_HASHMAP */\n#  define OLDNUM(sp,n)\tNewScreen(sp)->_line[n].oldindex\n# endif\t/* !USE_HASHMAP */\n\n#define OLDNUM_SIZE(sp) (sp)->_oldnum_size\n\n#endif /* defined(SCROLLDEBUG) || defined(HASHDEBUG) */\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_scroll_optimize) (NCURSES_SP_DCL0)\n/* scroll optimization to transform curscr to newscr */\n{\n    int i;\n    int start, end, shift;\n\n    TR(TRACE_ICALLS, (T_CALLED(\"_nc_scroll_optimize(%p)\"), (void *) SP_PARM));\n\n#if !defined(SCROLLDEBUG) && !defined(HASHDEBUG)\n#if USE_HASHMAP\n    /* get enough storage */\n    assert(OLDNUM_SIZE(SP_PARM) >= 0);\n    assert(screen_lines(SP_PARM) > 0);\n    if ((oldnums(SP_PARM) == 0)\n\t|| (OLDNUM_SIZE(SP_PARM) < screen_lines(SP_PARM))) {\n\tint need_lines = ((OLDNUM_SIZE(SP_PARM) < screen_lines(SP_PARM))\n\t\t\t  ? screen_lines(SP_PARM)\n\t\t\t  : OLDNUM_SIZE(SP_PARM));\n\tint *new_oldnums = typeRealloc(int,\n\t\t\t\t       (size_t) need_lines,\n\t\t\t\t       oldnums(SP_PARM));\n\tif (!new_oldnums)\n\t    return;\n\toldnums(SP_PARM) = new_oldnums;\n\tOLDNUM_SIZE(SP_PARM) = need_lines;\n    }\n    /* calculate the indices */\n    NCURSES_SP_NAME(_nc_hash_map) (NCURSES_SP_ARG);\n#endif\n#endif /* !defined(SCROLLDEBUG) && !defined(HASHDEBUG) */\n\n#ifdef TRACE\n    if (USE_TRACEF(TRACE_UPDATE | TRACE_MOVE)) {\n\tNCURSES_SP_NAME(_nc_linedump) (NCURSES_SP_ARG);\n\t_nc_unlock_global(tracef);\n    }\n#endif /* TRACE */\n\n    /* pass 1 - from top to bottom scrolling up */\n    for (i = 0; i < screen_lines(SP_PARM);) {\n\twhile (i < screen_lines(SP_PARM)\n\t       && (OLDNUM(SP_PARM, i) == _NEWINDEX || OLDNUM(SP_PARM, i) <= i))\n\t    i++;\n\tif (i >= screen_lines(SP_PARM))\n\t    break;\n\n\tshift = OLDNUM(SP_PARM, i) - i;\t\t/* shift > 0 */\n\tstart = i;\n\n\ti++;\n\twhile (i < screen_lines(SP_PARM)\n\t       && OLDNUM(SP_PARM, i) != _NEWINDEX\n\t       && OLDNUM(SP_PARM, i) - i == shift)\n\t    i++;\n\tend = i - 1 + shift;\n\n\tTR(TRACE_UPDATE | TRACE_MOVE, (\"scroll [%d, %d] by %d\", start, end, shift));\n#if !defined(SCROLLDEBUG) && !defined(HASHDEBUG)\n\tif (NCURSES_SP_NAME(_nc_scrolln) (NCURSES_SP_ARGx\n\t\t\t\t\t  shift,\n\t\t\t\t\t  start,\n\t\t\t\t\t  end,\n\t\t\t\t\t  screen_lines(SP_PARM) - 1) == ERR) {\n\t    TR(TRACE_UPDATE | TRACE_MOVE, (\"unable to scroll\"));\n\t    continue;\n\t}\n#endif /* !defined(SCROLLDEBUG) && !defined(HASHDEBUG) */\n    }\n\n    /* pass 2 - from bottom to top scrolling down */\n    for (i = screen_lines(SP_PARM) - 1; i >= 0;) {\n\twhile (i >= 0\n\t       && (OLDNUM(SP_PARM, i) == _NEWINDEX\n\t\t   || OLDNUM(SP_PARM, i) >= i)) {\n\t    i--;\n\t}\n\tif (i < 0)\n\t    break;\n\n\tshift = OLDNUM(SP_PARM, i) - i;\t\t/* shift < 0 */\n\tend = i;\n\n\ti--;\n\twhile (i >= 0\n\t       && OLDNUM(SP_PARM, i) != _NEWINDEX\n\t       && OLDNUM(SP_PARM, i) - i == shift) {\n\t    i--;\n\t}\n\tstart = i + 1 - (-shift);\n\n\tTR(TRACE_UPDATE | TRACE_MOVE, (\"scroll [%d, %d] by %d\", start, end, shift));\n#if !defined(SCROLLDEBUG) && !defined(HASHDEBUG)\n\tif (NCURSES_SP_NAME(_nc_scrolln) (NCURSES_SP_ARGx\n\t\t\t\t\t  shift,\n\t\t\t\t\t  start,\n\t\t\t\t\t  end,\n\t\t\t\t\t  screen_lines(SP_PARM) - 1) == ERR) {\n\t    TR(TRACE_UPDATE | TRACE_MOVE, (\"unable to scroll\"));\n\t    continue;\n\t}\n#endif /* !defined(SCROLLDEBUG) && !defined(HASHDEBUG) */\n    }\n    TR(TRACE_ICALLS, (T_RETURN(\"\")));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_scroll_optimize(void)\n{\n    NCURSES_SP_NAME(_nc_scroll_optimize) (CURRENT_SCREEN);\n}\n#endif\n\n#if defined(TRACE) || defined(SCROLLDEBUG) || defined(HASHDEBUG)\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_linedump) (NCURSES_SP_DCL0)\n/* dump the state of the real and virtual oldnum fields */\n{\n    char *buf = 0;\n    size_t want = ((size_t) screen_lines(SP_PARM) + 1) * 4;\n    (void) SP_PARM;\n\n    if ((buf = typeMalloc(char, want)) != 0) {\n\tint n;\n\n\t*buf = '\\0';\n\tfor (n = 0; n < screen_lines(SP_PARM); n++)\n\t    _nc_SPRINTF(buf + strlen(buf),\n\t\t\t_nc_SLIMIT(want - strlen(buf))\n\t\t\t\" %02d\", OLDNUM(SP_PARM, n));\n\tTR(TRACE_UPDATE | TRACE_MOVE, (\"virt %s\", buf));\n\tfree(buf);\n    }\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_linedump(void)\n{\n    NCURSES_SP_NAME(_nc_linedump) (CURRENT_SCREEN);\n}\n#endif\n\n#endif /* defined(TRACE) || defined(SCROLLDEBUG) */\n\n#ifdef SCROLLDEBUG\n\nint\nmain(int argc GCC_UNUSED, char *argv[]GCC_UNUSED)\n{\n    char line[BUFSIZ], *st;\n\n#ifdef TRACE\n    _nc_tracing = TRACE_MOVE;\n#endif\n    for (;;) {\n\tint n;\n\n\tfor (n = 0; n < screen_lines(sp); n++)\n\t    oldnums[n] = _NEWINDEX;\n\n\t/* grab the test vector */\n\tif (fgets(line, sizeof(line), stdin) == (char *) NULL)\n\t    exit(EXIT_SUCCESS);\n\n\t/* parse it */\n\tn = 0;\n\tif (line[0] == '#') {\n\t    (void) fputs(line, stderr);\n\t    continue;\n\t}\n\tst = strtok(line, \" \");\n\tdo {\n\t    oldnums[n++] = atoi(st);\n\t} while\n\t    ((st = strtok((char *) NULL, \" \")) != 0);\n\n\t/* display it */\n\t(void) fputs(\"Initial input:\\n\", stderr);\n\t_nc_linedump();\n\n\t_nc_scroll_optimize();\n    }\n}\n\n#endif /* SCROLLDEBUG */\n\n/* hardscroll.c ends here */\n","/****************************************************************************\n * Copyright (c) 1998-2015,2016 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n ****************************************************************************/\n\n/******************************************************************************\n\nNAME\n   hashmap.c -- fill in scramble vector based on text hashes\n\nSYNOPSIS\n   void _nc_hash_map(void)\n\nDESCRIPTION:\n   This code attempts to recognize pairs of old and new lines in the physical\nand virtual screens.  When a line pair is recognized, the old line index is\nplaced in the oldindex member of the virtual screen line, to be used by the\nvertical-motion optimizer portion of the update logic (see hardscroll.c).\n\n   Line pairs are recognized by applying a modified Heckel's algorithm,\nsped up by hashing.  If a line hash is unique in both screens, those\nlines must be a pair. Then if the lines just before or after the pair\nare the same or similar, they are a pair too.\n\n   We don't worry about false pairs produced by hash collisions, on the\nassumption that such cases are rare and will only make the latter stages\nof update less efficient, not introduce errors.\n\nHOW TO TEST THIS:\n\nUse the following production:\n\nhashmap: hashmap.c\n\t$(CC) -g -DHASHDEBUG hashmap.c hardscroll.c ../objects/lib_trace.o -o hashmap\n\nAUTHOR\n    Eric S. Raymond <esr@snark.thyrsus.com>, May 1996\n    Bug fixes and improvements by Alexander V. Lukyanov <lav@yars.free.net>, 1997\n\n*****************************************************************************/\n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: hashmap.c,v 1.66 2016/05/28 23:32:40 tom Exp $\")\n\n#ifdef HASHDEBUG\n\n# define _tracef\tprintf\n# undef TR\n# ifdef TRACE\n# define TR(n, a)\tif (_nc_tracing & (n)) { _tracef a ; putchar('\\n'); }\n# else\n# define TR(n, a)\t{ _tracef a ; putchar('\\n'); }\n# endif\n# undef screen_lines\n# define screen_lines(sp) MAXLINES\n# define TEXTWIDTH(sp)\t1\nint oldnums[MAXLINES], reallines[MAXLINES];\nstatic NCURSES_CH_T oldtext[MAXLINES][TEXTWIDTH(sp)];\nstatic NCURSES_CH_T newtext[MAXLINES][TEXTWIDTH(sp)];\n# define OLDNUM(sp,n)\toldnums[n]\n# define OLDTEXT(sp,n)\toldtext[n]\n# define NEWTEXT(sp,m)\tnewtext[m]\n# define PENDING(sp,n)  1\n\n#else /* !HASHDEBUG */\n\n# define OLDNUM(sp,n)\t(sp)->_oldnum_list[n]\n# define OLDTEXT(sp,n)\tCurScreen(sp)->_line[n].text\n# define NEWTEXT(sp,m)\tNewScreen(sp)->_line[m].text\n# define TEXTWIDTH(sp)\t(CurScreen(sp)->_maxx + 1)\n# define PENDING(sp,n)  (NewScreen(sp)->_line[n].firstchar != _NOCHANGE)\n\n#endif /* !HASHDEBUG */\n\n#define oldhash(sp)\t((sp)->oldhash)\n#define newhash(sp)\t((sp)->newhash)\n#define hashtab(sp)\t((sp)->hashtab)\n#define lines_alloc(sp)\t((sp)->hashtab_len)\n\n#if USE_WIDEC_SUPPORT\n#define HASH_VAL(ch) (ch.chars[0])\n#else\n#define HASH_VAL(ch) (ch)\n#endif\n\nstatic const NCURSES_CH_T blankchar = NewChar(BLANK_TEXT);\n\nstatic NCURSES_INLINE unsigned long\nhash(SCREEN *sp, NCURSES_CH_T * text)\n{\n    int i;\n    NCURSES_CH_T ch;\n    unsigned long result = 0;\n    (void) sp;\n\n    for (i = TEXTWIDTH(sp); i > 0; i--) {\n\tch = *text++;\n\tresult += (result << 5) + (unsigned long) HASH_VAL(ch);\n    }\n    return result;\n}\n\n/* approximate update cost */\nstatic int\nupdate_cost(SCREEN *sp, NCURSES_CH_T * from, NCURSES_CH_T * to)\n{\n    int cost = 0;\n    int i;\n    (void) sp;\n\n    for (i = TEXTWIDTH(sp); i > 0; i--, from++, to++)\n\tif (!(CharEq(*from, *to)))\n\t    cost++;\n\n    return cost;\n}\n\nstatic int\nupdate_cost_from_blank(SCREEN *sp, NCURSES_CH_T * to)\n{\n    int cost = 0;\n    int i;\n    NCURSES_CH_T blank = blankchar;\n    (void) sp;\n\n    if (back_color_erase)\n\tSetPair(blank, GetPair(stdscr->_nc_bkgd));\n\n    for (i = TEXTWIDTH(sp); i > 0; i--, to++)\n\tif (!(CharEq(blank, *to)))\n\t    cost++;\n\n    return cost;\n}\n\n/*\n * Returns true when moving line 'from' to line 'to' seems to be cost\n * effective. 'blank' indicates whether the line 'to' would become blank.\n */\nstatic NCURSES_INLINE bool\ncost_effective(SCREEN *sp, const int from, const int to, const int blank)\n{\n    int new_from;\n\n    if (from == to)\n\treturn FALSE;\n\n    new_from = OLDNUM(sp, from);\n    if (new_from == _NEWINDEX)\n\tnew_from = from;\n\n    /*\n     * On the left side of >= is the cost before moving;\n     * on the right side -- cost after moving.\n     */\n    return (((blank ? update_cost_from_blank(sp, NEWTEXT(sp, to))\n\t      : update_cost(sp, OLDTEXT(sp, to), NEWTEXT(sp, to)))\n\t     + update_cost(sp, OLDTEXT(sp, new_from), NEWTEXT(sp, from)))\n\t    >= ((new_from == from ? update_cost_from_blank(sp, NEWTEXT(sp, from))\n\t\t : update_cost(sp, OLDTEXT(sp, new_from), NEWTEXT(sp, from)))\n\t\t+ update_cost(sp, OLDTEXT(sp, from), NEWTEXT(sp, to))))\n\t? TRUE : FALSE;\n}\n\nstatic void\ngrow_hunks(SCREEN *sp)\n{\n    int back_limit;\t\t/* limits for cells to fill */\n    int back_ref_limit;\t\t/* limit for references */\n    int i;\n    int next_hunk;\n\n    /*\n     * This is tricky part.  We have unique pairs to use as anchors.\n     * Use these to deduce the presence of spans of identical lines.\n     */\n    back_limit = 0;\n    back_ref_limit = 0;\n\n    i = 0;\n    while (i < screen_lines(sp) && OLDNUM(sp, i) == _NEWINDEX)\n\ti++;\n    for (; i < screen_lines(sp); i = next_hunk) {\n\tint forward_limit;\n\tint forward_ref_limit;\n\tint end;\n\tint start = i;\n\tint shift = OLDNUM(sp, i) - i;\n\n\t/* get forward limit */\n\ti = start + 1;\n\twhile (i < screen_lines(sp)\n\t       && OLDNUM(sp, i) != _NEWINDEX\n\t       && OLDNUM(sp, i) - i == shift)\n\t    i++;\n\tend = i;\n\twhile (i < screen_lines(sp) && OLDNUM(sp, i) == _NEWINDEX)\n\t    i++;\n\tnext_hunk = i;\n\tforward_limit = i;\n\tif (i >= screen_lines(sp) || OLDNUM(sp, i) >= i)\n\t    forward_ref_limit = i;\n\telse\n\t    forward_ref_limit = OLDNUM(sp, i);\n\n\ti = start - 1;\n\t/* grow back */\n\tif (shift < 0)\n\t    back_limit = back_ref_limit + (-shift);\n\twhile (i >= back_limit) {\n\t    if (newhash(sp)[i] == oldhash(sp)[i + shift]\n\t\t|| cost_effective(sp, i + shift, i, shift < 0)) {\n\t\tOLDNUM(sp, i) = i + shift;\n\t\tTR(TRACE_UPDATE | TRACE_MOVE,\n\t\t   (\"connected new line %d to old line %d (backward continuation)\",\n\t\t    i, i + shift));\n\t    } else {\n\t\tTR(TRACE_UPDATE | TRACE_MOVE,\n\t\t   (\"not connecting new line %d to old line %d (backward continuation)\",\n\t\t    i, i + shift));\n\t\tbreak;\n\t    }\n\t    i--;\n\t}\n\n\ti = end;\n\t/* grow forward */\n\tif (shift > 0)\n\t    forward_limit = forward_ref_limit - shift;\n\twhile (i < forward_limit) {\n\t    if (newhash(sp)[i] == oldhash(sp)[i + shift]\n\t\t|| cost_effective(sp, i + shift, i, shift > 0)) {\n\t\tOLDNUM(sp, i) = i + shift;\n\t\tTR(TRACE_UPDATE | TRACE_MOVE,\n\t\t   (\"connected new line %d to old line %d (forward continuation)\",\n\t\t    i, i + shift));\n\t    } else {\n\t\tTR(TRACE_UPDATE | TRACE_MOVE,\n\t\t   (\"not connecting new line %d to old line %d (forward continuation)\",\n\t\t    i, i + shift));\n\t\tbreak;\n\t    }\n\t    i++;\n\t}\n\n\tback_ref_limit = back_limit = i;\n\tif (shift > 0)\n\t    back_ref_limit += shift;\n    }\n}\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_hash_map) (NCURSES_SP_DCL0)\n{\n    HASHMAP *hsp;\n    register int i;\n\n    if (screen_lines(SP_PARM) > lines_alloc(SP_PARM)) {\n\tif (hashtab(SP_PARM))\n\t    free(hashtab(SP_PARM));\n\thashtab(SP_PARM) = typeMalloc(HASHMAP,\n\t\t\t\t      ((size_t) screen_lines(SP_PARM) + 1) * 2);\n\tif (!hashtab(SP_PARM)) {\n\t    if (oldhash(SP_PARM)) {\n\t\tFreeAndNull(oldhash(SP_PARM));\n\t    }\n\t    lines_alloc(SP_PARM) = 0;\n\t    return;\n\t}\n\tlines_alloc(SP_PARM) = screen_lines(SP_PARM);\n    }\n\n    if (oldhash(SP_PARM) && newhash(SP_PARM)) {\n\t/* re-hash only changed lines */\n\tfor (i = 0; i < screen_lines(SP_PARM); i++) {\n\t    if (PENDING(SP_PARM, i))\n\t\tnewhash(SP_PARM)[i] = hash(SP_PARM, NEWTEXT(SP_PARM, i));\n\t}\n    } else {\n\t/* re-hash all */\n\tif (oldhash(SP_PARM) == 0)\n\t    oldhash(SP_PARM) = typeCalloc(unsigned long,\n\t\t\t\t\t    (size_t) screen_lines(SP_PARM));\n\tif (newhash(SP_PARM) == 0)\n\t    newhash(SP_PARM) = typeCalloc(unsigned long,\n\t\t\t\t\t    (size_t) screen_lines(SP_PARM));\n\tif (!oldhash(SP_PARM) || !newhash(SP_PARM))\n\t    return;\t\t/* malloc failure */\n\tfor (i = 0; i < screen_lines(SP_PARM); i++) {\n\t    newhash(SP_PARM)[i] = hash(SP_PARM, NEWTEXT(SP_PARM, i));\n\t    oldhash(SP_PARM)[i] = hash(SP_PARM, OLDTEXT(SP_PARM, i));\n\t}\n    }\n\n#ifdef HASH_VERIFY\n    for (i = 0; i < screen_lines(SP_PARM); i++) {\n\tif (newhash(SP_PARM)[i] != hash(SP_PARM, NEWTEXT(SP_PARM, i)))\n\t    fprintf(stderr, \"error in newhash[%d]\\n\", i);\n\tif (oldhash(SP_PARM)[i] != hash(SP_PARM, OLDTEXT(SP_PARM, i)))\n\t    fprintf(stderr, \"error in oldhash[%d]\\n\", i);\n    }\n#endif\n\n    /*\n     * Set up and count line-hash values.\n     */\n    memset(hashtab(SP_PARM), '\\0',\n\t   sizeof(*(hashtab(SP_PARM)))\n\t   * ((size_t) screen_lines(SP_PARM) + 1) * 2);\n    for (i = 0; i < screen_lines(SP_PARM); i++) {\n\tunsigned long hashval = oldhash(SP_PARM)[i];\n\n\tfor (hsp = hashtab(SP_PARM); hsp->hashval; hsp++)\n\t    if (hsp->hashval == hashval)\n\t\tbreak;\n\thsp->hashval = hashval;\t/* in case this is a new entry */\n\thsp->oldcount++;\n\thsp->oldindex = i;\n    }\n    for (i = 0; i < screen_lines(SP_PARM); i++) {\n\tunsigned long hashval = newhash(SP_PARM)[i];\n\n\tfor (hsp = hashtab(SP_PARM); hsp->hashval; hsp++)\n\t    if (hsp->hashval == hashval)\n\t\tbreak;\n\thsp->hashval = hashval;\t/* in case this is a new entry */\n\thsp->newcount++;\n\thsp->newindex = i;\n\n\tOLDNUM(SP_PARM, i) = _NEWINDEX;\t\t/* initialize old indices array */\n    }\n\n    /*\n     * Mark line pairs corresponding to unique hash pairs.\n     *\n     * We don't mark lines with offset 0, because it can make fail\n     * extending hunks by cost_effective. Otherwise, it does not\n     * have any side effects.\n     */\n    for (hsp = hashtab(SP_PARM); hsp->hashval; hsp++)\n\tif (hsp->oldcount == 1 && hsp->newcount == 1\n\t    && hsp->oldindex != hsp->newindex) {\n\t    TR(TRACE_UPDATE | TRACE_MOVE,\n\t       (\"new line %d is hash-identical to old line %d (unique)\",\n\t\thsp->newindex, hsp->oldindex));\n\t    OLDNUM(SP_PARM, hsp->newindex) = hsp->oldindex;\n\t}\n\n    grow_hunks(SP_PARM);\n\n    /*\n     * Eliminate bad or impossible shifts -- this includes removing\n     * those hunks which could not grow because of conflicts, as well\n     * those which are to be moved too far, they are likely to destroy\n     * more than carry.\n     */\n    for (i = 0; i < screen_lines(SP_PARM);) {\n\tint start, shift, size;\n\n\twhile (i < screen_lines(SP_PARM) && OLDNUM(SP_PARM, i) == _NEWINDEX)\n\t    i++;\n\tif (i >= screen_lines(SP_PARM))\n\t    break;\n\tstart = i;\n\tshift = OLDNUM(SP_PARM, i) - i;\n\ti++;\n\twhile (i < screen_lines(SP_PARM)\n\t       && OLDNUM(SP_PARM, i) != _NEWINDEX\n\t       && OLDNUM(SP_PARM, i) - i == shift)\n\t    i++;\n\tsize = i - start;\n\tif (size < 3 || size + min(size / 8, 2) < abs(shift)) {\n\t    while (start < i) {\n\t\tOLDNUM(SP_PARM, start) = _NEWINDEX;\n\t\tstart++;\n\t    }\n\t}\n    }\n\n    /* After clearing invalid hunks, try grow the rest. */\n    grow_hunks(SP_PARM);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_hash_map(void)\n{\n    NCURSES_SP_NAME(_nc_hash_map) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_make_oldhash) (NCURSES_SP_DCLx int i)\n{\n    if (oldhash(SP_PARM))\n\toldhash(SP_PARM)[i] = hash(SP_PARM, OLDTEXT(SP_PARM, i));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_make_oldhash(int i)\n{\n    NCURSES_SP_NAME(_nc_make_oldhash) (CURRENT_SCREEN, i);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_scroll_oldhash) (NCURSES_SP_DCLx int n, int top, int bot)\n{\n    size_t size;\n    int i;\n\n    if (!oldhash(SP_PARM))\n\treturn;\n\n    size = sizeof(*(oldhash(SP_PARM))) * (size_t) (bot - top + 1 - abs(n));\n    if (n > 0) {\n\tmemmove(oldhash(SP_PARM) + top, oldhash(SP_PARM) + top + n, size);\n\tfor (i = bot; i > bot - n; i--)\n\t    oldhash(SP_PARM)[i] = hash(SP_PARM, OLDTEXT(SP_PARM, i));\n    } else {\n\tmemmove(oldhash(SP_PARM) + top - n, oldhash(SP_PARM) + top, size);\n\tfor (i = top; i < top - n; i++)\n\t    oldhash(SP_PARM)[i] = hash(SP_PARM, OLDTEXT(SP_PARM, i));\n    }\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_scroll_oldhash(int n, int top, int bot)\n{\n    NCURSES_SP_NAME(_nc_scroll_oldhash) (CURRENT_SCREEN, n, top, bot);\n}\n#endif\n\n#ifdef HASHDEBUG\nstatic void\nusage(void)\n{\n    static const char *table[] =\n    {\n\t\"hashmap test-driver\",\n\t\"\",\n\t\"#  comment\",\n\t\"l  get initial line number vector\",\n\t\"n  use following letters as text of new lines\",\n\t\"o  use following letters as text of old lines\",\n\t\"d  dump state of test arrays\",\n\t\"h  apply hash mapper and see scroll optimization\",\n\t\"?  this message\"\n    };\n    size_t n;\n    for (n = 0; n < sizeof(table) / sizeof(table[0]); n++)\n\tfprintf(stderr, \"%s\\n\", table[n]);\n}\n\nint\nmain(int argc GCC_UNUSED, char *argv[]GCC_UNUSED)\n{\n    char line[BUFSIZ], *st;\n    int n;\n\n    if (setupterm(NULL, fileno(stdout), (int *) 0) == ERR)\n\treturn EXIT_FAILURE;\n    (void) _nc_alloc_screen();\n\n    for (n = 0; n < screen_lines(sp); n++) {\n\treallines[n] = n;\n\toldnums[n] = _NEWINDEX;\n\tCharOf(oldtext[n][0]) = CharOf(newtext[n][0]) = '.';\n    }\n\n    if (NC_ISATTY(fileno(stdin)))\n\tusage();\n\n#ifdef TRACE\n    _nc_tracing = TRACE_MOVE;\n#endif\n    for (;;) {\n\t/* grab a test command */\n\tif (fgets(line, sizeof(line), stdin) == (char *) NULL)\n\t    break;\n\n\tswitch (line[0]) {\n\tcase '#':\t\t/* comment */\n\t    (void) fputs(line, stderr);\n\t    break;\n\n\tcase 'l':\t\t/* get initial line number vector */\n\t    for (n = 0; n < screen_lines(sp); n++) {\n\t\treallines[n] = n;\n\t\toldnums[n] = _NEWINDEX;\n\t    }\n\t    n = 0;\n\t    st = strtok(line, \" \");\n\t    do {\n\t\toldnums[n++] = atoi(st);\n\t    } while\n\t\t((st = strtok((char *) NULL, \" \")) != 0);\n\t    break;\n\n\tcase 'n':\t\t/* use following letters as text of new lines */\n\t    for (n = 0; n < screen_lines(sp); n++)\n\t\tCharOf(newtext[n][0]) = '.';\n\t    for (n = 0; n < screen_lines(sp); n++)\n\t\tif (line[n + 1] == '\\n')\n\t\t    break;\n\t\telse\n\t\t    CharOf(newtext[n][0]) = line[n + 1];\n\t    break;\n\n\tcase 'o':\t\t/* use following letters as text of old lines */\n\t    for (n = 0; n < screen_lines(sp); n++)\n\t\tCharOf(oldtext[n][0]) = '.';\n\t    for (n = 0; n < screen_lines(sp); n++)\n\t\tif (line[n + 1] == '\\n')\n\t\t    break;\n\t\telse\n\t\t    CharOf(oldtext[n][0]) = line[n + 1];\n\t    break;\n\n\tcase 'd':\t\t/* dump state of test arrays */\n#ifdef TRACE\n\t    _nc_linedump();\n#endif\n\t    (void) fputs(\"Old lines: [\", stdout);\n\t    for (n = 0; n < screen_lines(sp); n++)\n\t\tputchar(CharOf(oldtext[n][0]));\n\t    putchar(']');\n\t    putchar('\\n');\n\t    (void) fputs(\"New lines: [\", stdout);\n\t    for (n = 0; n < screen_lines(sp); n++)\n\t\tputchar(CharOf(newtext[n][0]));\n\t    putchar(']');\n\t    putchar('\\n');\n\t    break;\n\n\tcase 'h':\t\t/* apply hash mapper and see scroll optimization */\n\t    _nc_hash_map();\n\t    (void) fputs(\"Result:\\n\", stderr);\n#ifdef TRACE\n\t    _nc_linedump();\n#endif\n\t    _nc_scroll_optimize();\n\t    (void) fputs(\"Done.\\n\", stderr);\n\t    break;\n\tdefault:\n\tcase '?':\n\t    usage();\n\t    break;\n\t}\n    }\n#if NO_LEAKS\n    _nc_free_and_exit(EXIT_SUCCESS);\n#else\n    return EXIT_SUCCESS;\n#endif\n}\n\n#endif /* HASHDEBUG */\n\n/* hashmap.c ends here */\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *                                                                          *\n *  Rewritten 2001-2004 to support wide-characters by                       *\n *\tSven Verdoolaege                                                    *\n *\tThomas Dickey                                                       *\n ****************************************************************************/\n\n/*\n**\tlib_addstr.c\n*\n**\tThe routines waddnstr(), waddchnstr().\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_addstr.c,v 1.54 2017/03/25 21:10:03 tom Exp $\")\n\nNCURSES_EXPORT(int)\nwaddnstr(WINDOW *win, const char *astr, int n)\n{\n    const char *str = astr;\n    int code = ERR;\n\n    T((T_CALLED(\"waddnstr(%p,%s,%d)\"), (void *) win, _nc_visbufn(astr, n), n));\n\n    if (win && (str != 0)) {\n\tTR(TRACE_VIRTPUT | TRACE_ATTRS,\n\t   (\"... current %s\", _traceattr(WINDOW_ATTRS(win))));\n\tcode = OK;\n\tif (n < 0)\n\t    n = (int) strlen(astr);\n\n\tTR(TRACE_VIRTPUT, (\"str is not null, length = %d\", n));\n\twhile ((n-- > 0) && (*str != '\\0')) {\n\t    NCURSES_CH_T ch;\n\t    TR(TRACE_VIRTPUT, (\"*str = %#o\", UChar(*str)));\n\t    SetChar(ch, UChar(*str++), A_NORMAL);\n\t    if (_nc_waddch_nosync(win, ch) == ERR) {\n\t\tcode = ERR;\n\t\tbreak;\n\t    }\n\t}\n\t_nc_synchook(win);\n    }\n    TR(TRACE_VIRTPUT, (\"waddnstr returns %d\", code));\n    returnCode(code);\n}\n\nNCURSES_EXPORT(int)\nwaddchnstr(WINDOW *win, const chtype *astr, int n)\n{\n    NCURSES_SIZE_T y, x;\n    int code = OK;\n    int i;\n    struct ldat *line;\n\n    T((T_CALLED(\"waddchnstr(%p,%p,%d)\"), (void *) win, (const void *) astr, n));\n\n    if (!win || !astr)\n\treturnCode(ERR);\n\n    y = win->_cury;\n    x = win->_curx;\n    if (n < 0) {\n\tconst chtype *str;\n\tn = 0;\n\tfor (str = (const chtype *) astr; *str != 0; str++)\n\t    n++;\n    }\n    if (n > win->_maxx - x + 1)\n\tn = win->_maxx - x + 1;\n    if (n == 0)\n\treturnCode(code);\n\n    line = &(win->_line[y]);\n    for (i = 0; i < n && ChCharOf(astr[i]) != '\\0'; ++i) {\n\tSetChar2(line->text[i + x], astr[i]);\n    }\n    CHANGED_RANGE(line, x, (NCURSES_SIZE_T) (x + n - 1));\n\n    _nc_synchook(win);\n    returnCode(code);\n}\n\n#if USE_WIDEC_SUPPORT\n\nNCURSES_EXPORT(int)\n_nc_wchstrlen(const cchar_t *s)\n{\n    int result = 0;\n    if (s != 0) {\n\twhile (CharOf(s[result]) != L'\\0') {\n\t    result++;\n\t}\n    }\n    return result;\n}\n\nNCURSES_EXPORT(int)\nwadd_wchnstr(WINDOW *win, const cchar_t *astr, int n)\n{\n    static const NCURSES_CH_T blank = NewChar(BLANK_TEXT);\n    NCURSES_SIZE_T y;\n    NCURSES_SIZE_T x;\n    int code = OK;\n    struct ldat *line;\n    int i, j, start, len, end;\n\n    T((T_CALLED(\"wadd_wchnstr(%p,%s,%d)\"),\n       (void *) win,\n       _nc_viscbuf(astr, n),\n       n));\n\n    if (!win)\n\treturnCode(ERR);\n\n    y = win->_cury;\n    x = win->_curx;\n    if (n < 0) {\n\tn = _nc_wchstrlen(astr);\n    }\n    if (n > win->_maxx - x + 1)\n\tn = win->_maxx - x + 1;\n    if (n == 0)\n\treturnCode(code);\n\n    line = &(win->_line[y]);\n    start = x;\n    end = x + n - 1;\n\n    /*\n     * Reset orphaned cells of multi-column characters that extend up to the\n     * new string's location to blanks.\n     */\n    if (x > 0 && isWidecExt(line->text[x])) {\n\tfor (i = 0; i <= x; ++i) {\n\t    if (!isWidecExt(line->text[x - i])) {\n\t\t/* must be isWidecBase() */\n\t\tstart -= i;\n\t\twhile (i > 0) {\n\t\t    line->text[x - i--] = _nc_render(win, blank);\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    /*\n     * Copy the new string to the window.\n     */\n    for (i = 0; i < n && CharOf(astr[i]) != L'\\0' && x <= win->_maxx; ++i) {\n\tif (isWidecExt(astr[i]))\n\t    continue;\n\n\tlen = wcwidth(CharOf(astr[i]));\n\n\tif (x + len - 1 <= win->_maxx) {\n\t    line->text[x] = _nc_render(win, astr[i]);\n\t    if (len > 1) {\n\t\tfor (j = 0; j < len; ++j) {\n\t\t    if (j != 0) {\n\t\t\tline->text[x + j] = line->text[x];\n\t\t    }\n\t\t    SetWidecExt(line->text[x + j], j);\n\t\t}\n\t    } else {\n\t\tlen = 1;\n\t    }\n\t    x = (NCURSES_SIZE_T) (x + len);\n\t    end += len - 1;\n\t} else {\n\t    break;\n\t}\n    }\n\n    /*\n     * Set orphaned cells of multi-column characters which lie after the new\n     * string to blanks.\n     */\n    while (x <= win->_maxx && isWidecExt(line->text[x])) {\n\tline->text[x] = _nc_render(win, blank);\n\t++end;\n\t++x;\n    }\n    CHANGED_RANGE(line, start, end);\n\n    _nc_synchook(win);\n    returnCode(code);\n}\n\nNCURSES_EXPORT(int)\nwaddnwstr(WINDOW *win, const wchar_t *str, int n)\n{\n    int code = ERR;\n\n    T((T_CALLED(\"waddnwstr(%p,%s,%d)\"), (void *) win, _nc_viswbufn(str, n), n));\n\n    if (win && (str != 0)) {\n\tTR(TRACE_VIRTPUT | TRACE_ATTRS,\n\t   (\"... current %s\", _traceattr(WINDOW_ATTRS(win))));\n\tcode = OK;\n\tif (n < 0)\n\t    n = (int) wcslen(str);\n\n\tTR(TRACE_VIRTPUT, (\"str is not null, length = %d\", n));\n\twhile ((n-- > 0) && (*str != L('\\0'))) {\n\t    NCURSES_CH_T ch;\n\t    TR(TRACE_VIRTPUT, (\"*str[0] = %#lx\", (unsigned long) *str));\n\t    SetChar(ch, *str++, A_NORMAL);\n\t    if (wadd_wch(win, &ch) == ERR) {\n\t\tcode = ERR;\n\t\tbreak;\n\t    }\n\t}\n\t_nc_synchook(win);\n    }\n    TR(TRACE_VIRTPUT, (\"waddnwstr returns %d\", code));\n    returnCode(code);\n}\n\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2013,2014 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n *\tbeep.c\n *\n *\tThe routine beep().\n *\n */\n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_beep.c,v 1.17 2014/03/08 20:32:59 tom Exp $\")\n\n/*\n *\tbeep()\n *\n *\tSound the current terminal's audible bell if it has one.   If not,\n *\tflash the screen if possible.\n *\n */\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(beep) (NCURSES_SP_DCL0)\n{\n    int res = ERR;\n\n    T((T_CALLED(\"beep(%p)\"), (void *) SP_PARM));\n\n#ifdef USE_TERM_DRIVER\n    if (SP_PARM != 0)\n\tres = CallDriver_1(SP_PARM, td_doBeepOrFlash, TRUE);\n#else\n    /* FIXME: should make sure that we are not in altchar mode */\n    if (cur_term == 0) {\n\tres = ERR;\n    } else if (bell) {\n\tres = NCURSES_PUTP2_FLUSH(\"bell\", bell);\n    } else if (flash_screen) {\n\tres = NCURSES_PUTP2_FLUSH(\"flash_screen\", flash_screen);\n\t_nc_flush();\n    }\n#endif\n\n    returnCode(res);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nbeep(void)\n{\n    return NCURSES_SP_NAME(beep) (CURRENT_SCREEN);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2000,2009 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n ****************************************************************************/\n\n/*\n**\tlib_clearok.c\n**\n**\tThe routine clearok.\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_clearok.c,v 1.5 2009/10/24 22:34:53 tom Exp $\")\n\nNCURSES_EXPORT(int)\nclearok(WINDOW *win, bool flag)\n{\n    T((T_CALLED(\"clearok(%p,%d)\"), (void *) win, flag));\n\n    if (win) {\n\twin->_clear = flag;\n\treturnCode(OK);\n    } else\n\treturnCode(ERR);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Sven Verdoolaege                        2001                    *\n ****************************************************************************/\n\n/*\n**\tlib_hline.c\n**\n**\tThe routine whline().\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_hline.c,v 1.15 2017/10/28 19:57:42 tom Exp $\")\n\nNCURSES_EXPORT(int)\nwhline(WINDOW *win, chtype ch, int n)\n{\n    int code = ERR;\n\n    T((T_CALLED(\"whline(%p,%s,%d)\"), (void *) win, _tracechtype(ch), n));\n\n    if (win) {\n\tstruct ldat *line = &(win->_line[win->_cury]);\n\tNCURSES_CH_T wch;\n\tint start = win->_curx;\n\tint end = start + n - 1;\n\n\tif (end > win->_maxx)\n\t    end = win->_maxx;\n\n\tCHANGED_RANGE(line, start, end);\n\n\tif (ch == 0)\n\t    SetChar2(wch, ACS_HLINE);\n\telse\n\t    SetChar2(wch, ch);\n\twch = _nc_render(win, wch);\n\n#if USE_WIDEC_SUPPORT\n\tif (start > 0 && isWidecExt(line->text[start])) {\n\t    SetChar2(line->text[start - 1], ' ');\n\t}\n\tif (end < win->_maxx && isWidecExt(line->text[end + 1])) {\n\t    SetChar2(line->text[end + 1], ' ');\n\t}\n#endif\n\twhile (end >= start) {\n\t    line->text[end] = wch;\n\t    end--;\n\t}\n\n\t_nc_synchook(win);\n\tcode = OK;\n    }\n    returnCode(code);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n/*\n**\tlib_newwin.c\n**\n**\tThe routines newwin(), subwin() and their dependent\n**\n*/\n\n#include <curses.priv.h>\n#include <stddef.h>\n\nMODULE_ID(\"$Id: lib_newwin.c,v 1.74 2017/05/13 23:17:29 tom Exp $\")\n\n#define window_is(name) ((sp)->_##name == win)\n\n#if USE_REENTRANT\n#define remove_window(name) \\\n\t\tsp->_##name = 0\n#else\n#define remove_window(name) \\\n\t\tsp->_##name = 0; \\\n\t\tif (win == name) \\\n\t\t    name = 0\n#endif\n\nstatic void\nremove_window_from_screen(WINDOW *win)\n{\n    SCREEN *sp;\n\n#ifdef USE_SP_WINDOWLIST\n    if ((sp = _nc_screen_of(win)) != 0) {\n\tif (window_is(curscr)) {\n\t    remove_window(curscr);\n\t} else if (window_is(stdscr)) {\n\t    remove_window(stdscr);\n\t} else if (window_is(newscr)) {\n\t    remove_window(newscr);\n\t}\n    }\n#else\n    for (each_screen(sp)) {\n\tif (window_is(curscr)) {\n\t    remove_window(curscr);\n\t    break;\n\t} else if (window_is(stdscr)) {\n\t    remove_window(stdscr);\n\t    break;\n\t} else if (window_is(newscr)) {\n\t    remove_window(newscr);\n\t    break;\n\t}\n    }\n#endif\n}\n\nNCURSES_EXPORT(int)\n_nc_freewin(WINDOW *win)\n{\n    int result = ERR;\n#ifdef USE_SP_WINDOWLIST\n    SCREEN *sp = _nc_screen_of(win);\t/* pretend this is parameter */\n#endif\n\n    T((T_CALLED(\"_nc_freewin(%p)\"), (void *) win));\n\n    if (win != 0) {\n\n\tif (_nc_nonsp_try_global(curses) == 0) {\n\t    WINDOWLIST *p, *q;\n\n\t    q = 0;\n\t    for (each_window(sp, p)) {\n\n\t\tif (&(p->win) == win) {\n\t\t    remove_window_from_screen(win);\n\t\t    if (q == 0)\n\t\t\tWindowList(sp) = p->next;\n\t\t    else\n\t\t\tq->next = p->next;\n\n\t\t    if (!(win->_flags & _SUBWIN)) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i <= win->_maxy; i++)\n\t\t\t    FreeIfNeeded(win->_line[i].text);\n\t\t    }\n\t\t    free(win->_line);\n\t\t    free(p);\n\n\t\t    result = OK;\n\t\t    T((\"...deleted win=%p\", (void *) win));\n\t\t    break;\n\t\t}\n\t\tq = p;\n\t    }\n\t    _nc_nonsp_unlock_global(curses);\n\t}\n    }\n    returnCode(result);\n}\n\nNCURSES_EXPORT(WINDOW *)\nNCURSES_SP_NAME(newwin) (NCURSES_SP_DCLx\n\t\t\t int num_lines, int num_columns, int begy, int begx)\n{\n    WINDOW *win;\n    NCURSES_CH_T *ptr;\n    int i;\n\n    T((T_CALLED(\"newwin(%p, %d,%d,%d,%d)\"), (void *) SP_PARM, num_lines, num_columns,\n       begy, begx));\n\n    if (begy < 0\n\t|| begx < 0\n\t|| num_lines < 0\n\t|| num_columns < 0\n\t|| SP_PARM == 0)\n\treturnWin(0);\n\n    if (num_lines == 0)\n\tnum_lines = SP_PARM->_lines_avail - begy;\n    if (num_columns == 0)\n\tnum_columns = screen_columns(SP_PARM) - begx;\n\n    win = NCURSES_SP_NAME(_nc_makenew) (NCURSES_SP_ARGx\n\t\t\t\t\tnum_lines, num_columns, begy, begx, 0);\n    if (win == 0)\n\treturnWin(0);\n\n    for (i = 0; i < num_lines; i++) {\n\twin->_line[i].text = typeCalloc(NCURSES_CH_T, (unsigned) num_columns);\n\tif (win->_line[i].text == 0) {\n\t    (void) _nc_freewin(win);\n\t    returnWin(0);\n\t}\n\tfor (ptr = win->_line[i].text;\n\t     ptr < win->_line[i].text + num_columns;\n\t     ptr++)\n\t    SetChar(*ptr, BLANK_TEXT, BLANK_ATTR);\n    }\n\n    returnWin(win);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(WINDOW *)\nnewwin(int num_lines, int num_columns, int begy, int begx)\n{\n    WINDOW *win;\n    _nc_sp_lock_global(curses);\n    win = NCURSES_SP_NAME(newwin) (CURRENT_SCREEN,\n\t\t\t\t   num_lines, num_columns, begy, begx);\n    _nc_sp_unlock_global(curses);\n    return (win);\n}\n#endif\n\nNCURSES_EXPORT(WINDOW *)\nderwin(WINDOW *orig, int num_lines, int num_columns, int begy, int begx)\n{\n    WINDOW *win;\n    int i;\n    int flags = _SUBWIN;\n#if NCURSES_SP_FUNCS\n    SCREEN *sp = _nc_screen_of(orig);\n#endif\n\n    T((T_CALLED(\"derwin(%p,%d,%d,%d,%d)\"), (void *) orig, num_lines, num_columns,\n       begy, begx));\n\n    /*\n     * make sure window fits inside the original one\n     */\n    if (begy < 0 || begx < 0 || orig == 0 || num_lines < 0 || num_columns < 0)\n\treturnWin(0);\n    if (begy + num_lines > orig->_maxy + 1\n\t|| begx + num_columns > orig->_maxx + 1)\n\treturnWin(0);\n\n    if (num_lines == 0)\n\tnum_lines = orig->_maxy + 1 - begy;\n\n    if (num_columns == 0)\n\tnum_columns = orig->_maxx + 1 - begx;\n\n    if (orig->_flags & _ISPAD)\n\tflags |= _ISPAD;\n\n    win = NCURSES_SP_NAME(_nc_makenew) (NCURSES_SP_ARGx num_lines, num_columns,\n\t\t\t\t\torig->_begy + begy,\n\t\t\t\t\torig->_begx + begx, flags);\n    if (win == 0)\n\treturnWin(0);\n\n    win->_pary = begy;\n    win->_parx = begx;\n    WINDOW_ATTRS(win) = WINDOW_ATTRS(orig);\n    win->_nc_bkgd = orig->_nc_bkgd;\n\n    for (i = 0; i < num_lines; i++)\n\twin->_line[i].text = &orig->_line[begy++].text[begx];\n\n    win->_parent = orig;\n\n    returnWin(win);\n}\n\nNCURSES_EXPORT(WINDOW *)\nsubwin(WINDOW *w, int l, int c, int y, int x)\n{\n    WINDOW *result = 0;\n\n    T((T_CALLED(\"subwin(%p, %d, %d, %d, %d)\"), (void *) w, l, c, y, x));\n    if (w != 0) {\n\tT((\"parent has begy = %ld, begx = %ld\", (long) w->_begy, (long) w->_begx));\n\n\tresult = derwin(w, l, c, y - w->_begy, x - w->_begx);\n    }\n    returnWin(result);\n}\n\nstatic bool\ndimension_limit(int value)\n{\n    NCURSES_SIZE_T test = (NCURSES_SIZE_T) value;\n    return (test == value && value > 0);\n}\n\nNCURSES_EXPORT(WINDOW *)\nNCURSES_SP_NAME(_nc_makenew) (NCURSES_SP_DCLx\n\t\t\t      int num_lines,\n\t\t\t      int num_columns,\n\t\t\t      int begy,\n\t\t\t      int begx,\n\t\t\t      int flags)\n{\n    int i;\n    WINDOWLIST *wp;\n    WINDOW *win;\n    bool is_padwin = (flags & _ISPAD);\n\n    T((T_CALLED(\"_nc_makenew(%p,%d,%d,%d,%d)\"),\n       (void *) SP_PARM, num_lines, num_columns, begy, begx));\n\n    if (SP_PARM == 0)\n\treturnWin(0);\n\n    if (!dimension_limit(num_lines) || !dimension_limit(num_columns))\n\treturnWin(0);\n\n    if ((wp = typeCalloc(WINDOWLIST, 1)) == 0)\n\treturnWin(0);\n\n    win = &(wp->win);\n\n    if ((win->_line = typeCalloc(struct ldat, ((unsigned) num_lines))) == 0) {\n\tfree(wp);\n\treturnWin(0);\n    }\n\n    _nc_nonsp_lock_global(curses);\n\n    win->_curx = 0;\n    win->_cury = 0;\n    win->_maxy = (NCURSES_SIZE_T) (num_lines - 1);\n    win->_maxx = (NCURSES_SIZE_T) (num_columns - 1);\n    win->_begy = (NCURSES_SIZE_T) begy;\n    win->_begx = (NCURSES_SIZE_T) begx;\n    win->_yoffset = SP_PARM->_topstolen;\n\n    win->_flags = (short) flags;\n    WINDOW_ATTRS(win) = A_NORMAL;\n    SetChar(win->_nc_bkgd, BLANK_TEXT, BLANK_ATTR);\n\n    win->_clear = (is_padwin\n\t\t   ? FALSE\n\t\t   : (num_lines == screen_lines(SP_PARM)\n\t\t      && num_columns == screen_columns(SP_PARM)));\n    win->_idlok = FALSE;\n    win->_idcok = TRUE;\n    win->_scroll = FALSE;\n    win->_leaveok = FALSE;\n    win->_use_keypad = FALSE;\n    win->_delay = -1;\n    win->_immed = FALSE;\n    win->_sync = 0;\n    win->_parx = -1;\n    win->_pary = -1;\n    win->_parent = 0;\n\n    win->_regtop = 0;\n    win->_regbottom = (NCURSES_SIZE_T) (num_lines - 1);\n\n    win->_pad._pad_y = -1;\n    win->_pad._pad_x = -1;\n    win->_pad._pad_top = -1;\n    win->_pad._pad_bottom = -1;\n    win->_pad._pad_left = -1;\n    win->_pad._pad_right = -1;\n\n    for (i = 0; i < num_lines; i++) {\n\t/*\n\t * This used to do\n\t *\n\t * win->_line[i].firstchar = win->_line[i].lastchar = _NOCHANGE;\n\t *\n\t * which marks the whole window unchanged.  That's how\n\t * SVr1 curses did it, but SVr4 curses marks the whole new\n\t * window changed.\n\t *\n\t * With the old SVr1-like code, say you have stdscr full of\n\t * characters, then create a new window with newwin(),\n\t * then do a printw(win, \"foo        \");, the trailing spaces are\n\t * completely ignored by the following refreshes.  So, you\n\t * get \"foojunkjunk\" on the screen instead of \"foo        \" as\n\t * you actually intended.\n\t *\n\t * SVr4 doesn't do this.  Instead the spaces are actually written.\n\t * So that's how we want ncurses to behave.\n\t */\n\twin->_line[i].firstchar = 0;\n\twin->_line[i].lastchar = (NCURSES_SIZE_T) (num_columns - 1);\n\n\tif_USE_SCROLL_HINTS(win->_line[i].oldindex = i);\n    }\n\n    if (!is_padwin && (begx + num_columns == screen_columns(SP_PARM))) {\n\twin->_flags |= _ENDLINE;\n\n\tif (begx == 0 && num_lines == screen_lines(SP_PARM) && begy == 0)\n\t    win->_flags |= _FULLWIN;\n\n\tif (begy + num_lines == screen_lines(SP_PARM))\n\t    win->_flags |= _SCROLLWIN;\n    }\n\n    wp->next = WindowList(SP_PARM);\n    wp->screen = SP_PARM;\n    WindowList(SP_PARM) = wp;\n\n    T((T_CREATE(\"window %p\"), (void *) win));\n\n    _nc_nonsp_unlock_global(curses);\n    returnWin(win);\n}\n\n/*\n * wgetch() and other functions with a WINDOW* parameter may use a SCREEN*\n * internally, and it is useful to allow those to be invoked without switching\n * SCREEN's, e.g., for multi-threaded applications.\n */\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(WINDOW *)\n_nc_curscr_of(SCREEN *sp)\n{\n    return (sp == 0) ? NULL : CurScreen(sp);\n}\n\nNCURSES_EXPORT(WINDOW *)\n_nc_newscr_of(SCREEN *sp)\n{\n    return (sp == 0) ? NULL : NewScreen(sp);\n}\n\nNCURSES_EXPORT(WINDOW *)\n_nc_stdscr_of(SCREEN *sp)\n{\n    return (sp == 0) ? NULL : StdScreen(sp);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2012,2016 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey            1997-on                             *\n ****************************************************************************/\n\n/*\n**\tlib_printw.c\n**\n**\tThe routines printw(), wprintw() and friends.\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_printw.c,v 1.24 2016/05/28 23:11:26 tom Exp $\")\n\nNCURSES_EXPORT(int)\nprintw(const char *fmt,...)\n{\n    va_list argp;\n    int code;\n\n#ifdef TRACE\n    va_list argq;\n    va_start(argq, fmt);\n    T((T_CALLED(\"printw(%s%s)\"),\n       _nc_visbuf(fmt), _nc_varargs(fmt, argq)));\n    va_end(argq);\n#endif\n\n    va_start(argp, fmt);\n    code = vwprintw(stdscr, fmt, argp);\n    va_end(argp);\n\n    returnCode(code);\n}\n\nNCURSES_EXPORT(int)\nwprintw(WINDOW *win, const char *fmt,...)\n{\n    va_list argp;\n    int code;\n\n#ifdef TRACE\n    va_list argq;\n    va_start(argq, fmt);\n    T((T_CALLED(\"wprintw(%p,%s%s)\"),\n       (void *) win, _nc_visbuf(fmt), _nc_varargs(fmt, argq)));\n    va_end(argq);\n#endif\n\n    va_start(argp, fmt);\n    code = vwprintw(win, fmt, argp);\n    va_end(argp);\n\n    returnCode(code);\n}\n\nNCURSES_EXPORT(int)\nmvprintw(int y, int x, const char *fmt,...)\n{\n    int code;\n\n#ifdef TRACE\n    va_list argq;\n    va_start(argq, fmt);\n    T((T_CALLED(\"mvprintw(%d,%d,%s%s)\"),\n       y, x, _nc_visbuf(fmt), _nc_varargs(fmt, argq)));\n    va_end(argq);\n#endif\n\n    if ((code = move(y, x)) != ERR) {\n\tva_list argp;\n\n\tva_start(argp, fmt);\n\tcode = vwprintw(stdscr, fmt, argp);\n\tva_end(argp);\n    }\n    returnCode(code);\n}\n\nNCURSES_EXPORT(int)\nmvwprintw(WINDOW *win, int y, int x, const char *fmt,...)\n{\n    int code;\n\n#ifdef TRACE\n    va_list argq;\n    va_start(argq, fmt);\n    T((T_CALLED(\"mvwprintw(%d,%d,%p,%s%s)\"),\n       y, x, (void *) win, _nc_visbuf(fmt), _nc_varargs(fmt, argq)));\n    va_end(argq);\n#endif\n\n    if ((code = wmove(win, y, x)) != ERR) {\n\tva_list argp;\n\n\tva_start(argp, fmt);\n\tcode = vwprintw(win, fmt, argp);\n\tva_end(argp);\n    }\n    returnCode(code);\n}\n\nNCURSES_EXPORT(int)\nvwprintw(WINDOW *win, const char *fmt, va_list argp)\n{\n    char *buf;\n    int code = ERR;\n#if NCURSES_SP_FUNCS\n    SCREEN *sp = _nc_screen_of(win);\n#endif\n\n    T((T_CALLED(\"vwprintw(%p,%s,va_list)\"), (void *) win, _nc_visbuf(fmt)));\n\n    buf = NCURSES_SP_NAME(_nc_printf_string) (NCURSES_SP_ARGx fmt, argp);\n    if (buf != 0) {\n\tcode = waddstr(win, buf);\n    }\n    returnCode(code);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2007,2009 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Juergen Pfeifer                         1996-1999               *\n *     and: Thomas E. Dickey                        1996-on                 *\n ****************************************************************************/\n\n/*\n *\tlib_slkclear.c\n *\tSoft key routines.\n *      Remove soft labels from the screen.\n */\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_slkclear.c,v 1.14 2009/11/07 16:27:05 tom Exp $\")\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(slk_clear) (NCURSES_SP_DCL0)\n{\n    int rc = ERR;\n\n    T((T_CALLED(\"slk_clear(%p)\"), (void *) SP_PARM));\n\n    if (SP_PARM != 0 && SP_PARM->_slk != 0) {\n\tSP_PARM->_slk->hidden = TRUE;\n\t/* For simulated SLK's it looks much more natural to\n\t   inherit those attributes from the standard screen */\n\tSP_PARM->_slk->win->_nc_bkgd = StdScreen(SP_PARM)->_nc_bkgd;\n\tWINDOW_ATTRS(SP_PARM->_slk->win) = WINDOW_ATTRS(StdScreen(SP_PARM));\n\tif (SP_PARM->_slk->win == StdScreen(SP_PARM)) {\n\t    rc = OK;\n\t} else {\n\t    werase(SP_PARM->_slk->win);\n\t    rc = wrefresh(SP_PARM->_slk->win);\n\t}\n    }\n    returnCode(rc);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nslk_clear(void)\n{\n    return NCURSES_SP_NAME(slk_clear) (CURRENT_SCREEN);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2000,2009 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Juergen Pfeifer                         1997,2009               *\n *     and: Thomas E. Dickey                        1996-on                 *\n ****************************************************************************/\n\n/*\n *\tlib_slktouch.c\n *\tSoft key routines.\n *      Force the code to believe that the soft keys have been changed.\n */\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_slktouch.c,v 1.8 2009/10/24 22:12:21 tom Exp $\")\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(slk_touch) (NCURSES_SP_DCL0)\n{\n    T((T_CALLED(\"slk_touch(%p)\"), (void *) SP_PARM));\n\n    if (SP_PARM == 0 || SP_PARM->_slk == 0)\n\treturnCode(ERR);\n    SP_PARM->_slk->dirty = TRUE;\n\n    returnCode(OK);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nslk_touch(void)\n{\n    return NCURSES_SP_NAME(slk_touch) (CURRENT_SCREEN);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2012,2013 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey        1997-on                                 *\n ****************************************************************************/\n\n#include <curses.priv.h>\n#include <ctype.h>\n\nMODULE_ID(\"$Id: safe_sprintf.c,v 1.27 2013/01/20 01:04:32 tom Exp $\")\n\n#if USE_SAFE_SPRINTF\n\ntypedef enum {\n    Flags, Width, Prec, Type, Format\n} PRINTF;\n\n#define VA_INTGR(type) ival = va_arg(ap, type)\n#define VA_FLOAT(type) fval = va_arg(ap, type)\n#define VA_POINT(type) pval = (void *)va_arg(ap, type)\n\n/*\n * Scan a variable-argument list for printf to determine the number of\n * characters that would be emitted.\n */\nstatic int\n_nc_printf_length(const char *fmt, va_list ap)\n{\n    size_t length = BUFSIZ;\n    char *buffer;\n    char *format;\n    int len = 0;\n    size_t fmt_len;\n    char fmt_arg[BUFSIZ];\n\n    if (fmt == 0 || *fmt == '\\0')\n\treturn 0;\n    fmt_len = strlen(fmt) + 1;\n    if ((format = typeMalloc(char, fmt_len)) == 0)\n\t  return -1;\n    if ((buffer = typeMalloc(char, length)) == 0) {\n\tfree(format);\n\treturn -1;\n    }\n\n    while (*fmt != '\\0') {\n\tif (*fmt == '%') {\n\t    static char dummy[] = \"\";\n\t    PRINTF state = Flags;\n\t    char *pval = dummy;\t/* avoid const-cast */\n\t    double fval = 0.0;\n\t    int done = FALSE;\n\t    int ival = 0;\n\t    int prec = -1;\n\t    int type = 0;\n\t    int used = 0;\n\t    int width = -1;\n\t    size_t f = 0;\n\n\t    format[f++] = *fmt;\n\t    while (*++fmt != '\\0' && len >= 0 && !done) {\n\t\tformat[f++] = *fmt;\n\n\t\tif (isdigit(UChar(*fmt))) {\n\t\t    int num = *fmt - '0';\n\t\t    if (state == Flags && num != 0)\n\t\t\tstate = Width;\n\t\t    if (state == Width) {\n\t\t\tif (width < 0)\n\t\t\t    width = 0;\n\t\t\twidth = (width * 10) + num;\n\t\t    } else if (state == Prec) {\n\t\t\tif (prec < 0)\n\t\t\t    prec = 0;\n\t\t\tprec = (prec * 10) + num;\n\t\t    }\n\t\t} else if (*fmt == '*') {\n\t\t    VA_INTGR(int);\n\t\t    if (state == Flags)\n\t\t\tstate = Width;\n\t\t    if (state == Width) {\n\t\t\twidth = ival;\n\t\t    } else if (state == Prec) {\n\t\t\tprec = ival;\n\t\t    }\n\t\t    _nc_SPRINTF(fmt_arg,\n\t\t\t\t_nc_SLIMIT(sizeof(fmt_arg))\n\t\t\t\t\"%d\", ival);\n\t\t    fmt_len += strlen(fmt_arg);\n\t\t    if ((format = _nc_doalloc(format, fmt_len)) == 0) {\n\t\t\tfree(buffer);\n\t\t\treturn -1;\n\t\t    }\n\t\t    --f;\n\t\t    _nc_STRCPY(&format[f], fmt_arg, fmt_len - f);\n\t\t    f = strlen(format);\n\t\t} else if (isalpha(UChar(*fmt))) {\n\t\t    done = TRUE;\n\t\t    switch (*fmt) {\n\t\t    case 'Z':\t/* FALLTHRU */\n\t\t    case 'h':\t/* FALLTHRU */\n\t\t    case 'l':\t/* FALLTHRU */\n\t\t\tdone = FALSE;\n\t\t\ttype = *fmt;\n\t\t\tbreak;\n\t\t    case 'i':\t/* FALLTHRU */\n\t\t    case 'd':\t/* FALLTHRU */\n\t\t    case 'u':\t/* FALLTHRU */\n\t\t    case 'x':\t/* FALLTHRU */\n\t\t    case 'X':\t/* FALLTHRU */\n\t\t\tif (type == 'l')\n\t\t\t    VA_INTGR(long);\n\t\t\telse if (type == 'Z')\n\t\t\t    VA_INTGR(size_t);\n\t\t\telse\n\t\t\t    VA_INTGR(int);\n\t\t\tused = 'i';\n\t\t\tbreak;\n\t\t    case 'f':\t/* FALLTHRU */\n\t\t    case 'e':\t/* FALLTHRU */\n\t\t    case 'E':\t/* FALLTHRU */\n\t\t    case 'g':\t/* FALLTHRU */\n\t\t    case 'G':\t/* FALLTHRU */\n\t\t\tVA_FLOAT(double);\n\t\t\tused = 'f';\n\t\t\tbreak;\n\t\t    case 'c':\n\t\t\tVA_INTGR(int);\n\t\t\tused = 'i';\n\t\t\tbreak;\n\t\t    case 's':\n\t\t\tVA_POINT(char *);\n\t\t\tif (prec < 0)\n\t\t\t    prec = strlen(pval);\n\t\t\tif (prec > (int) length) {\n\t\t\t    length = length + prec;\n\t\t\t    buffer = typeRealloc(char, length, buffer);\n\t\t\t    if (buffer == 0) {\n\t\t\t\tfree(format);\n\t\t\t\treturn -1;\n\t\t\t    }\n\t\t\t}\n\t\t\tused = 'p';\n\t\t\tbreak;\n\t\t    case 'p':\n\t\t\tVA_POINT(void *);\n\t\t\tused = 'p';\n\t\t\tbreak;\n\t\t    case 'n':\n\t\t\tVA_POINT(int *);\n\t\t\tused = 0;\n\t\t\tbreak;\n\t\t    default:\n\t\t\tbreak;\n\t\t    }\n\t\t} else if (*fmt == '.') {\n\t\t    state = Prec;\n\t\t} else if (*fmt == '%') {\n\t\t    done = TRUE;\n\t\t    used = 'p';\n\t\t}\n\t    }\n\t    format[f] = '\\0';\n\t    switch (used) {\n\t    case 'i':\n\t\t_nc_SPRINTF(buffer, _nc_SLIMIT(length) format, ival);\n\t\tbreak;\n\t    case 'f':\n\t\t_nc_SPRINTF(buffer, _nc_SLIMIT(length) format, fval);\n\t\tbreak;\n\t    default:\n\t\t_nc_SPRINTF(buffer, _nc_SLIMIT(length) format, pval);\n\t\tbreak;\n\t    }\n\t    len += (int) strlen(buffer);\n\t} else {\n\t    fmt++;\n\t    len++;\n\t}\n    }\n\n    free(buffer);\n    free(format);\n    return len;\n}\n#endif\n\n#define my_buffer _nc_globals.safeprint_buf\n#define my_length _nc_globals.safeprint_used\n\n/*\n * Wrapper for vsprintf that allocates a buffer big enough to hold the result.\n */\nNCURSES_EXPORT(char *)\nNCURSES_SP_NAME(_nc_printf_string) (NCURSES_SP_DCLx\n\t\t\t\t    const char *fmt,\n\t\t\t\t    va_list ap)\n{\n    char *result = 0;\n\n    if (fmt != 0) {\n#if USE_SAFE_SPRINTF\n\tva_list ap2;\n\tint len;\n\n\tbegin_va_copy(ap2, ap);\n\tlen = _nc_printf_length(fmt, ap2);\n\tend_va_copy(ap2);\n\n\tif ((int) my_length < len + 1) {\n\t    my_length = 2 * (len + 1);\n\t    my_buffer = typeRealloc(char, my_length, my_buffer);\n\t}\n\tif (my_buffer != 0) {\n\t    *my_buffer = '\\0';\n\t    if (len >= 0) {\n\t\tvsprintf(my_buffer, fmt, ap);\n\t    }\n\t    result = my_buffer;\n\t}\n#else\n#define MyCols _nc_globals.safeprint_cols\n#define MyRows _nc_globals.safeprint_rows\n\n\tif (screen_lines(SP_PARM) > MyRows || screen_columns(SP_PARM) > MyCols) {\n\t    if (screen_lines(SP_PARM) > MyRows)\n\t\tMyRows = screen_lines(SP_PARM);\n\t    if (screen_columns(SP_PARM) > MyCols)\n\t\tMyCols = screen_columns(SP_PARM);\n\t    my_length = (size_t) (MyRows * (MyCols + 1)) + 1;\n\t    my_buffer = typeRealloc(char, my_length, my_buffer);\n\t}\n\n\tif (my_buffer != 0) {\n# if HAVE_VSNPRINTF\n\t    vsnprintf(my_buffer, my_length, fmt, ap);\t/* GNU extension */\n# else\n\t    vsprintf(my_buffer, fmt, ap);\t/* ANSI */\n# endif\n\t    result = my_buffer;\n\t}\n#endif\n    } else if (my_buffer != 0) {\t/* see _nc_freeall() */\n\tfree(my_buffer);\n\tmy_buffer = 0;\n\tmy_length = 0;\n    }\n    return result;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(char *)\n_nc_printf_string(const char *fmt, va_list ap)\n{\n    return NCURSES_SP_NAME(_nc_printf_string) (CURRENT_SCREEN, fmt, ap);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 2001-2008,2012 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey 2001                                           *\n ****************************************************************************/\n\n#include <curses.priv.h>\n\n#include <ctype.h>\n\nMODULE_ID(\"$Id: varargs.c,v 1.11 2012/10/27 21:03:28 tom Exp $\")\n\n#ifdef TRACE\n\n#define MAX_PARMS 10\n\ntypedef enum {\n    atUnknown = 0, atInteger, atFloat, atPoint, atString\n} ARGTYPE;\n\n#define VA_INT(type) ival = (int) va_arg(ap, type)\n#define VA_FLT(type) fval = va_arg(ap, type)\n#define VA_PTR(type) pval = (char *)va_arg(ap, type)\n#define VA_STR(type) sval = va_arg(ap, type)\n\n#define MyBuffer _nc_globals.tracearg_buf\n#define MyLength _nc_globals.tracearg_used\n\n/*\n * Returns a string that represents the parameter list of a printf-style call.\n */\nNCURSES_EXPORT(char *)\n_nc_varargs(const char *fmt, va_list ap)\n{\n    static char dummy[] = \"\";\n\n    char buffer[BUFSIZ];\n    const char *param;\n    int n;\n\n    if (fmt == 0 || *fmt == '\\0')\n\treturn dummy;\n    if (MyLength == 0)\n\tMyBuffer = typeMalloc(char, MyLength = BUFSIZ);\n    if (MyBuffer == 0)\n\treturn dummy;\n    *MyBuffer = '\\0';\n\n    while (*fmt != '\\0') {\n\tif (*fmt == '%') {\n\t    char *pval = 0;\t/* avoid const-cast */\n\t    const char *sval = \"\";\n\t    double fval = 0.0;\n\t    int done = FALSE;\n\t    int ival = 0;\n\t    int type = 0;\n\t    ARGTYPE parm[MAX_PARMS];\n\t    int parms = 0;\n\t    ARGTYPE used = atUnknown;\n\n\t    while (*++fmt != '\\0' && !done) {\n\n\t\tif (*fmt == '*') {\n\t\t    VA_INT(int);\n\t\t    if (parms < MAX_PARMS)\n\t\t\tparm[parms++] = atInteger;\n\t\t} else if (isalpha(UChar(*fmt))) {\n\t\t    done = TRUE;\n\t\t    switch (*fmt) {\n\t\t    case 'Z':\t/* FALLTHRU */\n\t\t    case 'h':\t/* FALLTHRU */\n\t\t    case 'l':\t/* FALLTHRU */\n\t\t\tdone = FALSE;\n\t\t\ttype = *fmt;\n\t\t\tbreak;\n\t\t    case 'i':\t/* FALLTHRU */\n\t\t    case 'd':\t/* FALLTHRU */\n\t\t    case 'u':\t/* FALLTHRU */\n\t\t    case 'x':\t/* FALLTHRU */\n\t\t    case 'X':\t/* FALLTHRU */\n\t\t\tif (type == 'l')\n\t\t\t    VA_INT(long);\n\t\t\telse if (type == 'Z')\n\t\t\t    VA_INT(size_t);\n\t\t\telse\n\t\t\t    VA_INT(int);\n\t\t\tused = atInteger;\n\t\t\tbreak;\n\t\t    case 'f':\t/* FALLTHRU */\n\t\t    case 'e':\t/* FALLTHRU */\n\t\t    case 'E':\t/* FALLTHRU */\n\t\t    case 'g':\t/* FALLTHRU */\n\t\t    case 'G':\t/* FALLTHRU */\n\t\t\tVA_FLT(double);\n\t\t\tused = atFloat;\n\t\t\tbreak;\n\t\t    case 'c':\n\t\t\tVA_INT(int);\n\t\t\tused = atInteger;\n\t\t\tbreak;\n\t\t    case 's':\n\t\t\tVA_STR(const char *);\n\t\t\tused = atString;\n\t\t\tbreak;\n\t\t    case 'p':\n\t\t\tVA_PTR(void *);\n\t\t\tused = atPoint;\n\t\t\tbreak;\n\t\t    case 'n':\n\t\t\tVA_PTR(int *);\n\t\t\tused = atPoint;\n\t\t\tbreak;\n\t\t    default:\n\t\t\tbreak;\n\t\t    }\n\t\t} else if (*fmt == '%') {\n\t\t    done = TRUE;\n\t\t}\n\t\tif (used != atUnknown && parms < MAX_PARMS) {\n\t\t    parm[parms++] = used;\n\t\t    for (n = 0; n < parms; ++n) {\n\t\t\tused = parm[n];\n\t\t\tparam = buffer;\n\t\t\tswitch (used) {\n\t\t\tcase atInteger:\n\t\t\t    _nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer))\n\t\t\t\t\t\"%d\", ival);\n\t\t\t    break;\n\t\t\tcase atFloat:\n\t\t\t    _nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer))\n\t\t\t\t\t\"%f\", fval);\n\t\t\t    break;\n\t\t\tcase atPoint:\n\t\t\t    _nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer))\n\t\t\t\t\t\"%p\", pval);\n\t\t\t    break;\n\t\t\tcase atString:\n\t\t\t    param = _nc_visbuf2(1, sval);\n\t\t\t    break;\n\t\t\tcase atUnknown:\n\t\t\tdefault:\n\t\t\t    _nc_STRCPY(buffer, \"?\", sizeof(buffer));\n\t\t\t    break;\n\t\t\t}\n\t\t\tMyLength += strlen(param) + 2;\n\t\t\tMyBuffer = typeRealloc(char, MyLength, MyBuffer);\n\t\t\tif (MyBuffer != 0) {\n\t\t\t    _nc_SPRINTF(MyBuffer + strlen(MyBuffer),\n\t\t\t\t\t_nc_SLIMIT(MyLength - strlen(MyBuffer))\n\t\t\t\t\t\", %s\", param);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tused = atUnknown;\n\t    }\n\t} else {\n\t    fmt++;\n\t}\n    }\n\n    return (MyBuffer ? MyBuffer : dummy);\n}\n#else\nEMPTY_MODULE(_nc_varargs)\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2011,2012 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey                                                *\n ****************************************************************************/\n\n#include <curses.priv.h>\n\n#include <ctype.h>\n\n#include <tic.h>\n\nMODULE_ID(\"$Id: access.c,v 1.23 2012/09/01 19:21:29 tom Exp $\")\n\n#ifdef __TANDEM\n#define ROOT_UID 65535\n#endif\n\n#ifndef ROOT_UID\n#define ROOT_UID 0\n#endif\n\n#define LOWERCASE(c) ((isalpha(UChar(c)) && isupper(UChar(c))) ? tolower(UChar(c)) : (c))\n\nNCURSES_EXPORT(char *)\n_nc_rootname(char *path)\n{\n    char *result = _nc_basename(path);\n#if !MIXEDCASE_FILENAMES || defined(PROG_EXT)\n    static char *temp;\n    char *s;\n\n    temp = strdup(result);\n    result = temp;\n#if !MIXEDCASE_FILENAMES\n    for (s = result; *s != '\\0'; ++s) {\n\t*s = (char) LOWERCASE(*s);\n    }\n#endif\n#if defined(PROG_EXT)\n    if ((s = strrchr(result, '.')) != 0) {\n\tif (!strcmp(s, PROG_EXT))\n\t    *s = '\\0';\n    }\n#endif\n#endif\n    return result;\n}\n\n/*\n * Check if a string appears to be an absolute pathname.\n */\nNCURSES_EXPORT(bool)\n_nc_is_abs_path(const char *path)\n{\n#if defined(__EMX__) || defined(__DJGPP__)\n#define is_pathname(s) ((((s) != 0) && ((s)[0] == '/')) \\\n\t\t  || (((s)[0] != 0) && ((s)[1] == ':')))\n#else\n#define is_pathname(s) ((s) != 0 && (s)[0] == '/')\n#endif\n    return is_pathname(path);\n}\n\n/*\n * Return index of the basename\n */\nNCURSES_EXPORT(unsigned)\n_nc_pathlast(const char *path)\n{\n    const char *test = strrchr(path, '/');\n#ifdef __EMX__\n    if (test == 0)\n\ttest = strrchr(path, '\\\\');\n#endif\n    if (test == 0)\n\ttest = path;\n    else\n\ttest++;\n    return (unsigned) (test - path);\n}\n\nNCURSES_EXPORT(char *)\n_nc_basename(char *path)\n{\n    return path + _nc_pathlast(path);\n}\n\nNCURSES_EXPORT(int)\n_nc_access(const char *path, int mode)\n{\n    int result;\n\n    if (path == 0) {\n\tresult = -1;\n    } else if (access(path, mode) < 0) {\n\tif ((mode & W_OK) != 0\n\t    && errno == ENOENT\n\t    && strlen(path) < PATH_MAX) {\n\t    char head[PATH_MAX];\n\t    char *leaf;\n\n\t    _nc_STRCPY(head, path, sizeof(head));\n\t    leaf = _nc_basename(head);\n\t    if (leaf == 0)\n\t\tleaf = head;\n\t    *leaf = '\\0';\n\t    if (head == leaf)\n\t\t_nc_STRCPY(head, \".\", sizeof(head));\n\n\t    result = access(head, R_OK | W_OK | X_OK);\n\t} else {\n\t    result = -1;\n\t}\n    } else {\n\tresult = 0;\n    }\n    return result;\n}\n\nNCURSES_EXPORT(bool)\n_nc_is_dir_path(const char *path)\n{\n    bool result = FALSE;\n    struct stat sb;\n\n    if (stat(path, &sb) == 0\n\t&& S_ISDIR(sb.st_mode)) {\n\tresult = TRUE;\n    }\n    return result;\n}\n\nNCURSES_EXPORT(bool)\n_nc_is_file_path(const char *path)\n{\n    bool result = FALSE;\n    struct stat sb;\n\n    if (stat(path, &sb) == 0\n\t&& S_ISREG(sb.st_mode)) {\n\tresult = TRUE;\n    }\n    return result;\n}\n\n#ifndef USE_ROOT_ENVIRON\n/*\n * Returns true if we allow application to use environment variables that are\n * used for searching lists of directories, etc.\n */\nNCURSES_EXPORT(int)\n_nc_env_access(void)\n{\n#if HAVE_ISSETUGID\n    if (issetugid())\n\treturn FALSE;\n#elif HAVE_GETEUID && HAVE_GETEGID\n    if (getuid() != geteuid()\n\t|| getgid() != getegid())\n\treturn FALSE;\n#endif\n    /* ...finally, disallow root */\n    return (getuid() != ROOT_UID) && (geteuid() != ROOT_UID);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2008,2009 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n ****************************************************************************/\n\n/*\n *\tcomp_hash.c --- Routines to deal with the hashtable of capability\n *\t\t\tnames.\n *\n */\n\n#define USE_TERMLIB 1\n#include <curses.priv.h>\n\n#include <tic.h>\n#include <hashsize.h>\n\nMODULE_ID(\"$Id: comp_hash.c,v 1.48 2009/08/08 17:36:21 tom Exp $\")\n\n/*\n * Finds the entry for the given string in the hash table if present.\n * Returns a pointer to the entry in the table or 0 if not found.\n */\n/* entrypoint used by tack (do not alter) */\nNCURSES_EXPORT(struct name_table_entry const *)\n_nc_find_entry(const char *string,\n\t       const HashValue * hash_table)\n{\n    bool termcap = (hash_table != _nc_get_hash_table(FALSE));\n    const HashData *data = _nc_get_hash_info(termcap);\n    int hashvalue;\n    struct name_table_entry const *ptr = 0;\n    struct name_table_entry const *real_table;\n\n    hashvalue = data->hash_of(string);\n\n    if (data->table_data[hashvalue] >= 0) {\n\n\treal_table = _nc_get_table(termcap);\n\tptr = real_table + data->table_data[hashvalue];\n\twhile (!data->compare_names(ptr->nte_name, string)) {\n\t    if (ptr->nte_link < 0) {\n\t\tptr = 0;\n\t\tbreak;\n\t    }\n\t    ptr = real_table + (ptr->nte_link\n\t\t\t\t+ data->table_data[data->table_size]);\n\t}\n    }\n\n    return (ptr);\n}\n\n/*\n * Finds the entry for the given name with the given type in the given table if\n * present (as distinct from _nc_find_entry, which finds the last entry\n * regardless of type).\n *\n * Returns a pointer to the entry in the table or 0 if not found.\n */\nNCURSES_EXPORT(struct name_table_entry const *)\n_nc_find_type_entry(const char *string,\n\t\t    int type,\n\t\t    bool termcap)\n{\n    struct name_table_entry const *ptr = NULL;\n    const HashData *data = _nc_get_hash_info(termcap);\n    int hashvalue = data->hash_of(string);\n\n    if (data->table_data[hashvalue] >= 0) {\n\tconst struct name_table_entry *const table = _nc_get_table(termcap);\n\n\tptr = table + data->table_data[hashvalue];\n\twhile (ptr->nte_type != type\n\t       || !data->compare_names(ptr->nte_name, string)) {\n\t    if (ptr->nte_link < 0) {\n\t\tptr = 0;\n\t\tbreak;\n\t    }\n\t    ptr = table + (ptr->nte_link + data->table_data[data->table_size]);\n\t}\n    }\n\n    return ptr;\n}\n","/****************************************************************************\n * Copyright (c) 2006-2016,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey                                                *\n ****************************************************************************/\n\n/*\n * Iterators for terminal databases.\n */\n\n#include <curses.priv.h>\n\n#include <time.h>\n#include <tic.h>\n\n#if USE_HASHED_DB\n#include <hashed_db.h>\n#endif\n\nMODULE_ID(\"$Id: db_iterator.c,v 1.46 2017/07/01 22:54:42 tom Exp $\")\n\n#define HaveTicDirectory _nc_globals.have_tic_directory\n#define KeepTicDirectory _nc_globals.keep_tic_directory\n#define TicDirectory     _nc_globals.tic_directory\n#define my_blob          _nc_globals.dbd_blob\n#define my_list          _nc_globals.dbd_list\n#define my_size          _nc_globals.dbd_size\n#define my_time          _nc_globals.dbd_time\n#define my_vars          _nc_globals.dbd_vars\n\nstatic void\nadd_to_blob(const char *text, size_t limit)\n{\n    (void) limit;\n\n    if (*text != '\\0') {\n\tchar *last = my_blob + strlen(my_blob);\n\tif (last != my_blob)\n\t    *last++ = NCURSES_PATHSEP;\n\t_nc_STRCPY(last, text, limit);\n    }\n}\n\nstatic bool\ncheck_existence(const char *name, struct stat *sb)\n{\n    bool result = FALSE;\n\n    if (quick_prefix(name)) {\n\tresult = TRUE;\n    } else if (stat(name, sb) == 0\n\t       && (S_ISDIR(sb->st_mode)\n\t\t   || (S_ISREG(sb->st_mode) && sb->st_size))) {\n\tresult = TRUE;\n    }\n#if USE_HASHED_DB\n    else if (strlen(name) < PATH_MAX - sizeof(DBM_SUFFIX)) {\n\tchar temp[PATH_MAX];\n\t_nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp)) \"%s%s\", name, DBM_SUFFIX);\n\tif (stat(temp, sb) == 0 && S_ISREG(sb->st_mode) && sb->st_size) {\n\t    result = TRUE;\n\t}\n    }\n#endif\n    return result;\n}\n\n/*\n * Trim newlines (and backslashes preceding those) and tab characters to\n * help simplify scripting of the quick-dump feature.  Leave spaces and\n * other backslashes alone.\n */\nstatic void\ntrim_formatting(char *source)\n{\n    char *target = source;\n    char ch;\n\n    while ((ch = *source++) != '\\0') {\n\tif (ch == '\\\\' && *source == '\\n')\n\t    continue;\n\tif (ch == '\\n' || ch == '\\t')\n\t    continue;\n\t*target++ = ch;\n    }\n    *target = '\\0';\n}\n\n/*\n * Store the latest value of an environment variable in my_vars[] so we can\n * detect if one changes, invalidating the cached search-list.\n */\nstatic bool\nupdate_getenv(const char *name, DBDIRS which)\n{\n    bool result = FALSE;\n\n    if (which < dbdLAST) {\n\tchar *value;\n\tchar *cached_value = my_vars[which].value;\n\tbool same_value;\n\n\tif ((value = getenv(name)) != 0) {\n\t    value = strdup(value);\n\t}\n\tsame_value = ((value == 0 && cached_value == 0) ||\n\t\t      (value != 0 &&\n\t\t       cached_value != 0 &&\n\t\t       strcmp(value, cached_value) == 0));\n\n\t/* Set variable name to enable checks in cache_expired(). */\n\tmy_vars[which].name = name;\n\n\tif (!same_value) {\n\t    FreeIfNeeded(my_vars[which].value);\n\t    my_vars[which].value = value;\n\t    result = TRUE;\n\t} else {\n\t    free(value);\n\t}\n    }\n    return result;\n}\n\nstatic char *\ncache_getenv(const char *name, DBDIRS which)\n{\n    char *result = 0;\n\n    (void) update_getenv(name, which);\n    if (which < dbdLAST) {\n\tresult = my_vars[which].value;\n    }\n    return result;\n}\n\n/*\n * The cache expires if at least a second has passed since the initial lookup,\n * or if one of the environment variables changed.\n *\n * Only a few applications use multiple lookups of terminal entries, seems that\n * aside from bulk I/O such as tic and toe, that leaves interactive programs\n * which should not be modifying the terminal databases in a way that would\n * invalidate the search-list.\n *\n * The \"1-second\" is to allow for user-directed changes outside the program.\n */\nstatic bool\ncache_expired(void)\n{\n    bool result = FALSE;\n    time_t now = time((time_t *) 0);\n\n    if (now > my_time) {\n\tresult = TRUE;\n    } else {\n\tDBDIRS n;\n\tfor (n = (DBDIRS) 0; n < dbdLAST; ++n) {\n\t    if (my_vars[n].name != 0\n\t\t&& update_getenv(my_vars[n].name, n)) {\n\t\tresult = TRUE;\n\t\tbreak;\n\t    }\n\t}\n    }\n    return result;\n}\n\nstatic void\nfree_cache(void)\n{\n    FreeAndNull(my_blob);\n    FreeAndNull(my_list);\n}\n\n/*\n * Record the \"official\" location of the terminfo directory, according to\n * the place where we're writing to, or the normal default, if not.\n */\nNCURSES_EXPORT(const char *)\n_nc_tic_dir(const char *path)\n{\n    T((\"_nc_tic_dir %s\", NonNull(path)));\n    if (!KeepTicDirectory) {\n\tif (path != 0) {\n\t    TicDirectory = path;\n\t    HaveTicDirectory = TRUE;\n\t} else if (HaveTicDirectory == 0) {\n\t    if (use_terminfo_vars()) {\n\t\tconst char *envp;\n\t\tif ((envp = getenv(\"TERMINFO\")) != 0)\n\t\t    return _nc_tic_dir(envp);\n\t    }\n\t}\n    }\n    return TicDirectory ? TicDirectory : TERMINFO;\n}\n\n/*\n * Special fix to prevent the terminfo directory from being moved after tic\n * has chdir'd to it.  If we let it be changed, then if $TERMINFO has a\n * relative path, we'll lose track of the actual directory.\n */\nNCURSES_EXPORT(void)\n_nc_keep_tic_dir(const char *path)\n{\n    _nc_tic_dir(path);\n    KeepTicDirectory = TRUE;\n}\n\n/*\n * Cleanup.\n */\nNCURSES_EXPORT(void)\n_nc_last_db(void)\n{\n    if (my_blob != 0 && cache_expired()) {\n\tfree_cache();\n    }\n}\n\n/*\n * This is a simple iterator which allows the caller to step through the\n * possible locations for a terminfo directory.  ncurses uses this to find\n * terminfo files to read.\n */\nNCURSES_EXPORT(const char *)\n_nc_next_db(DBDIRS * state, int *offset)\n{\n    const char *result;\n\n    (void) offset;\n    if ((int) *state < my_size\n\t&& my_list != 0\n\t&& my_list[*state] != 0) {\n\tresult = my_list[*state];\n\t(*state)++;\n    } else {\n\tresult = 0;\n    }\n    if (result != 0) {\n\tT((\"_nc_next_db %d %s\", *state, result));\n    }\n    return result;\n}\n\nNCURSES_EXPORT(void)\n_nc_first_db(DBDIRS * state, int *offset)\n{\n    bool cache_has_expired = FALSE;\n    *state = dbdTIC;\n    *offset = 0;\n\n    T((T_CALLED(\"_nc_first_db\")));\n\n    /* build a blob containing all of the strings we will use for a lookup\n     * table.\n     */\n    if (my_blob == 0 || (cache_has_expired = cache_expired())) {\n\tsize_t blobsize = 0;\n\tconst char *values[dbdLAST];\n\tstruct stat *my_stat;\n\tint j;\n\n\tif (cache_has_expired)\n\t    free_cache();\n\n\tfor (j = 0; j < dbdLAST; ++j)\n\t    values[j] = 0;\n\n\t/*\n\t * This is the first item in the list, and is used only when tic is\n\t * writing to the database, as a performance improvement.\n\t */\n\tvalues[dbdTIC] = TicDirectory;\n\n#if NCURSES_USE_DATABASE\n#ifdef TERMINFO_DIRS\n\tvalues[dbdCfgList] = TERMINFO_DIRS;\n#endif\n#ifdef TERMINFO\n\tvalues[dbdCfgOnce] = TERMINFO;\n#endif\n#endif\n\n#if NCURSES_USE_TERMCAP\n\tvalues[dbdCfgList2] = TERMPATH;\n#endif\n\n\tif (use_terminfo_vars()) {\n#if NCURSES_USE_DATABASE\n\t    values[dbdEnvOnce] = cache_getenv(\"TERMINFO\", dbdEnvOnce);\n\t    values[dbdHome] = _nc_home_terminfo();\n\t    (void) cache_getenv(\"HOME\", dbdHome);\n\t    values[dbdEnvList] = cache_getenv(\"TERMINFO_DIRS\", dbdEnvList);\n\n#endif\n#if NCURSES_USE_TERMCAP\n\t    values[dbdEnvOnce2] = cache_getenv(\"TERMCAP\", dbdEnvOnce2);\n\t    /* only use $TERMCAP if it is an absolute path */\n\t    if (values[dbdEnvOnce2] != 0\n\t\t&& *values[dbdEnvOnce2] != '/') {\n\t\tvalues[dbdEnvOnce2] = 0;\n\t    }\n\t    values[dbdEnvList2] = cache_getenv(\"TERMPATH\", dbdEnvList2);\n#endif /* NCURSES_USE_TERMCAP */\n\t}\n\n\tfor (j = 0; j < dbdLAST; ++j) {\n\t    if (values[j] == 0)\n\t\tvalues[j] = \"\";\n\t    blobsize += 2 + strlen(values[j]);\n\t}\n\n\tmy_blob = malloc(blobsize);\n\tif (my_blob != 0) {\n\t    *my_blob = '\\0';\n\t    for (j = 0; j < dbdLAST; ++j) {\n\t\tadd_to_blob(values[j], blobsize);\n\t    }\n\n\t    /* Now, build an array which will be pointers to the distinct\n\t     * strings in the blob.\n\t     */\n\t    blobsize = 2;\n\t    for (j = 0; my_blob[j] != '\\0'; ++j) {\n\t\tif (my_blob[j] == NCURSES_PATHSEP)\n\t\t    ++blobsize;\n\t    }\n\t    my_list = typeCalloc(char *, blobsize);\n\t    my_stat = typeCalloc(struct stat, blobsize);\n\t    if (my_list != 0 && my_stat != 0) {\n\t\tint k = 0;\n\t\tmy_list[k++] = my_blob;\n\t\tfor (j = 0; my_blob[j] != '\\0'; ++j) {\n\t\t    if (my_blob[j] == NCURSES_PATHSEP\n\t\t\t&& ((&my_blob[j] - my_list[k - 1]) != 3\n\t\t\t    || !quick_prefix(my_list[k - 1]))) {\n\t\t\tmy_blob[j] = '\\0';\n\t\t\tmy_list[k++] = &my_blob[j + 1];\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Eliminate duplicates from the list.\n\t\t */\n\t\tfor (j = 0; my_list[j] != 0; ++j) {\n#ifdef TERMINFO\n\t\t    if (*my_list[j] == '\\0')\n\t\t\tmy_list[j] = strdup(TERMINFO);\n#endif\n\t\t    trim_formatting(my_list[j]);\n\t\t    for (k = 0; k < j; ++k) {\n\t\t\tif (!strcmp(my_list[j], my_list[k])) {\n\t\t\t    T((\"duplicate %s\", my_list[j]));\n\t\t\t    k = j - 1;\n\t\t\t    while ((my_list[j] = my_list[j + 1]) != 0) {\n\t\t\t\t++j;\n\t\t\t    }\n\t\t\t    j = k;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Eliminate non-existent databases, and those that happen to\n\t\t * be symlinked to another location.\n\t\t */\n\t\tfor (j = 0; my_list[j] != 0; ++j) {\n\t\t    bool found = check_existence(my_list[j], &my_stat[j]);\n#if HAVE_LINK\n\t\t    if (found) {\n\t\t\tfor (k = 0; k < j; ++k) {\n\t\t\t    if (my_stat[j].st_dev == my_stat[k].st_dev\n\t\t\t\t&& my_stat[j].st_ino == my_stat[k].st_ino) {\n\t\t\t\tfound = FALSE;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n#endif\n\t\t    if (!found) {\n\t\t\tT((\"not found %s\", my_list[j]));\n\t\t\tk = j;\n\t\t\twhile ((my_list[k] = my_list[k + 1]) != 0) {\n\t\t\t    ++k;\n\t\t\t}\n\t\t\t--j;\n\t\t    }\n\t\t}\n\t\tmy_size = j;\n\t\tmy_time = time((time_t *) 0);\n\t    } else {\n\t\tFreeAndNull(my_blob);\n\t    }\n\t    free(my_stat);\n\t}\n    }\n    returnVoid;\n}\n\n#if NO_LEAKS\nvoid\n_nc_db_iterator_leaks(void)\n{\n    DBDIRS which;\n\n    if (my_blob != 0)\n\tFreeAndNull(my_blob);\n    if (my_list != 0)\n\tFreeAndNull(my_list);\n    for (which = 0; (int) which < dbdLAST; ++which) {\n\tmy_vars[which].name = 0;\n\tFreeIfNeeded(my_vars[which].value);\n\tmy_vars[which].value = 0;\n    }\n}\n#endif\n","/* This file was generated by ./tinfo/MKfallback.sh */\n\n/*\n * DO NOT EDIT THIS FILE BY HAND!\n */\n\n#include <curses.priv.h>\n\nNCURSES_EXPORT(const TERMTYPE2 *)\n_nc_fallback2 (const char *name GCC_UNUSED)\n{\n\t/* the fallback list is empty */\n    return((const TERMTYPE2 *)0);\n}\n\n#if NCURSES_EXT_NUMBERS\n#undef _nc_fallback\n\n/*\n * This entrypoint is used by tack.\n */\nNCURSES_EXPORT(const TERMTYPE *)\n_nc_fallback (const char *name)\n{\n    const TERMTYPE2 *tp = _nc_fallback2(name);\n    const TERMTYPE *result = 0;\n    if (tp != 0) {\n\tstatic TERMTYPE temp;\n\t_nc_export_termtype2(&temp, tp);\n\tresult = &temp;\n    }\n    return result;\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1999-2011,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey                    1999-on                     *\n ****************************************************************************/\n\n/*\n * free_ttype.c -- allocation functions for TERMTYPE\n *\n *\t_nc_free_termtype()\n *\tuse_extended_names()\n *\n */\n\n#include <curses.priv.h>\n\n#include <tic.h>\n\nMODULE_ID(\"$Id: free_ttype.c,v 1.17 2017/04/13 01:06:04 tom Exp $\")\n\nstatic void\nreally_free_termtype(TERMTYPE2 *ptr, bool freeStrings)\n{\n    T((\"_nc_free_termtype(%s)\", ptr->term_names));\n\n    if (freeStrings) {\n\tFreeIfNeeded(ptr->str_table);\n    }\n    FreeIfNeeded(ptr->Booleans);\n    FreeIfNeeded(ptr->Numbers);\n    FreeIfNeeded(ptr->Strings);\n#if NCURSES_XNAMES\n    if (freeStrings) {\n\tFreeIfNeeded(ptr->ext_str_table);\n    }\n    FreeIfNeeded(ptr->ext_Names);\n#endif\n    memset(ptr, 0, sizeof(TERMTYPE));\n    _nc_free_entry(_nc_head, ptr);\n}\n\n/*\n * This entrypoint is used by tack.\n */\nNCURSES_EXPORT(void)\n_nc_free_termtype(TERMTYPE *ptr)\n{\n    really_free_termtype((TERMTYPE2 *) ptr, !NCURSES_EXT_NUMBERS);\n}\n\n#if NCURSES_EXT_NUMBERS\nNCURSES_EXPORT(void)\n_nc_free_termtype2(TERMTYPE2 *ptr)\n{\n    really_free_termtype(ptr, TRUE);\n}\n#endif\n\n#if NCURSES_XNAMES\nNCURSES_EXPORT_VAR(bool) _nc_user_definable = TRUE;\n\nNCURSES_EXPORT(int)\nuse_extended_names(bool flag)\n{\n    int oldflag = _nc_user_definable;\n\n    START_TRACE();\n    T((T_CALLED(\"use_extended_names(%d)\"), flag));\n    _nc_user_definable = flag;\n    returnBool(oldflag);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2012,2016 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey                                                *\n ****************************************************************************/\n\n/*\n *\thome_terminfo.c -- return the $HOME/.terminfo string, expanded\n */\n\n#include <curses.priv.h>\n#include <tic.h>\n\nMODULE_ID(\"$Id: home_terminfo.c,v 1.16 2016/05/28 23:22:52 tom Exp $\")\n\n/* ncurses extension...fall back on user's private directory */\n\n#define MyBuffer _nc_globals.home_terminfo\n\nNCURSES_EXPORT(char *)\n_nc_home_terminfo(void)\n{\n    char *result = 0;\n#if USE_HOME_TERMINFO\n    if (use_terminfo_vars()) {\n\n\tif (MyBuffer == 0) {\n\t    char *home;\n\n\t    if ((home = getenv(\"HOME\")) != 0) {\n\t\tsize_t want = (strlen(home) + sizeof(PRIVATE_INFO));\n\t\tTYPE_MALLOC(char, want, MyBuffer);\n\t\t_nc_SPRINTF(MyBuffer, _nc_SLIMIT(want) PRIVATE_INFO, home);\n\t    }\n\t}\n\tresult = MyBuffer;\n    }\n#endif\n    return result;\n}\n","/****************************************************************************\n * Copyright (c) 1999-2010,2016 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n#include <curses.priv.h>\n#include <tic.h>\t\t/* struct tinfo_fkeys */\n\nMODULE_ID(\"$Id: init_keytry.c,v 1.18 2016/05/28 23:22:52 tom Exp $\")\n\n/*\n**      _nc_init_keytry()\n**\n**      Construct the try for the current terminal's keypad keys.\n**\n*/\n\n/*\n * Internal entrypoints use SCREEN* parameter to obtain capabilities rather\n * than cur_term.\n */\n#undef CUR\n#define CUR SP_TERMTYPE\n\n#if\tBROKEN_LINKER\n#undef\t_nc_tinfo_fkeys\n#endif\n\n/* LINT_PREPRO\n#if 0*/\n#include <init_keytry.h>\n/* LINT_PREPRO\n#endif*/\n\n#if\tBROKEN_LINKER\nconst struct tinfo_fkeys *\n_nc_tinfo_fkeysf(void)\n{\n    return _nc_tinfo_fkeys;\n}\n#endif\n\nNCURSES_EXPORT(void)\n_nc_init_keytry(SCREEN *sp)\n{\n    /* The sp->_keytry value is initialized in newterm(), where the sp\n     * structure is created, because we can not tell where keypad() or\n     * mouse_activate() (which will call keyok()) are first called.\n     */\n\n    if (sp != 0) {\n\tunsigned n;\n\n\tfor (n = 0; _nc_tinfo_fkeys[n].code; n++) {\n\t    if (_nc_tinfo_fkeys[n].offset < STRCOUNT) {\n\t\t(void) _nc_add_to_try(&(sp->_keytry),\n\t\t\t\t      CUR Strings[_nc_tinfo_fkeys[n].offset],\n\t\t\t\t      _nc_tinfo_fkeys[n].code);\n\t    }\n\t}\n#if NCURSES_XNAMES\n\t/*\n\t * Add any of the extended strings to the tries if their name begins\n\t * with 'k', i.e., they follow the convention of other terminfo key\n\t * names.\n\t */\n\t{\n\t    TERMTYPE *tp = &(sp->_term->type);\n\t    for (n = STRCOUNT; n < NUM_STRINGS(tp); ++n) {\n\t\tconst char *name = ExtStrname(tp, (int) n, strnames);\n\t\tchar *value = tp->Strings[n];\n\t\tif (name != 0\n\t\t    && *name == 'k'\n\t\t    && value != 0\n\t\t    && NCURSES_SP_NAME(key_defined) (NCURSES_SP_ARGx\n\t\t\t\t\t\t     value) == 0) {\n\t\t    (void) _nc_add_to_try(&(sp->_keytry),\n\t\t\t\t\t  value,\n\t\t\t\t\t  n - STRCOUNT + KEY_MAX);\n\t\t}\n\t    }\n\t}\n#endif\n#ifdef TRACE\n\t_nc_trace_tries(sp->_keytry);\n#endif\n    }\n}\n","/* generated by MKkeyname.awk */\n\n#include <curses.priv.h>\n#include <tic.h>\n\nstruct kn { short offset; int code; };\nstatic const struct kn _nc_key_names[] = {\n\t{ 0, KEY_A1 },\n\t{ 7, KEY_A3 },\n\t{ 14, KEY_B2 },\n\t{ 21, KEY_BACKSPACE },\n\t{ 35, KEY_BEG },\n\t{ 43, KEY_BREAK },\n\t{ 53, KEY_BTAB },\n\t{ 62, KEY_C1 },\n\t{ 69, KEY_C3 },\n\t{ 76, KEY_CANCEL },\n\t{ 87, KEY_CATAB },\n\t{ 97, KEY_CLEAR },\n\t{ 107, KEY_CLOSE },\n\t{ 117, KEY_COMMAND },\n\t{ 129, KEY_COPY },\n\t{ 138, KEY_CREATE },\n\t{ 149, KEY_CTAB },\n\t{ 158, KEY_DC },\n\t{ 165, KEY_DL },\n\t{ 172, KEY_DOWN },\n\t{ 181, KEY_EIC },\n\t{ 189, KEY_END },\n\t{ 197, KEY_ENTER },\n\t{ 207, KEY_EOL },\n\t{ 215, KEY_EOS },\n\t{ 223, KEY_EXIT },\n\t{ 232, KEY_F(0) },\n\t{ 241, KEY_F(1) },\n\t{ 250, KEY_F(10) },\n\t{ 260, KEY_F(11) },\n\t{ 270, KEY_F(12) },\n\t{ 280, KEY_F(13) },\n\t{ 290, KEY_F(14) },\n\t{ 300, KEY_F(15) },\n\t{ 310, KEY_F(16) },\n\t{ 320, KEY_F(17) },\n\t{ 330, KEY_F(18) },\n\t{ 340, KEY_F(19) },\n\t{ 350, KEY_F(2) },\n\t{ 359, KEY_F(20) },\n\t{ 369, KEY_F(21) },\n\t{ 379, KEY_F(22) },\n\t{ 389, KEY_F(23) },\n\t{ 399, KEY_F(24) },\n\t{ 409, KEY_F(25) },\n\t{ 419, KEY_F(26) },\n\t{ 429, KEY_F(27) },\n\t{ 439, KEY_F(28) },\n\t{ 449, KEY_F(29) },\n\t{ 459, KEY_F(3) },\n\t{ 468, KEY_F(30) },\n\t{ 478, KEY_F(31) },\n\t{ 488, KEY_F(32) },\n\t{ 498, KEY_F(33) },\n\t{ 508, KEY_F(34) },\n\t{ 518, KEY_F(35) },\n\t{ 528, KEY_F(36) },\n\t{ 538, KEY_F(37) },\n\t{ 548, KEY_F(38) },\n\t{ 558, KEY_F(39) },\n\t{ 568, KEY_F(4) },\n\t{ 577, KEY_F(40) },\n\t{ 587, KEY_F(41) },\n\t{ 597, KEY_F(42) },\n\t{ 607, KEY_F(43) },\n\t{ 617, KEY_F(44) },\n\t{ 627, KEY_F(45) },\n\t{ 637, KEY_F(46) },\n\t{ 647, KEY_F(47) },\n\t{ 657, KEY_F(48) },\n\t{ 667, KEY_F(49) },\n\t{ 677, KEY_F(5) },\n\t{ 686, KEY_F(50) },\n\t{ 696, KEY_F(51) },\n\t{ 706, KEY_F(52) },\n\t{ 716, KEY_F(53) },\n\t{ 726, KEY_F(54) },\n\t{ 736, KEY_F(55) },\n\t{ 746, KEY_F(56) },\n\t{ 756, KEY_F(57) },\n\t{ 766, KEY_F(58) },\n\t{ 776, KEY_F(59) },\n\t{ 786, KEY_F(6) },\n\t{ 795, KEY_F(60) },\n\t{ 805, KEY_F(61) },\n\t{ 815, KEY_F(62) },\n\t{ 825, KEY_F(63) },\n\t{ 835, KEY_F(7) },\n\t{ 844, KEY_F(8) },\n\t{ 853, KEY_F(9) },\n\t{ 862, KEY_FIND },\n\t{ 871, KEY_HELP },\n\t{ 880, KEY_HOME },\n\t{ 889, KEY_IC },\n\t{ 896, KEY_IL },\n\t{ 903, KEY_LEFT },\n\t{ 912, KEY_LL },\n\t{ 919, KEY_MARK },\n\t{ 928, KEY_MESSAGE },\n\t{ 940, KEY_MOUSE },\n\t{ 950, KEY_MOVE },\n\t{ 959, KEY_NEXT },\n\t{ 968, KEY_NPAGE },\n\t{ 978, KEY_OPEN },\n\t{ 987, KEY_OPTIONS },\n\t{ 999, KEY_PPAGE },\n\t{ 1009, KEY_PREVIOUS },\n\t{ 1022, KEY_PRINT },\n\t{ 1032, KEY_REDO },\n\t{ 1041, KEY_REFERENCE },\n\t{ 1055, KEY_REFRESH },\n\t{ 1067, KEY_REPLACE },\n\t{ 1079, KEY_RESET },\n\t{ 1089, KEY_RESIZE },\n\t{ 1100, KEY_RESTART },\n\t{ 1112, KEY_RESUME },\n\t{ 1123, KEY_RIGHT },\n\t{ 1133, KEY_SAVE },\n\t{ 1142, KEY_SBEG },\n\t{ 1151, KEY_SCANCEL },\n\t{ 1163, KEY_SCOMMAND },\n\t{ 1176, KEY_SCOPY },\n\t{ 1186, KEY_SCREATE },\n\t{ 1198, KEY_SDC },\n\t{ 1206, KEY_SDL },\n\t{ 1214, KEY_SELECT },\n\t{ 1225, KEY_SEND },\n\t{ 1234, KEY_SEOL },\n\t{ 1243, KEY_SEXIT },\n\t{ 1253, KEY_SF },\n\t{ 1260, KEY_SFIND },\n\t{ 1270, KEY_SHELP },\n\t{ 1280, KEY_SHOME },\n\t{ 1290, KEY_SIC },\n\t{ 1298, KEY_SLEFT },\n\t{ 1308, KEY_SMESSAGE },\n\t{ 1321, KEY_SMOVE },\n\t{ 1331, KEY_SNEXT },\n\t{ 1341, KEY_SOPTIONS },\n\t{ 1354, KEY_SPREVIOUS },\n\t{ 1368, KEY_SPRINT },\n\t{ 1379, KEY_SR },\n\t{ 1386, KEY_SREDO },\n\t{ 1396, KEY_SREPLACE },\n\t{ 1409, KEY_SRESET },\n\t{ 1420, KEY_SRIGHT },\n\t{ 1431, KEY_SRSUME },\n\t{ 1442, KEY_SSAVE },\n\t{ 1452, KEY_SSUSPEND },\n\t{ 1465, KEY_STAB },\n\t{ 1474, KEY_SUNDO },\n\t{ 1484, KEY_SUSPEND },\n\t{ 1496, KEY_UNDO },\n\t{ 1505, KEY_UP },\n\t{ -1, 0 }};\n\nstatic const char key_names[] = \n\t\"KEY_A1\\0\"\n\t\"KEY_A3\\0\"\n\t\"KEY_B2\\0\"\n\t\"KEY_BACKSPACE\\0\"\n\t\"KEY_BEG\\0\"\n\t\"KEY_BREAK\\0\"\n\t\"KEY_BTAB\\0\"\n\t\"KEY_C1\\0\"\n\t\"KEY_C3\\0\"\n\t\"KEY_CANCEL\\0\"\n\t\"KEY_CATAB\\0\"\n\t\"KEY_CLEAR\\0\"\n\t\"KEY_CLOSE\\0\"\n\t\"KEY_COMMAND\\0\"\n\t\"KEY_COPY\\0\"\n\t\"KEY_CREATE\\0\"\n\t\"KEY_CTAB\\0\"\n\t\"KEY_DC\\0\"\n\t\"KEY_DL\\0\"\n\t\"KEY_DOWN\\0\"\n\t\"KEY_EIC\\0\"\n\t\"KEY_END\\0\"\n\t\"KEY_ENTER\\0\"\n\t\"KEY_EOL\\0\"\n\t\"KEY_EOS\\0\"\n\t\"KEY_EXIT\\0\"\n\t\"KEY_F(0)\\0\"\n\t\"KEY_F(1)\\0\"\n\t\"KEY_F(10)\\0\"\n\t\"KEY_F(11)\\0\"\n\t\"KEY_F(12)\\0\"\n\t\"KEY_F(13)\\0\"\n\t\"KEY_F(14)\\0\"\n\t\"KEY_F(15)\\0\"\n\t\"KEY_F(16)\\0\"\n\t\"KEY_F(17)\\0\"\n\t\"KEY_F(18)\\0\"\n\t\"KEY_F(19)\\0\"\n\t\"KEY_F(2)\\0\"\n\t\"KEY_F(20)\\0\"\n\t\"KEY_F(21)\\0\"\n\t\"KEY_F(22)\\0\"\n\t\"KEY_F(23)\\0\"\n\t\"KEY_F(24)\\0\"\n\t\"KEY_F(25)\\0\"\n\t\"KEY_F(26)\\0\"\n\t\"KEY_F(27)\\0\"\n\t\"KEY_F(28)\\0\"\n\t\"KEY_F(29)\\0\"\n\t\"KEY_F(3)\\0\"\n\t\"KEY_F(30)\\0\"\n\t\"KEY_F(31)\\0\"\n\t\"KEY_F(32)\\0\"\n\t\"KEY_F(33)\\0\"\n\t\"KEY_F(34)\\0\"\n\t\"KEY_F(35)\\0\"\n\t\"KEY_F(36)\\0\"\n\t\"KEY_F(37)\\0\"\n\t\"KEY_F(38)\\0\"\n\t\"KEY_F(39)\\0\"\n\t\"KEY_F(4)\\0\"\n\t\"KEY_F(40)\\0\"\n\t\"KEY_F(41)\\0\"\n\t\"KEY_F(42)\\0\"\n\t\"KEY_F(43)\\0\"\n\t\"KEY_F(44)\\0\"\n\t\"KEY_F(45)\\0\"\n\t\"KEY_F(46)\\0\"\n\t\"KEY_F(47)\\0\"\n\t\"KEY_F(48)\\0\"\n\t\"KEY_F(49)\\0\"\n\t\"KEY_F(5)\\0\"\n\t\"KEY_F(50)\\0\"\n\t\"KEY_F(51)\\0\"\n\t\"KEY_F(52)\\0\"\n\t\"KEY_F(53)\\0\"\n\t\"KEY_F(54)\\0\"\n\t\"KEY_F(55)\\0\"\n\t\"KEY_F(56)\\0\"\n\t\"KEY_F(57)\\0\"\n\t\"KEY_F(58)\\0\"\n\t\"KEY_F(59)\\0\"\n\t\"KEY_F(6)\\0\"\n\t\"KEY_F(60)\\0\"\n\t\"KEY_F(61)\\0\"\n\t\"KEY_F(62)\\0\"\n\t\"KEY_F(63)\\0\"\n\t\"KEY_F(7)\\0\"\n\t\"KEY_F(8)\\0\"\n\t\"KEY_F(9)\\0\"\n\t\"KEY_FIND\\0\"\n\t\"KEY_HELP\\0\"\n\t\"KEY_HOME\\0\"\n\t\"KEY_IC\\0\"\n\t\"KEY_IL\\0\"\n\t\"KEY_LEFT\\0\"\n\t\"KEY_LL\\0\"\n\t\"KEY_MARK\\0\"\n\t\"KEY_MESSAGE\\0\"\n\t\"KEY_MOUSE\\0\"\n\t\"KEY_MOVE\\0\"\n\t\"KEY_NEXT\\0\"\n\t\"KEY_NPAGE\\0\"\n\t\"KEY_OPEN\\0\"\n\t\"KEY_OPTIONS\\0\"\n\t\"KEY_PPAGE\\0\"\n\t\"KEY_PREVIOUS\\0\"\n\t\"KEY_PRINT\\0\"\n\t\"KEY_REDO\\0\"\n\t\"KEY_REFERENCE\\0\"\n\t\"KEY_REFRESH\\0\"\n\t\"KEY_REPLACE\\0\"\n\t\"KEY_RESET\\0\"\n\t\"KEY_RESIZE\\0\"\n\t\"KEY_RESTART\\0\"\n\t\"KEY_RESUME\\0\"\n\t\"KEY_RIGHT\\0\"\n\t\"KEY_SAVE\\0\"\n\t\"KEY_SBEG\\0\"\n\t\"KEY_SCANCEL\\0\"\n\t\"KEY_SCOMMAND\\0\"\n\t\"KEY_SCOPY\\0\"\n\t\"KEY_SCREATE\\0\"\n\t\"KEY_SDC\\0\"\n\t\"KEY_SDL\\0\"\n\t\"KEY_SELECT\\0\"\n\t\"KEY_SEND\\0\"\n\t\"KEY_SEOL\\0\"\n\t\"KEY_SEXIT\\0\"\n\t\"KEY_SF\\0\"\n\t\"KEY_SFIND\\0\"\n\t\"KEY_SHELP\\0\"\n\t\"KEY_SHOME\\0\"\n\t\"KEY_SIC\\0\"\n\t\"KEY_SLEFT\\0\"\n\t\"KEY_SMESSAGE\\0\"\n\t\"KEY_SMOVE\\0\"\n\t\"KEY_SNEXT\\0\"\n\t\"KEY_SOPTIONS\\0\"\n\t\"KEY_SPREVIOUS\\0\"\n\t\"KEY_SPRINT\\0\"\n\t\"KEY_SR\\0\"\n\t\"KEY_SREDO\\0\"\n\t\"KEY_SREPLACE\\0\"\n\t\"KEY_SRESET\\0\"\n\t\"KEY_SRIGHT\\0\"\n\t\"KEY_SRSUME\\0\"\n\t\"KEY_SSAVE\\0\"\n\t\"KEY_SSUSPEND\\0\"\n\t\"KEY_STAB\\0\"\n\t\"KEY_SUNDO\\0\"\n\t\"KEY_SUSPEND\\0\"\n\t\"KEY_UNDO\\0\"\n\t\"KEY_UP\\0\";\n\n#define SIZEOF_TABLE 256\n#define MyTable _nc_globals.keyname_table\n#define MyInit  _nc_globals.init_keyname\n\nNCURSES_EXPORT(NCURSES_CONST char *)\nsafe_keyname (SCREEN *sp, int c)\n{\n\tchar name[20];\n\tNCURSES_CONST char *result = 0;\n\n\tif (c == -1) {\n\t\tresult = \"-1\";\n\t} else {\n\t\tint i;\n\t\tfor (i = 0; _nc_key_names[i].offset != -1; i++) {\n\t\t\tif (_nc_key_names[i].code == c) {\n\t\t\t\tresult = (NCURSES_CONST char *)key_names + _nc_key_names[i].offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (result == 0 && (c >= 0 && c < SIZEOF_TABLE)) {\n\t\t\tif (MyTable == 0)\n\t\t\t\tMyTable = typeCalloc(char *, SIZEOF_TABLE);\n\n\t\t\tif (MyTable != 0) {\n\t\t\t\tint m_prefix = (sp == 0 || sp->_use_meta);\n\n\t\t\t\t/* if sense of meta() changed, discard cached data */\n\t\t\t\tif (MyInit != (m_prefix + 1)) {\n\t\t\t\t\tMyInit = m_prefix + 1;\n\t\t\t\t\tfor (i = 0; i < SIZEOF_TABLE; ++i) {\n\t\t\t\t\t\tif (MyTable[i]) {\n\t\t\t\t\t\t\tFreeAndNull(MyTable[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* create and cache result as needed */\n\t\t\t\tif (MyTable[c] == 0) {\n\t\t\t\t\tint cc = c;\n\t\t\t\t\tchar *p = name;\n#define P_LIMIT (sizeof(name) - (size_t) (p - name))\n\t\t\t\t\tif (cc >= 128 && m_prefix) {\n\t\t\t\t\t\t_nc_STRCPY(p, \"M-\", P_LIMIT);\n\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\tcc -= 128;\n\t\t\t\t\t}\n\t\t\t\t\tif (cc < 32)\n\t\t\t\t\t\t_nc_SPRINTF(p, _nc_SLIMIT(P_LIMIT) \"^%c\", cc + '@');\n\t\t\t\t\telse if (cc == 127)\n\t\t\t\t\t\t_nc_STRCPY(p, \"^?\", P_LIMIT);\n\t\t\t\t\telse\n\t\t\t\t\t\t_nc_SPRINTF(p, _nc_SLIMIT(P_LIMIT) \"%c\", cc);\n\t\t\t\t\tMyTable[c] = strdup(name);\n\t\t\t\t}\n\t\t\t\tresult = MyTable[c];\n\t\t\t}\n#if NCURSES_EXT_FUNCS && NCURSES_XNAMES\n\t\t} else if (result == 0 && HasTerminal(sp)) {\n\t\t\tint j, k;\n\t\t\tchar * bound;\n\t\t\tTERMTYPE2 *tp = &TerminalType(TerminalOf(sp));\n\t\t\tunsigned save_trace = _nc_tracing;\n\n\t\t\t_nc_tracing = 0;\t/* prevent recursion via keybound() */\n\t\t\tfor (j = 0; (bound = NCURSES_SP_NAME(keybound)(NCURSES_SP_ARGx c, j)) != 0; ++j) {\n\t\t\t\tfor(k = STRCOUNT; k < (int) NUM_STRINGS(tp);  k++) {\n\t\t\t\t\tif (tp->Strings[k] != 0 && !strcmp(bound, tp->Strings[k])) {\n\t\t\t\t\t\tresult = ExtStrname(tp, k, strnames);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(bound);\n\t\t\t\tif (result != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t_nc_tracing = save_trace;\n#endif\n\t\t}\n\t}\n\treturn result;\n}\n\nNCURSES_EXPORT(NCURSES_CONST char *)\nkeyname (int c)\n{\n\treturn safe_keyname (CURRENT_SCREEN, c);\n}\n\n#if NO_LEAKS\nvoid _nc_keyname_leaks(void)\n{\n\tif (MyTable != 0) {\n\t\tint j;\n\t\tfor (j = 0; j < SIZEOF_TABLE; ++j) {\n\t\t\tFreeIfNeeded(MyTable[j]);\n\t\t}\n\t\tFreeAndNull(MyTable);\n\t}\n}\n#endif /* NO_LEAKS */\n","/****************************************************************************\n * Copyright (c) 1999-2011,2012 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey 1999                                           *\n ****************************************************************************/\n/*\n *\ttrace_tries.c - Tracing/Debugging buffers (keycode tries-trees)\n */\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: trace_tries.c,v 1.17 2012/10/27 20:50:50 tom Exp $\")\n\n#ifdef TRACE\n#define my_buffer _nc_globals.tracetry_buf\n#define my_length _nc_globals.tracetry_used\n\nstatic void\nrecur_tries(TRIES * tree, unsigned level)\n{\n    if (level > my_length) {\n\tmy_length = (level + 1) * 4;\n\tmy_buffer = (unsigned char *) _nc_doalloc(my_buffer, my_length);\n    }\n\n    if (my_buffer != 0) {\n\twhile (tree != 0) {\n\t    if ((my_buffer[level] = tree->ch) == 0)\n\t\tmy_buffer[level] = 128;\n\t    my_buffer[level + 1] = 0;\n\t    if (tree->value != 0) {\n\t\t_tracef(\"%5d: %s (%s)\", tree->value,\n\t\t\t_nc_visbuf((char *) my_buffer), keyname(tree->value));\n\t    }\n\t    if (tree->child)\n\t\trecur_tries(tree->child, level + 1);\n\t    tree = tree->sibling;\n\t}\n    }\n}\n\nNCURSES_EXPORT(void)\n_nc_trace_tries(TRIES * tree)\n{\n    if ((my_buffer = typeMalloc(unsigned char, my_length = 80)) != 0) {\n\t_tracef(\"BEGIN tries %p\", (void *) tree);\n\trecur_tries(tree, 0);\n\t_tracef(\". . . tries %p\", (void *) tree);\n\tfree(my_buffer);\n    }\n}\n\n#else\nEMPTY_MODULE(_nc_empty_trace_tries)\n#endif\n","/****************************************************************************\n * Copyright (c) 2003-2006,2009 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey, 2003                                          *\n ****************************************************************************/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: key_defined.c,v 1.9 2009/10/24 22:15:47 tom Exp $\")\n\nstatic int\nfind_definition(TRIES * tree, const char *str)\n{\n    TRIES *ptr;\n    int result = OK;\n\n    if (str != 0 && *str != '\\0') {\n\tfor (ptr = tree; ptr != 0; ptr = ptr->sibling) {\n\t    if (UChar(*str) == UChar(ptr->ch)) {\n\t\tif (str[1] == '\\0' && ptr->child != 0) {\n\t\t    result = ERR;\n\t\t} else if ((result = find_definition(ptr->child, str + 1))\n\t\t\t   == OK) {\n\t\t    result = ptr->value;\n\t\t} else if (str[1] == '\\0') {\n\t\t    result = ERR;\n\t\t}\n\t    }\n\t    if (result != OK)\n\t\tbreak;\n\t}\n    }\n    return (result);\n}\n\n/*\n * Returns the keycode associated with the given string.  If none is found,\n * return OK.  If the string is only a prefix to other strings, return ERR.\n * Otherwise, return the keycode's value (neither OK/ERR).\n */\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(key_defined) (NCURSES_SP_DCLx const char *str)\n{\n    int code = ERR;\n\n    T((T_CALLED(\"key_defined(%p, %s)\"), (void *) SP_PARM, _nc_visbuf(str)));\n    if (SP_PARM != 0 && str != 0) {\n\tcode = find_definition(SP_PARM->_keytry, str);\n    }\n\n    returnCode(code);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nkey_defined(const char *str)\n{\n    return NCURSES_SP_NAME(key_defined) (CURRENT_SCREEN, str);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1999-2009,2011 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey                        1999-on                 *\n *     and: Juergen Pfeifer                         2009                    *\n ****************************************************************************/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: keybound.c,v 1.11 2011/10/22 16:47:05 tom Exp $\")\n\n/*\n * Returns the count'th string definition which is associated with the\n * given keycode.  The result is malloc'd, must be freed by the caller.\n */\nNCURSES_EXPORT(char *)\nNCURSES_SP_NAME(keybound) (NCURSES_SP_DCLx int code, int count)\n{\n    char *result = 0;\n\n    T((T_CALLED(\"keybound(%p, %d,%d)\"), (void *) SP_PARM, code, count));\n    if (SP_PARM != 0 && code >= 0) {\n\tresult = _nc_expand_try(SP_PARM->_keytry,\n\t\t\t\t(unsigned) code,\n\t\t\t\t&count,\n\t\t\t\t(size_t) 0);\n    }\n    returnPtr(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(char *)\nkeybound(int code, int count)\n{\n    return NCURSES_SP_NAME(keybound) (CURRENT_SCREEN, code, count);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2009,2016 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *\n *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *\n *     and: Thomas E. Dickey                        1996-on                 *\n ****************************************************************************/\n\n/*\n**\tlib_erase.c\n**\n**\tThe routine werase().\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_erase.c,v 1.18 2016/05/28 23:11:26 tom Exp $\")\n\nNCURSES_EXPORT(int)\nwerase(WINDOW *win)\n{\n    int code = ERR;\n    NCURSES_CH_T blank;\n    NCURSES_CH_T *start;\n\n    T((T_CALLED(\"werase(%p)\"), (void *) win));\n\n    if (win) {\n\tNCURSES_CH_T *sp;\n\tint y;\n\n\tblank = win->_nc_bkgd;\n\tfor (y = 0; y <= win->_maxy; y++) {\n\t    NCURSES_CH_T *end;\n\n\t    start = win->_line[y].text;\n\t    end = &start[win->_maxx];\n\n\t    /*\n\t     * If this is a derived window, we have to handle the case where\n\t     * a multicolumn character extends into the window that we are\n\t     * erasing.\n\t     */\n\t    if_WIDEC({\n\t\tif (isWidecExt(start[0])) {\n\t\t    int x = (win->_parent != 0) ? (win->_begx) : 0;\n\t\t    while (x-- > 0) {\n\t\t\tif (isWidecBase(start[-1])) {\n\t\t\t    --start;\n\t\t\t    break;\n\t\t\t}\n\t\t\t--start;\n\t\t    }\n\t\t}\n\t    });\n\n\t    for (sp = start; sp <= end; sp++)\n\t\t*sp = blank;\n\n\t    win->_line[y].firstchar = 0;\n\t    win->_line[y].lastchar = win->_maxx;\n\t}\n\twin->_curx = win->_cury = 0;\n\twin->_flags &= ~_WRAPPED;\n\t_nc_synchook(win);\n\tcode = OK;\n    }\n    returnCode(code);\n}\n","/****************************************************************************\n * Copyright (c) 1998-2009,2010 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey            1998-on                             *\n ****************************************************************************/\n\n/*\n**\tadd_tries.c\n**\n**\tAdd keycode/string to tries-tree.\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: add_tries.c,v 1.10 2010/12/19 01:31:14 tom Exp $\")\n\n#define SET_TRY(dst,src) if ((dst->ch = *src++) == 128) dst->ch = '\\0'\n#define CMP_TRY(a,b) ((a)? (a == b) : (b == 128))\n\nNCURSES_EXPORT(int)\n_nc_add_to_try(TRIES ** tree, const char *str, unsigned code)\n{\n    TRIES *ptr, *savedptr;\n    unsigned const char *txt = (unsigned const char *) str;\n\n    T((T_CALLED(\"_nc_add_to_try(%p, %s, %u)\"),\n       (void *) *tree, _nc_visbuf(str), code));\n    if (txt == 0 || *txt == '\\0' || code == 0)\n\treturnCode(ERR);\n\n    if ((*tree) != 0) {\n\tptr = savedptr = (*tree);\n\n\tfor (;;) {\n\t    unsigned char cmp = *txt;\n\n\t    while (!CMP_TRY(ptr->ch, cmp)\n\t\t   && ptr->sibling != 0)\n\t\tptr = ptr->sibling;\n\n\t    if (CMP_TRY(ptr->ch, cmp)) {\n\t\tif (*(++txt) == '\\0') {\n\t\t    ptr->value = (unsigned short) code;\n\t\t    returnCode(OK);\n\t\t}\n\t\tif (ptr->child != 0)\n\t\t    ptr = ptr->child;\n\t\telse\n\t\t    break;\n\t    } else {\n\t\tif ((ptr->sibling = typeCalloc(TRIES, 1)) == 0) {\n\t\t    returnCode(ERR);\n\t\t}\n\n\t\tsavedptr = ptr = ptr->sibling;\n\t\tSET_TRY(ptr, txt);\n\t\tptr->value = 0;\n\n\t\tbreak;\n\t    }\n\t}\t\t\t/* end for (;;) */\n    } else {\t\t\t/* (*tree) == 0 :: First sequence to be added */\n\tsavedptr = ptr = (*tree) = typeCalloc(TRIES, 1);\n\n\tif (ptr == 0) {\n\t    returnCode(ERR);\n\t}\n\n\tSET_TRY(ptr, txt);\n\tptr->value = 0;\n    }\n\n    /* at this point, we are adding to the try.  ptr->child == 0 */\n\n    while (*txt) {\n\tptr->child = typeCalloc(TRIES, 1);\n\n\tptr = ptr->child;\n\n\tif (ptr == 0) {\n\t    while ((ptr = savedptr) != 0) {\n\t\tsavedptr = ptr->child;\n\t\tfree(ptr);\n\t    }\n\t    returnCode(ERR);\n\t}\n\n\tSET_TRY(ptr, txt);\n\tptr->value = 0;\n    }\n\n    ptr->value = (unsigned short) code;\n    returnCode(OK);\n}\n","/*\n * generated by ./tinfo/MKcaptab.sh\n */\n\n/*\n *\tcomp_captab.c -- The names of the capabilities indexed via a hash\n *\t\t         table for the compiler.\n *\n */\n\n#include <curses.priv.h>\n#include <tic.h>\n#include <hashsize.h>\n\n/* 147 collisions out of 497 entries */\nstatic const char info_names_text[] = \\\n\"bw\\0\" \"am\\0\" \"xsb\\0\" \"xhp\\0\" \"xenl\\0\" \"eo\\0\" \"gn\\0\" \"hc\\0\" \"km\\0\" \\\n\"hs\\0\" \"in\\0\" \"da\\0\" \"db\\0\" \"mir\\0\" \"msgr\\0\" \"os\\0\" \"eslok\\0\" \"xt\\0\" \\\n\"hz\\0\" \"ul\\0\" \"xon\\0\" \"nxon\\0\" \"mc5i\\0\" \"chts\\0\" \"nrrmc\\0\" \"npc\\0\" \\\n\"ndscr\\0\" \"ccc\\0\" \"bce\\0\" \"hls\\0\" \"xhpa\\0\" \"crxm\\0\" \"daisy\\0\" \"xvpa\\0\" \\\n\"sam\\0\" \"cpix\\0\" \"lpix\\0\" \"cols\\0\" \"it\\0\" \"lines\\0\" \"lm\\0\" \"xmc\\0\" \\\n\"pb\\0\" \"vt\\0\" \"wsl\\0\" \"nlab\\0\" \"lh\\0\" \"lw\\0\" \"ma\\0\" \"wnum\\0\" \"colors\\0\" \\\n\"pairs\\0\" \"ncv\\0\" \"bufsz\\0\" \"spinv\\0\" \"spinh\\0\" \"maddr\\0\" \"mjump\\0\" \\\n\"mcs\\0\" \"mls\\0\" \"npins\\0\" \"orc\\0\" \"orl\\0\" \"orhi\\0\" \"orvi\\0\" \"cps\\0\" \\\n\"widcs\\0\" \"btns\\0\" \"bitwin\\0\" \"bitype\\0\" \"cbt\\0\" \"bel\\0\" \"cr\\0\" \"csr\\0\" \\\n\"tbc\\0\" \"clear\\0\" \"el\\0\" \"ed\\0\" \"hpa\\0\" \"cmdch\\0\" \"cup\\0\" \"cud1\\0\" \\\n\"home\\0\" \"civis\\0\" \"cub1\\0\" \"mrcup\\0\" \"cnorm\\0\" \"cuf1\\0\" \"ll\\0\" \\\n\"cuu1\\0\" \"cvvis\\0\" \"dch1\\0\" \"dl1\\0\" \"dsl\\0\" \"hd\\0\" \"smacs\\0\" \"blink\\0\" \\\n\"bold\\0\" \"smcup\\0\" \"smdc\\0\" \"dim\\0\" \"smir\\0\" \"invis\\0\" \"prot\\0\" \"rev\\0\" \\\n\"smso\\0\" \"smul\\0\" \"ech\\0\" \"rmacs\\0\" \"sgr0\\0\" \"rmcup\\0\" \"rmdc\\0\" \\\n\"rmir\\0\" \"rmso\\0\" \"rmul\\0\" \"flash\\0\" \"ff\\0\" \"fsl\\0\" \"is1\\0\" \"is2\\0\" \\\n\"is3\\0\" \"if\\0\" \"ich1\\0\" \"il1\\0\" \"ip\\0\" \"kbs\\0\" \"ktbc\\0\" \"kclr\\0\" \\\n\"kctab\\0\" \"kdch1\\0\" \"kdl1\\0\" \"kcud1\\0\" \"krmir\\0\" \"kel\\0\" \"ked\\0\" \\\n\"kf0\\0\" \"kf1\\0\" \"kf10\\0\" \"kf2\\0\" \"kf3\\0\" \"kf4\\0\" \"kf5\\0\" \"kf6\\0\" \\\n\"kf7\\0\" \"kf8\\0\" \"kf9\\0\" \"khome\\0\" \"kich1\\0\" \"kil1\\0\" \"kcub1\\0\" \"kll\\0\" \\\n\"knp\\0\" \"kpp\\0\" \"kcuf1\\0\" \"kind\\0\" \"kri\\0\" \"khts\\0\" \"kcuu1\\0\" \"rmkx\\0\" \\\n\"smkx\\0\" \"lf0\\0\" \"lf1\\0\" \"lf10\\0\" \"lf2\\0\" \"lf3\\0\" \"lf4\\0\" \"lf5\\0\" \\\n\"lf6\\0\" \"lf7\\0\" \"lf8\\0\" \"lf9\\0\" \"rmm\\0\" \"smm\\0\" \"nel\\0\" \"pad\\0\" \"dch\\0\" \\\n\"dl\\0\" \"cud\\0\" \"ich\\0\" \"indn\\0\" \"il\\0\" \"cub\\0\" \"cuf\\0\" \"rin\\0\" \"cuu\\0\" \\\n\"pfkey\\0\" \"pfloc\\0\" \"pfx\\0\" \"mc0\\0\" \"mc4\\0\" \"mc5\\0\" \"rep\\0\" \"rs1\\0\" \\\n\"rs2\\0\" \"rs3\\0\" \"rf\\0\" \"rc\\0\" \"vpa\\0\" \"sc\\0\" \"ind\\0\" \"ri\\0\" \"sgr\\0\" \\\n\"hts\\0\" \"wind\\0\" \"ht\\0\" \"tsl\\0\" \"uc\\0\" \"hu\\0\" \"iprog\\0\" \"ka1\\0\" \"ka3\\0\" \\\n\"kb2\\0\" \"kc1\\0\" \"kc3\\0\" \"mc5p\\0\" \"rmp\\0\" \"acsc\\0\" \"pln\\0\" \"kcbt\\0\" \\\n\"smxon\\0\" \"rmxon\\0\" \"smam\\0\" \"rmam\\0\" \"xonc\\0\" \"xoffc\\0\" \"enacs\\0\" \\\n\"smln\\0\" \"rmln\\0\" \"kbeg\\0\" \"kcan\\0\" \"kclo\\0\" \"kcmd\\0\" \"kcpy\\0\" \"kcrt\\0\" \\\n\"kend\\0\" \"kent\\0\" \"kext\\0\" \"kfnd\\0\" \"khlp\\0\" \"kmrk\\0\" \"kmsg\\0\" \"kmov\\0\" \\\n\"knxt\\0\" \"kopn\\0\" \"kopt\\0\" \"kprv\\0\" \"kprt\\0\" \"krdo\\0\" \"kref\\0\" \"krfr\\0\" \\\n\"krpl\\0\" \"krst\\0\" \"kres\\0\" \"ksav\\0\" \"kspd\\0\" \"kund\\0\" \"kBEG\\0\" \"kCAN\\0\" \\\n\"kCMD\\0\" \"kCPY\\0\" \"kCRT\\0\" \"kDC\\0\" \"kDL\\0\" \"kslt\\0\" \"kEND\\0\" \"kEOL\\0\" \\\n\"kEXT\\0\" \"kFND\\0\" \"kHLP\\0\" \"kHOM\\0\" \"kIC\\0\" \"kLFT\\0\" \"kMSG\\0\" \"kMOV\\0\" \\\n\"kNXT\\0\" \"kOPT\\0\" \"kPRV\\0\" \"kPRT\\0\" \"kRDO\\0\" \"kRPL\\0\" \"kRIT\\0\" \"kRES\\0\" \\\n\"kSAV\\0\" \"kSPD\\0\" \"kUND\\0\" \"rfi\\0\" \"kf11\\0\" \"kf12\\0\" \"kf13\\0\" \"kf14\\0\" \\\n\"kf15\\0\" \"kf16\\0\" \"kf17\\0\" \"kf18\\0\" \"kf19\\0\" \"kf20\\0\" \"kf21\\0\" \"kf22\\0\" \\\n\"kf23\\0\" \"kf24\\0\" \"kf25\\0\" \"kf26\\0\" \"kf27\\0\" \"kf28\\0\" \"kf29\\0\" \"kf30\\0\" \\\n\"kf31\\0\" \"kf32\\0\" \"kf33\\0\" \"kf34\\0\" \"kf35\\0\" \"kf36\\0\" \"kf37\\0\" \"kf38\\0\" \\\n\"kf39\\0\" \"kf40\\0\" \"kf41\\0\" \"kf42\\0\" \"kf43\\0\" \"kf44\\0\" \"kf45\\0\" \"kf46\\0\" \\\n\"kf47\\0\" \"kf48\\0\" \"kf49\\0\" \"kf50\\0\" \"kf51\\0\" \"kf52\\0\" \"kf53\\0\" \"kf54\\0\" \\\n\"kf55\\0\" \"kf56\\0\" \"kf57\\0\" \"kf58\\0\" \"kf59\\0\" \"kf60\\0\" \"kf61\\0\" \"kf62\\0\" \\\n\"kf63\\0\" \"el1\\0\" \"mgc\\0\" \"smgl\\0\" \"smgr\\0\" \"fln\\0\" \"sclk\\0\" \"dclk\\0\" \\\n\"rmclk\\0\" \"cwin\\0\" \"wingo\\0\" \"hup\\0\" \"dial\\0\" \"qdial\\0\" \"tone\\0\" \\\n\"pulse\\0\" \"hook\\0\" \"pause\\0\" \"wait\\0\" \"u0\\0\" \"u1\\0\" \"u2\\0\" \"u3\\0\" \\\n\"u4\\0\" \"u5\\0\" \"u6\\0\" \"u7\\0\" \"u8\\0\" \"u9\\0\" \"op\\0\" \"oc\\0\" \"initc\\0\" \\\n\"initp\\0\" \"scp\\0\" \"setf\\0\" \"setb\\0\" \"cpi\\0\" \"lpi\\0\" \"chr\\0\" \"cvr\\0\" \\\n\"defc\\0\" \"swidm\\0\" \"sdrfq\\0\" \"sitm\\0\" \"slm\\0\" \"smicm\\0\" \"snlq\\0\" \\\n\"snrmq\\0\" \"sshm\\0\" \"ssubm\\0\" \"ssupm\\0\" \"sum\\0\" \"rwidm\\0\" \"ritm\\0\" \\\n\"rlm\\0\" \"rmicm\\0\" \"rshm\\0\" \"rsubm\\0\" \"rsupm\\0\" \"rum\\0\" \"mhpa\\0\" \\\n\"mcud1\\0\" \"mcub1\\0\" \"mcuf1\\0\" \"mvpa\\0\" \"mcuu1\\0\" \"porder\\0\" \"mcud\\0\" \\\n\"mcub\\0\" \"mcuf\\0\" \"mcuu\\0\" \"scs\\0\" \"smgb\\0\" \"smgbp\\0\" \"smglp\\0\" \\\n\"smgrp\\0\" \"smgt\\0\" \"smgtp\\0\" \"sbim\\0\" \"scsd\\0\" \"rbim\\0\" \"rcsd\\0\" \\\n\"subcs\\0\" \"supcs\\0\" \"docr\\0\" \"zerom\\0\" \"csnm\\0\" \"kmous\\0\" \"minfo\\0\" \\\n\"reqmp\\0\" \"getm\\0\" \"setaf\\0\" \"setab\\0\" \"pfxl\\0\" \"devt\\0\" \"csin\\0\" \\\n\"s0ds\\0\" \"s1ds\\0\" \"s2ds\\0\" \"s3ds\\0\" \"smglr\\0\" \"smgtb\\0\" \"birep\\0\" \\\n\"binel\\0\" \"bicr\\0\" \"colornm\\0\" \"defbi\\0\" \"endbi\\0\" \"setcolor\\0\" \\\n\"slines\\0\" \"dispc\\0\" \"smpch\\0\" \"rmpch\\0\" \"smsc\\0\" \"rmsc\\0\" \"pctrm\\0\" \\\n\"scesc\\0\" \"scesa\\0\" \"ehhlm\\0\" \"elhlm\\0\" \"elohlm\\0\" \"erhlm\\0\" \"ethlm\\0\" \\\n\"evhlm\\0\" \"sgr1\\0\" \"slength\\0\" \"OTi2\\0\" \"OTrs\\0\" \"OTug\\0\" \"OTbs\\0\" \\\n\"OTns\\0\" \"OTnc\\0\" \"OTdC\\0\" \"OTdN\\0\" \"OTnl\\0\" \"OTbc\\0\" \"OTMT\\0\" \"OTNL\\0\" \\\n\"OTdB\\0\" \"OTdT\\0\" \"OTkn\\0\" \"OTko\\0\" \"OTma\\0\" \"OTpt\\0\" \"OTxr\\0\" \"OTG2\\0\" \\\n\"OTG3\\0\" \"OTG1\\0\" \"OTG4\\0\" \"OTGR\\0\" \"OTGL\\0\" \"OTGU\\0\" \"OTGD\\0\" \"OTGH\\0\" \\\n\"OTGV\\0\" \"OTGC\\0\" \"meml\\0\" \"memu\\0\" \"box1\\0\" ;\n\nstatic name_table_data const info_names_data[] =\n{\n\t{               0,\t   BOOLEAN,\t  0,  -1 },\n\t{               3,\t   BOOLEAN,\t  1,  -1 },\n\t{               6,\t   BOOLEAN,\t  2,  -1 },\n\t{              10,\t   BOOLEAN,\t  3,  -1 },\n\t{              14,\t   BOOLEAN,\t  4,  -1 },\n\t{              19,\t   BOOLEAN,\t  5,  -1 },\n\t{              22,\t   BOOLEAN,\t  6,  -1 },\n\t{              25,\t   BOOLEAN,\t  7,  -1 },\n\t{              28,\t   BOOLEAN,\t  8,  -1 },\n\t{              31,\t   BOOLEAN,\t  9,  -1 },\n\t{              34,\t   BOOLEAN,\t 10,  -1 },\n\t{              37,\t   BOOLEAN,\t 11,  -1 },\n\t{              40,\t   BOOLEAN,\t 12,  -1 },\n\t{              43,\t   BOOLEAN,\t 13,  -1 },\n\t{              47,\t   BOOLEAN,\t 14,  -1 },\n\t{              52,\t   BOOLEAN,\t 15,  -1 },\n\t{              55,\t   BOOLEAN,\t 16,  -1 },\n\t{              61,\t   BOOLEAN,\t 17,  -1 },\n\t{              64,\t   BOOLEAN,\t 18,  -1 },\n\t{              67,\t   BOOLEAN,\t 19,  -1 },\n\t{              70,\t   BOOLEAN,\t 20,  -1 },\n\t{              74,\t   BOOLEAN,\t 21,  -1 },\n\t{              79,\t   BOOLEAN,\t 22,  -1 },\n\t{              84,\t   BOOLEAN,\t 23,  -1 },\n\t{              89,\t   BOOLEAN,\t 24,  -1 },\n\t{              95,\t   BOOLEAN,\t 25,  -1 },\n\t{              99,\t   BOOLEAN,\t 26,  -1 },\n\t{             105,\t   BOOLEAN,\t 27,  -1 },\n\t{             109,\t   BOOLEAN,\t 28,  -1 },\n\t{             113,\t   BOOLEAN,\t 29,  -1 },\n\t{             117,\t   BOOLEAN,\t 30,  -1 },\n\t{             122,\t   BOOLEAN,\t 31,  -1 },\n\t{             127,\t   BOOLEAN,\t 32,  -1 },\n\t{             133,\t   BOOLEAN,\t 33,  -1 },\n\t{             138,\t   BOOLEAN,\t 34,  -1 },\n\t{             142,\t   BOOLEAN,\t 35,  -1 },\n\t{             147,\t   BOOLEAN,\t 36,  -1 },\n\t{             152,\t    NUMBER,\t  0,  -1 },\n\t{             157,\t    NUMBER,\t  1,  -1 },\n\t{             160,\t    NUMBER,\t  2,   6 },\n\t{             166,\t    NUMBER,\t  3,  -1 },\n\t{             169,\t    NUMBER,\t  4,  -1 },\n\t{             173,\t    NUMBER,\t  5,  -1 },\n\t{             176,\t    NUMBER,\t  6,  -1 },\n\t{             179,\t    NUMBER,\t  7,  -1 },\n\t{             183,\t    NUMBER,\t  8,  -1 },\n\t{             188,\t    NUMBER,\t  9,  -1 },\n\t{             191,\t    NUMBER,\t 10,  -1 },\n\t{             194,\t    NUMBER,\t 11,  -1 },\n\t{             197,\t    NUMBER,\t 12,  -1 },\n\t{             202,\t    NUMBER,\t 13,  -1 },\n\t{             209,\t    NUMBER,\t 14,  -1 },\n\t{             215,\t    NUMBER,\t 15,  -1 },\n\t{             219,\t    NUMBER,\t 16,  46 },\n\t{             225,\t    NUMBER,\t 17,  -1 },\n\t{             231,\t    NUMBER,\t 18,  -1 },\n\t{             237,\t    NUMBER,\t 19,  -1 },\n\t{             243,\t    NUMBER,\t 20,  -1 },\n\t{             249,\t    NUMBER,\t 21,  -1 },\n\t{             253,\t    NUMBER,\t 22,  -1 },\n\t{             257,\t    NUMBER,\t 23,  -1 },\n\t{             263,\t    NUMBER,\t 24,  -1 },\n\t{             267,\t    NUMBER,\t 25,  -1 },\n\t{             271,\t    NUMBER,\t 26,  -1 },\n\t{             276,\t    NUMBER,\t 27,  -1 },\n\t{             281,\t    NUMBER,\t 28,  -1 },\n\t{             285,\t    NUMBER,\t 29,  -1 },\n\t{             291,\t    NUMBER,\t 30,  -1 },\n\t{             296,\t    NUMBER,\t 31,  -1 },\n\t{             303,\t    NUMBER,\t 32,  68 },\n\t{             310,\t    STRING,\t  0,  -1 },\n\t{             314,\t    STRING,\t  1,  -1 },\n\t{             318,\t    STRING,\t  2,  -1 },\n\t{             321,\t    STRING,\t  3,  -1 },\n\t{             325,\t    STRING,\t  4,  -1 },\n\t{             329,\t    STRING,\t  5,  -1 },\n\t{             335,\t    STRING,\t  6,  -1 },\n\t{             338,\t    STRING,\t  7,  -1 },\n\t{             341,\t    STRING,\t  8,  -1 },\n\t{             345,\t    STRING,\t  9,  -1 },\n\t{             351,\t    STRING,\t 10,  73 },\n\t{             355,\t    STRING,\t 11,  -1 },\n\t{             360,\t    STRING,\t 12,  -1 },\n\t{             365,\t    STRING,\t 13,  -1 },\n\t{             371,\t    STRING,\t 14,  -1 },\n\t{             376,\t    STRING,\t 15,  -1 },\n\t{             382,\t    STRING,\t 16,  -1 },\n\t{             388,\t    STRING,\t 17,  -1 },\n\t{             393,\t    STRING,\t 18,  -1 },\n\t{             396,\t    STRING,\t 19,  -1 },\n\t{             401,\t    STRING,\t 20,  -1 },\n\t{             407,\t    STRING,\t 21,  -1 },\n\t{             412,\t    STRING,\t 22,  -1 },\n\t{             416,\t    STRING,\t 23,  -1 },\n\t{             420,\t    STRING,\t 24,  -1 },\n\t{             423,\t    STRING,\t 25,  -1 },\n\t{             429,\t    STRING,\t 26,  -1 },\n\t{             435,\t    STRING,\t 27,  -1 },\n\t{             440,\t    STRING,\t 28,  -1 },\n\t{             446,\t    STRING,\t 29,  -1 },\n\t{             451,\t    STRING,\t 30,  -1 },\n\t{             455,\t    STRING,\t 31,  -1 },\n\t{             460,\t    STRING,\t 32,  -1 },\n\t{             466,\t    STRING,\t 33,  -1 },\n\t{             471,\t    STRING,\t 34,  -1 },\n\t{             475,\t    STRING,\t 35,  -1 },\n\t{             480,\t    STRING,\t 36,  -1 },\n\t{             485,\t    STRING,\t 37,  -1 },\n\t{             489,\t    STRING,\t 38,  -1 },\n\t{             495,\t    STRING,\t 39,  -1 },\n\t{             500,\t    STRING,\t 40,  -1 },\n\t{             506,\t    STRING,\t 41,  -1 },\n\t{             511,\t    STRING,\t 42,  -1 },\n\t{             516,\t    STRING,\t 43,  -1 },\n\t{             521,\t    STRING,\t 44,  -1 },\n\t{             526,\t    STRING,\t 45,  -1 },\n\t{             532,\t    STRING,\t 46,  -1 },\n\t{             535,\t    STRING,\t 47,  -1 },\n\t{             539,\t    STRING,\t 48,  -1 },\n\t{             543,\t    STRING,\t 49,  59 },\n\t{             547,\t    STRING,\t 50,  76 },\n\t{             551,\t    STRING,\t 51,  -1 },\n\t{             554,\t    STRING,\t 52,  20 },\n\t{             559,\t    STRING,\t 53,  -1 },\n\t{             563,\t    STRING,\t 54,  -1 },\n\t{             566,\t    STRING,\t 55,  -1 },\n\t{             570,\t    STRING,\t 56,  -1 },\n\t{             575,\t    STRING,\t 57,  98 },\n\t{             580,\t    STRING,\t 58,  -1 },\n\t{             586,\t    STRING,\t 59,  -1 },\n\t{             592,\t    STRING,\t 60,  -1 },\n\t{             597,\t    STRING,\t 61,  -1 },\n\t{             603,\t    STRING,\t 62,  -1 },\n\t{             609,\t    STRING,\t 63,  -1 },\n\t{             613,\t    STRING,\t 64,  -1 },\n\t{             617,\t    STRING,\t 65,  -1 },\n\t{             621,\t    STRING,\t 66,  -1 },\n\t{             625,\t    STRING,\t 67,  -1 },\n\t{             630,\t    STRING,\t 68,  -1 },\n\t{             634,\t    STRING,\t 69,  -1 },\n\t{             638,\t    STRING,\t 70,  -1 },\n\t{             642,\t    STRING,\t 71,  61 },\n\t{             646,\t    STRING,\t 72,  -1 },\n\t{             650,\t    STRING,\t 73,  -1 },\n\t{             654,\t    STRING,\t 74,  -1 },\n\t{             658,\t    STRING,\t 75,  -1 },\n\t{             662,\t    STRING,\t 76,  -1 },\n\t{             668,\t    STRING,\t 77,  -1 },\n\t{             674,\t    STRING,\t 78,  -1 },\n\t{             679,\t    STRING,\t 79,  -1 },\n\t{             685,\t    STRING,\t 80,  -1 },\n\t{             689,\t    STRING,\t 81,  -1 },\n\t{             693,\t    STRING,\t 82,  -1 },\n\t{             697,\t    STRING,\t 83,  -1 },\n\t{             703,\t    STRING,\t 84,  55 },\n\t{             708,\t    STRING,\t 85, 105 },\n\t{             712,\t    STRING,\t 86,  -1 },\n\t{             717,\t    STRING,\t 87,  81 },\n\t{             723,\t    STRING,\t 88,  -1 },\n\t{             728,\t    STRING,\t 89,  -1 },\n\t{             733,\t    STRING,\t 90,  -1 },\n\t{             737,\t    STRING,\t 91,  -1 },\n\t{             741,\t    STRING,\t 92,  -1 },\n\t{             746,\t    STRING,\t 93,  -1 },\n\t{             750,\t    STRING,\t 94,  33 },\n\t{             754,\t    STRING,\t 95,  -1 },\n\t{             758,\t    STRING,\t 96,  -1 },\n\t{             762,\t    STRING,\t 97,  -1 },\n\t{             766,\t    STRING,\t 98,   7 },\n\t{             770,\t    STRING,\t 99,  94 },\n\t{             774,\t    STRING,\t100,  -1 },\n\t{             778,\t    STRING,\t101, 131 },\n\t{             782,\t    STRING,\t102,  -1 },\n\t{             786,\t    STRING,\t103,  -1 },\n\t{             790,\t    STRING,\t104,  30 },\n\t{             794,\t    STRING,\t105,  -1 },\n\t{             798,\t    STRING,\t106,  -1 },\n\t{             801,\t    STRING,\t107,  -1 },\n\t{             805,\t    STRING,\t108,  -1 },\n\t{             809,\t    STRING,\t109,  -1 },\n\t{             814,\t    STRING,\t110,  -1 },\n\t{             817,\t    STRING,\t111,  -1 },\n\t{             821,\t    STRING,\t112, 156 },\n\t{             825,\t    STRING,\t113,  -1 },\n\t{             829,\t    STRING,\t114,  -1 },\n\t{             833,\t    STRING,\t115,  51 },\n\t{             839,\t    STRING,\t116,  -1 },\n\t{             845,\t    STRING,\t117,  -1 },\n\t{             849,\t    STRING,\t118,  -1 },\n\t{             853,\t    STRING,\t119,  -1 },\n\t{             857,\t    STRING,\t120,  -1 },\n\t{             861,\t    STRING,\t121,  -1 },\n\t{             865,\t    STRING,\t122,  -1 },\n\t{             869,\t    STRING,\t123,  -1 },\n\t{             873,\t    STRING,\t124, 126 },\n\t{             877,\t    STRING,\t125,  -1 },\n\t{             880,\t    STRING,\t126,  -1 },\n\t{             883,\t    STRING,\t127,  -1 },\n\t{             887,\t    STRING,\t128,  -1 },\n\t{             890,\t    STRING,\t129,  -1 },\n\t{             894,\t    STRING,\t130,  -1 },\n\t{             897,\t    STRING,\t131,  -1 },\n\t{             901,\t    STRING,\t132,  -1 },\n\t{             905,\t    STRING,\t133,  -1 },\n\t{             910,\t    STRING,\t134,  -1 },\n\t{             913,\t    STRING,\t135,  -1 },\n\t{             917,\t    STRING,\t136,  23 },\n\t{             920,\t    STRING,\t137,  -1 },\n\t{             923,\t    STRING,\t138,  -1 },\n\t{             929,\t    STRING,\t139,  -1 },\n\t{             933,\t    STRING,\t140,  -1 },\n\t{             937,\t    STRING,\t141, 210 },\n\t{             941,\t    STRING,\t142, 211 },\n\t{             945,\t    STRING,\t143, 135 },\n\t{             949,\t    STRING,\t144,  -1 },\n\t{             954,\t    STRING,\t145,  -1 },\n\t{             958,\t    STRING,\t146, 176 },\n\t{             963,\t    STRING,\t147,  -1 },\n\t{             967,\t    STRING,\t148, 194 },\n\t{             972,\t    STRING,\t149,  -1 },\n\t{             978,\t    STRING,\t150,  -1 },\n\t{             984,\t    STRING,\t151, 137 },\n\t{             989,\t    STRING,\t152,  -1 },\n\t{             994,\t    STRING,\t153,  -1 },\n\t{             999,\t    STRING,\t154,  -1 },\n\t{            1005,\t    STRING,\t155,  -1 },\n\t{            1011,\t    STRING,\t156,  -1 },\n\t{            1016,\t    STRING,\t157,  -1 },\n\t{            1021,\t    STRING,\t158,  -1 },\n\t{            1026,\t    STRING,\t159,  -1 },\n\t{            1031,\t    STRING,\t160,  -1 },\n\t{            1036,\t    STRING,\t161,  -1 },\n\t{            1041,\t    STRING,\t162,  -1 },\n\t{            1046,\t    STRING,\t163,  54 },\n\t{            1051,\t    STRING,\t164, 192 },\n\t{            1056,\t    STRING,\t165,  -1 },\n\t{            1061,\t    STRING,\t166,  -1 },\n\t{            1066,\t    STRING,\t167, 193 },\n\t{            1071,\t    STRING,\t168,  -1 },\n\t{            1076,\t    STRING,\t169,  70 },\n\t{            1081,\t    STRING,\t170, 235 },\n\t{            1086,\t    STRING,\t171,  -1 },\n\t{            1091,\t    STRING,\t172,  -1 },\n\t{            1096,\t    STRING,\t173, 177 },\n\t{            1101,\t    STRING,\t174,  -1 },\n\t{            1106,\t    STRING,\t175,  -1 },\n\t{            1111,\t    STRING,\t176,  -1 },\n\t{            1116,\t    STRING,\t177,  -1 },\n\t{            1121,\t    STRING,\t178,  -1 },\n\t{            1126,\t    STRING,\t179, 239 },\n\t{            1131,\t    STRING,\t180, 219 },\n\t{            1136,\t    STRING,\t181,  80 },\n\t{            1141,\t    STRING,\t182, 249 },\n\t{            1146,\t    STRING,\t183, 252 },\n\t{            1151,\t    STRING,\t184, 240 },\n\t{            1156,\t    STRING,\t185, 254 },\n\t{            1161,\t    STRING,\t186,  -1 },\n\t{            1166,\t    STRING,\t187,  -1 },\n\t{            1171,\t    STRING,\t188, 101 },\n\t{            1176,\t    STRING,\t189,  -1 },\n\t{            1181,\t    STRING,\t190,  -1 },\n\t{            1186,\t    STRING,\t191,  -1 },\n\t{            1190,\t    STRING,\t192,  -1 },\n\t{            1194,\t    STRING,\t193, 244 },\n\t{            1199,\t    STRING,\t194,  -1 },\n\t{            1204,\t    STRING,\t195, 152 },\n\t{            1209,\t    STRING,\t196,  -1 },\n\t{            1214,\t    STRING,\t197, 150 },\n\t{            1219,\t    STRING,\t198,  -1 },\n\t{            1224,\t    STRING,\t199, 268 },\n\t{            1229,\t    STRING,\t200,  -1 },\n\t{            1233,\t    STRING,\t201,  72 },\n\t{            1238,\t    STRING,\t202,  -1 },\n\t{            1243,\t    STRING,\t203,  -1 },\n\t{            1248,\t    STRING,\t204,  -1 },\n\t{            1253,\t    STRING,\t205,  -1 },\n\t{            1258,\t    STRING,\t206,  -1 },\n\t{            1263,\t    STRING,\t207, 196 },\n\t{            1268,\t    STRING,\t208,  -1 },\n\t{            1273,\t    STRING,\t209,  -1 },\n\t{            1278,\t    STRING,\t210,  -1 },\n\t{            1283,\t    STRING,\t211,  -1 },\n\t{            1288,\t    STRING,\t212, 281 },\n\t{            1293,\t    STRING,\t213, 272 },\n\t{            1298,\t    STRING,\t214, 283 },\n\t{            1303,\t    STRING,\t215,  -1 },\n\t{            1307,\t    STRING,\t216,  -1 },\n\t{            1312,\t    STRING,\t217, 134 },\n\t{            1317,\t    STRING,\t218,  -1 },\n\t{            1322,\t    STRING,\t219,  -1 },\n\t{            1327,\t    STRING,\t220,  -1 },\n\t{            1332,\t    STRING,\t221,  43 },\n\t{            1337,\t    STRING,\t222, 256 },\n\t{            1342,\t    STRING,\t223,  -1 },\n\t{            1347,\t    STRING,\t224,  -1 },\n\t{            1352,\t    STRING,\t225, 286 },\n\t{            1357,\t    STRING,\t226, 287 },\n\t{            1362,\t    STRING,\t227, 288 },\n\t{            1367,\t    STRING,\t228, 289 },\n\t{            1372,\t    STRING,\t229, 290 },\n\t{            1377,\t    STRING,\t230, 291 },\n\t{            1382,\t    STRING,\t231, 292 },\n\t{            1387,\t    STRING,\t232, 293 },\n\t{            1392,\t    STRING,\t233, 294 },\n\t{            1397,\t    STRING,\t234, 133 },\n\t{            1402,\t    STRING,\t235, 296 },\n\t{            1407,\t    STRING,\t236, 297 },\n\t{            1412,\t    STRING,\t237, 298 },\n\t{            1417,\t    STRING,\t238, 299 },\n\t{            1422,\t    STRING,\t239, 300 },\n\t{            1427,\t    STRING,\t240, 301 },\n\t{            1432,\t    STRING,\t241, 302 },\n\t{            1437,\t    STRING,\t242, 303 },\n\t{            1442,\t    STRING,\t243, 304 },\n\t{            1447,\t    STRING,\t244, 257 },\n\t{            1452,\t    STRING,\t245, 306 },\n\t{            1457,\t    STRING,\t246, 307 },\n\t{            1462,\t    STRING,\t247, 308 },\n\t{            1467,\t    STRING,\t248, 309 },\n\t{            1472,\t    STRING,\t249, 310 },\n\t{            1477,\t    STRING,\t250, 311 },\n\t{            1482,\t    STRING,\t251, 312 },\n\t{            1487,\t    STRING,\t252, 313 },\n\t{            1492,\t    STRING,\t253, 314 },\n\t{            1497,\t    STRING,\t254, 226 },\n\t{            1502,\t    STRING,\t255, 316 },\n\t{            1507,\t    STRING,\t256, 317 },\n\t{            1512,\t    STRING,\t257, 318 },\n\t{            1517,\t    STRING,\t258, 319 },\n\t{            1522,\t    STRING,\t259, 320 },\n\t{            1527,\t    STRING,\t260, 321 },\n\t{            1532,\t    STRING,\t261, 322 },\n\t{            1537,\t    STRING,\t262, 323 },\n\t{            1542,\t    STRING,\t263, 324 },\n\t{            1547,\t    STRING,\t264, 258 },\n\t{            1552,\t    STRING,\t265, 326 },\n\t{            1557,\t    STRING,\t266, 327 },\n\t{            1562,\t    STRING,\t267, 328 },\n\t{            1567,\t    STRING,\t268, 329 },\n\t{            1572,\t    STRING,\t269,  -1 },\n\t{            1576,\t    STRING,\t270,  -1 },\n\t{            1580,\t    STRING,\t271, 335 },\n\t{            1585,\t    STRING,\t272, 332 },\n\t{            1590,\t    STRING,\t273,  -1 },\n\t{            1594,\t    STRING,\t274,  -1 },\n\t{            1599,\t    STRING,\t275,  -1 },\n\t{            1604,\t    STRING,\t276,  -1 },\n\t{            1610,\t    STRING,\t277,  37 },\n\t{            1615,\t    STRING,\t278,  -1 },\n\t{            1621,\t    STRING,\t279,  -1 },\n\t{            1625,\t    STRING,\t280,  -1 },\n\t{            1630,\t    STRING,\t281,  -1 },\n\t{            1636,\t    STRING,\t282,  -1 },\n\t{            1641,\t    STRING,\t283,  -1 },\n\t{            1647,\t    STRING,\t284,  -1 },\n\t{            1652,\t    STRING,\t285,   8 },\n\t{            1658,\t    STRING,\t286, 262 },\n\t{            1663,\t    STRING,\t287,  -1 },\n\t{            1666,\t    STRING,\t288,  -1 },\n\t{            1669,\t    STRING,\t289,  -1 },\n\t{            1672,\t    STRING,\t290,  -1 },\n\t{            1675,\t    STRING,\t291,  -1 },\n\t{            1678,\t    STRING,\t292,  -1 },\n\t{            1681,\t    STRING,\t293,  -1 },\n\t{            1684,\t    STRING,\t294,  -1 },\n\t{            1687,\t    STRING,\t295,  -1 },\n\t{            1690,\t    STRING,\t296,  -1 },\n\t{            1693,\t    STRING,\t297,  -1 },\n\t{            1696,\t    STRING,\t298,  -1 },\n\t{            1699,\t    STRING,\t299,  -1 },\n\t{            1705,\t    STRING,\t300,  -1 },\n\t{            1711,\t    STRING,\t301,  -1 },\n\t{            1715,\t    STRING,\t302, 325 },\n\t{            1720,\t    STRING,\t303, 221 },\n\t{            1725,\t    STRING,\t304, 243 },\n\t{            1729,\t    STRING,\t305,  -1 },\n\t{            1733,\t    STRING,\t306, 250 },\n\t{            1737,\t    STRING,\t307,  -1 },\n\t{            1741,\t    STRING,\t308, 141 },\n\t{            1746,\t    STRING,\t309, 248 },\n\t{            1752,\t    STRING,\t310, 218 },\n\t{            1758,\t    STRING,\t311,  -1 },\n\t{            1763,\t    STRING,\t312, 201 },\n\t{            1767,\t    STRING,\t313, 229 },\n\t{            1773,\t    STRING,\t314, 264 },\n\t{            1778,\t    STRING,\t315, 253 },\n\t{            1784,\t    STRING,\t316, 334 },\n\t{            1789,\t    STRING,\t317,  -1 },\n\t{            1795,\t    STRING,\t318, 236 },\n\t{            1801,\t    STRING,\t319, 185 },\n\t{            1805,\t    STRING,\t320,  -1 },\n\t{            1811,\t    STRING,\t321,  -1 },\n\t{            1816,\t    STRING,\t322,  -1 },\n\t{            1820,\t    STRING,\t323,  -1 },\n\t{            1826,\t    STRING,\t324, 112 },\n\t{            1831,\t    STRING,\t325,  -1 },\n\t{            1837,\t    STRING,\t326,  -1 },\n\t{            1843,\t    STRING,\t327,  -1 },\n\t{            1847,\t    STRING,\t328,  -1 },\n\t{            1852,\t    STRING,\t329,  -1 },\n\t{            1858,\t    STRING,\t330,  -1 },\n\t{            1864,\t    STRING,\t331,  53 },\n\t{            1870,\t    STRING,\t332,  -1 },\n\t{            1875,\t    STRING,\t333,  47 },\n\t{            1881,\t    STRING,\t334, 155 },\n\t{            1888,\t    STRING,\t335,  -1 },\n\t{            1893,\t    STRING,\t336,  -1 },\n\t{            1898,\t    STRING,\t337,  -1 },\n\t{            1903,\t    STRING,\t338,  -1 },\n\t{            1908,\t    STRING,\t339,  -1 },\n\t{            1912,\t    STRING,\t340,  -1 },\n\t{            1917,\t    STRING,\t341, 383 },\n\t{            1923,\t    STRING,\t342,  -1 },\n\t{            1929,\t    STRING,\t343,  -1 },\n\t{            1935,\t    STRING,\t344, 386 },\n\t{            1940,\t    STRING,\t345, 238 },\n\t{            1946,\t    STRING,\t346,  -1 },\n\t{            1951,\t    STRING,\t347, 344 },\n\t{            1956,\t    STRING,\t348,  31 },\n\t{            1961,\t    STRING,\t349,  -1 },\n\t{            1966,\t    STRING,\t350, 380 },\n\t{            1972,\t    STRING,\t351, 255 },\n\t{            1978,\t    STRING,\t352,  -1 },\n\t{            1983,\t    STRING,\t353,  -1 },\n\t{            1989,\t    STRING,\t354, 347 },\n\t{            1994,\t    STRING,\t355,  -1 },\n\t{            2000,\t    STRING,\t356,  -1 },\n\t{            2006,\t    STRING,\t357,  -1 },\n\t{            2012,\t    STRING,\t358,  87 },\n\t{            2017,\t    STRING,\t359,  -1 },\n\t{            2023,\t    STRING,\t360,  -1 },\n\t{            2029,\t    STRING,\t361,  -1 },\n\t{            2034,\t    STRING,\t362,  -1 },\n\t{            2039,\t    STRING,\t363,  -1 },\n\t{            2044,\t    STRING,\t364,  -1 },\n\t{            2049,\t    STRING,\t365, 212 },\n\t{            2054,\t    STRING,\t366, 109 },\n\t{            2059,\t    STRING,\t367, 213 },\n\t{            2064,\t    STRING,\t368, 230 },\n\t{            2070,\t    STRING,\t369,  -1 },\n\t{            2076,\t    STRING,\t370,  -1 },\n\t{            2082,\t    STRING,\t371,  -1 },\n\t{            2088,\t    STRING,\t372,  -1 },\n\t{            2093,\t    STRING,\t373,  -1 },\n\t{            2101,\t    STRING,\t374,  -1 },\n\t{            2107,\t    STRING,\t375,  -1 },\n\t{            2113,\t    STRING,\t376,  -1 },\n\t{            2122,\t    STRING,\t377, 116 },\n\t{            2129,\t    STRING,\t378,  -1 },\n\t{            2135,\t    STRING,\t379, 231 },\n\t{            2141,\t    STRING,\t380,  -1 },\n\t{            2147,\t    STRING,\t381, 338 },\n\t{            2152,\t    STRING,\t382,  -1 },\n\t{            2157,\t    STRING,\t383,  -1 },\n\t{            2163,\t    STRING,\t384, 197 },\n\t{            2169,\t    STRING,\t385, 430 },\n\t{            2175,\t    STRING,\t386,  -1 },\n\t{            2181,\t    STRING,\t387,  -1 },\n\t{            2187,\t    STRING,\t388,  -1 },\n\t{            2194,\t    STRING,\t389,  -1 },\n\t{            2200,\t    STRING,\t390,  -1 },\n\t{            2206,\t    STRING,\t391,  -1 },\n\t{            2212,\t    STRING,\t392, 437 },\n\t{            2217,\t    STRING,\t393,  -1 },\n\t{            2225,\t    STRING,\t394,  -1 },\n\t{            2230,\t    STRING,\t395,  -1 },\n\t{            2235,\t    NUMBER,\t 33,  -1 },\n\t{            2240,\t   BOOLEAN,\t 37,  -1 },\n\t{            2245,\t   BOOLEAN,\t 38,  -1 },\n\t{            2250,\t   BOOLEAN,\t 39,  -1 },\n\t{            2255,\t    NUMBER,\t 34,  -1 },\n\t{            2260,\t    NUMBER,\t 35,  -1 },\n\t{            2265,\t    STRING,\t396,  -1 },\n\t{            2270,\t    STRING,\t397,  13 },\n\t{            2275,\t   BOOLEAN,\t 40,  -1 },\n\t{            2280,\t   BOOLEAN,\t 41, 446 },\n\t{            2285,\t    NUMBER,\t 36,  -1 },\n\t{            2290,\t    NUMBER,\t 37,  -1 },\n\t{            2295,\t    NUMBER,\t 38,  -1 },\n\t{            2300,\t    STRING,\t398, 472 },\n\t{            2305,\t    STRING,\t399,  -1 },\n\t{            2310,\t   BOOLEAN,\t 42,  -1 },\n\t{            2315,\t   BOOLEAN,\t 43,  -1 },\n\t{            2320,\t    STRING,\t400,  -1 },\n\t{            2325,\t    STRING,\t401,  -1 },\n\t{            2330,\t    STRING,\t402,  -1 },\n\t{            2335,\t    STRING,\t403,  -1 },\n\t{            2340,\t    STRING,\t404,  -1 },\n\t{            2345,\t    STRING,\t405,  -1 },\n\t{            2350,\t    STRING,\t406,  -1 },\n\t{            2355,\t    STRING,\t407,  -1 },\n\t{            2360,\t    STRING,\t408,  26 },\n\t{            2365,\t    STRING,\t409,  60 },\n\t{            2370,\t    STRING,\t410, 121 },\n\t{            2375,\t    STRING,\t411, 407 },\n\t{            2380,\t    STRING,\t412, 402 },\n\t{            2385,\t    STRING,\t413,  -1 } \n};\n\nstatic struct name_table_entry *_nc_info_table = 0;\n\nstatic const HashValue _nc_info_hash_table[995] =\n{\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t465,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t261,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t457,\n\t -1,\n\t -1,\n\t265,\n\t216,\n\t120,\n\t -1,\n\t -1,\n\t -1,\n\t180,\n\t -1,\n\t -1,\n\t 88,\n\t -1,\n\t420,\n\t -1,\n\t398,\n\t -1,\n\t348,\n\t -1,\n\t -1,\n\t 19,\n\t -1,\n\t -1,\n\t -1,\n\t359,\n\t -1,\n\t174,\n\t -1,\n\t245,\n\t -1,\n\t 74,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t269,\n\t -1,\n\t480,\n\t -1,\n\t -1,\n\t -1,\n\t124,\n\t -1,\n\t -1,\n\t -1,\n\t390,\n\t379,\n\t367,\n\t -1,\n\t -1,\n\t444,\n\t -1,\n\t -1,\n\t -1,\n\t305,\n\t -1,\n\t -1,\n\t363,\n\t -1,\n\t -1,\n\t483,\n\t377,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t460,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t204,\n\t 38,\n\t -1,\n\t 82,\n\t -1,\n\t110,\n\t127,\n\t -1,\n\t -1,\n\t463,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t336,\n\t -1,\n\t 17,\n\t128,\n\t434,\n\t -1,\n\t188,\n\t129,\n\t -1,\n\t351,\n\t -1,\n\t -1,\n\t 16,\n\t -1,\n\t -1,\n\t259,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t489,\n\t -1,\n\t353,\n\t -1,\n\t 71,\n\t247,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 78,\n\t -1,\n\t -1,\n\t331,\n\t -1,\n\t -1,\n\t173,\n\t136,\n\t161,\n\t189,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t454,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t224,\n\t479,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t354,\n\t -1,\n\t -1,\n\t233,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t125,\n\t 11,\n\t -1,\n\t -1,\n\t378,\n\t166,\n\t -1,\n\t191,\n\t -1,\n\t -1,\n\t 48,\n\t228,\n\t -1,\n\t  2,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t374,\n\t -1,\n\t408,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t375,\n\t -1,\n\t 52,\n\t145,\n\t170,\n\t -1,\n\t392,\n\t382,\n\t -1,\n\t393,\n\t411,\n\t -1,\n\t -1,\n\t -1,\n\t276,\n\t -1,\n\t -1,\n\t 35,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t396,\n\t388,\n\t 36,\n\t -1,\n\t -1,\n\t 64,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t350,\n\t -1,\n\t -1,\n\t215,\n\t 91,\n\t -1,\n\t -1,\n\t439,\n\t -1,\n\t122,\n\t -1,\n\t200,\n\t -1,\n\t 67,\n\t -1,\n\t410,\n\t -1,\n\t -1,\n\t 89,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 96,\n\t 21,\n\t -1,\n\t103,\n\t  1,\n\t -1,\n\t -1,\n\t369,\n\t -1,\n\t -1,\n\t345,\n\t -1,\n\t -1,\n\t -1,\n\t355,\n\t 40,\n\t -1,\n\t 27,\n\t -1,\n\t406,\n\t -1,\n\t -1,\n\t -1,\n\t482,\n\t419,\n\t417,\n\t -1,\n\t -1,\n\t360,\n\t270,\n\t -1,\n\t -1,\n\t251,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t349,\n\t -1,\n\t -1,\n\t278,\n\t -1,\n\t442,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t438,\n\t -1,\n\t494,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t315,\n\t -1,\n\t340,\n\t364,\n\t356,\n\t -1,\n\t484,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 32,\n\t -1,\n\t -1,\n\t -1,\n\t260,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t207,\n\t487,\n\t 84,\n\t453,\n\t -1,\n\t -1,\n\t413,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t214,\n\t -1,\n\t337,\n\t352,\n\t477,\n\t -1,\n\t435,\n\t 56,\n\t -1,\n\t -1,\n\t 34,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t132,\n\t -1,\n\t 85,\n\t492,\n\t428,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t199,\n\t -1,\n\t342,\n\t -1,\n\t -1,\n\t -1,\n\t138,\n\t163,\n\t190,\n\t147,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t266,\n\t -1,\n\t -1,\n\t433,\n\t -1,\n\t -1,\n\t474,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t385,\n\t100,\n\t -1,\n\t -1,\n\t -1,\n\t431,\n\t -1,\n\t391,\n\t381,\n\t 12,\n\t 58,\n\t -1,\n\t142,\n\t167,\n\t -1,\n\t -1,\n\t409,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 42,\n\t 45,\n\t 66,\n\t -1,\n\t -1,\n\t424,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t220,\n\t376,\n\t -1,\n\t -1,\n\t343,\n\t -1,\n\t -1,\n\t -1,\n\t114,\n\t106,\n\t -1,\n\t -1,\n\t447,\n\t -1,\n\t217,\n\t493,\n\t171,\n\t172,\n\t399,\n\t346,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t195,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t496,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t241,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t151,\n\t -1,\n\t118,\n\t -1,\n\t 62,\n\t187,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t234,\n\t -1,\n\t443,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t357,\n\t -1,\n\t -1,\n\t -1,\n\t246,\n\t -1,\n\t -1,\n\t -1,\n\t448,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 39,\n\t -1,\n\t 10,\n\t397,\n\t389,\n\t -1,\n\t -1,\n\t154,\n\t -1,\n\t -1,\n\t -1,\n\t130,\n\t -1,\n\t 22,\n\t222,\n\t373,\n\t162,\n\t -1,\n\t361,\n\t203,\n\t -1,\n\t -1,\n\t242,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t459,\n\t -1,\n\t -1,\n\t271,\n\t -1,\n\t 97,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t427,\n\t -1,\n\t175,\n\t107,\n\t -1,\n\t -1,\n\t -1,\n\t178,\n\t423,\n\t372,\n\t 69,\n\t -1,\n\t365,\n\t -1,\n\t  4,\n\t486,\n\t184,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t461,\n\t -1,\n\t -1,\n\t282,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t475,\n\t -1,\n\t -1,\n\t -1,\n\t395,\n\t387,\n\t -1,\n\t -1,\n\t 79,\n\t 63,\n\t -1,\n\t -1,\n\t452,\n\t451,\n\t -1,\n\t 50,\n\t -1,\n\t436,\n\t -1,\n\t -1,\n\t285,\n\t -1,\n\t -1,\n\t 83,\n\t455,\n\t -1,\n\t -1,\n\t -1,\n\t279,\n\t370,\n\t -1,\n\t -1,\n\t -1,\n\t 18,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t421,\n\t -1,\n\t495,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t227,\n\t333,\n\t -1,\n\t -1,\n\t 25,\n\t139,\n\t164,\n\t -1,\n\t -1,\n\t371,\n\t -1,\n\t -1,\n\t429,\n\t -1,\n\t -1,\n\t -1,\n\t273,\n\t -1,\n\t466,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t181,\n\t -1,\n\t -1,\n\t 75,\n\t -1,\n\t 92,\n\t339,\n\t -1,\n\t384,\n\t -1,\n\t123,\n\t -1,\n\t143,\n\t168,\n\t -1,\n\t183,\n\t186,\n\t -1,\n\t108,\n\t 95,\n\t368,\n\t -1,\n\t -1,\n\t277,\n\t198,\n\t -1,\n\t206,\n\t432,\n\t -1,\n\t476,\n\t -1,\n\t458,\n\t -1,\n\t -1,\n\t182,\n\t -1,\n\t441,\n\t -1,\n\t -1,\n\t -1,\n\t115,\n\t113,\n\t404,\n\t -1,\n\t473,\n\t -1,\n\t -1,\n\t -1,\n\t490,\n\t104,\n\t -1,\n\t -1,\n\t450,\n\t449,\n\t -1,\n\t -1,\n\t -1,\n\t274,\n\t -1,\n\t481,\n\t111,\n\t 99,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t263,\n\t 93,\n\t -1,\n\t117,\n\t -1,\n\t 29,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t119,\n\t -1,\n\t -1,\n\t426,\n\t491,\n\t -1,\n\t -1,\n\t205,\n\t -1,\n\t237,\n\t 44,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t418,\n\t416,\n\t -1,\n\t -1,\n\t358,\n\t -1,\n\t -1,\n\t -1,\n\t 65,\n\t -1,\n\t440,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t  5,\n\t -1,\n\t -1,\n\t -1,\n\t488,\n\t -1,\n\t -1,\n\t -1,\n\t 28,\n\t412,\n\t -1,\n\t405,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t295,\n\t -1,\n\t471,\n\t362,\n\t -1,\n\t -1,\n\t485,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t202,\n\t -1,\n\t -1,\n\t284,\n\t -1,\n\t469,\n\t -1,\n\t -1,\n\t  9,\n\t 24,\n\t -1,\n\t -1,\n\t179,\n\t -1,\n\t -1,\n\t 15,\n\t -1,\n\t -1,\n\t148,\n\t -1,\n\t -1,\n\t -1,\n\t341,\n\t -1,\n\t -1,\n\t366,\n\t209,\n\t223,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t  0,\n\t -1,\n\t208,\n\t467,\n\t -1,\n\t422,\n\t -1,\n\t464,\n\t157,\n\t -1,\n\t403,\n\t -1,\n\t415,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t445,\n\t -1,\n\t -1,\n\t330,\n\t -1,\n\t -1,\n\t -1,\n\t462,\n\t160,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 86,\n\t -1,\n\t -1,\n\t 41,\n\t -1,\n\t280,\n\t -1,\n\t478,\n\t -1,\n\t -1,\n\t 57,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t394,\n\t414,\n\t -1,\n\t -1,\n\t -1,\n\t140,\n\t165,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t275,\n\t102,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t232,\n\t -1,\n\t 14,\n\t -1,\n\t -1,\n\t225,\n\t -1,\n\t -1,\n\t267,\n\t -1,\n\t 77,\n\t -1,\n\t144,\n\t169,\n\t -1,\n\t149,\n\t -1,\n\t400,\n\t -1,\n\t -1,\n\t -1,\n\t  3,\n\t -1,\n\t -1,\n\t -1,\n\t468,\n\t425,\n\t -1,\n\t -1,\n\t470,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t456,\n\t -1,\n\t158,\n\t159,\n\t -1,\n\t -1,\n\t146,\n\t 49,\n\t -1,\n\t -1,\n\t153,\n\t -1,\n\t401,\n\t 90,\n\t0\t/* base-of-table */\n};\n\n#if (BOOLCOUNT!=44)||(NUMCOUNT!=39)||(STRCOUNT!=414)\n#error\t--> term.h and comp_captab.c disagree about the <--\n#error\t--> numbers of booleans, numbers and/or strings <--\n#endif\n\n/* 103 collisions out of 497 entries */\nstatic const char cap_names_text[] = \\\n\"bw\\0\" \"am\\0\" \"xb\\0\" \"xs\\0\" \"xn\\0\" \"eo\\0\" \"gn\\0\" \"hc\\0\" \"km\\0\" \"hs\\0\" \\\n\"in\\0\" \"da\\0\" \"db\\0\" \"mi\\0\" \"ms\\0\" \"os\\0\" \"es\\0\" \"xt\\0\" \"hz\\0\" \"ul\\0\" \\\n\"xo\\0\" \"nx\\0\" \"5i\\0\" \"HC\\0\" \"NR\\0\" \"NP\\0\" \"ND\\0\" \"cc\\0\" \"ut\\0\" \"hl\\0\" \\\n\"YA\\0\" \"YB\\0\" \"YC\\0\" \"YD\\0\" \"YE\\0\" \"YF\\0\" \"YG\\0\" \"co\\0\" \"it\\0\" \"li\\0\" \\\n\"lm\\0\" \"sg\\0\" \"pb\\0\" \"vt\\0\" \"ws\\0\" \"Nl\\0\" \"lh\\0\" \"lw\\0\" \"ma\\0\" \"MW\\0\" \\\n\"Co\\0\" \"pa\\0\" \"NC\\0\" \"Ya\\0\" \"Yb\\0\" \"Yc\\0\" \"Yd\\0\" \"Ye\\0\" \"Yf\\0\" \"Yg\\0\" \\\n\"Yh\\0\" \"Yi\\0\" \"Yj\\0\" \"Yk\\0\" \"Yl\\0\" \"Ym\\0\" \"Yn\\0\" \"BT\\0\" \"Yo\\0\" \"Yp\\0\" \\\n\"bt\\0\" \"bl\\0\" \"cr\\0\" \"cs\\0\" \"ct\\0\" \"cl\\0\" \"ce\\0\" \"cd\\0\" \"ch\\0\" \"CC\\0\" \\\n\"cm\\0\" \"do\\0\" \"ho\\0\" \"vi\\0\" \"le\\0\" \"CM\\0\" \"ve\\0\" \"nd\\0\" \"ll\\0\" \"up\\0\" \\\n\"vs\\0\" \"dc\\0\" \"dl\\0\" \"ds\\0\" \"hd\\0\" \"as\\0\" \"mb\\0\" \"md\\0\" \"ti\\0\" \"dm\\0\" \\\n\"mh\\0\" \"im\\0\" \"mk\\0\" \"mp\\0\" \"mr\\0\" \"so\\0\" \"us\\0\" \"ec\\0\" \"ae\\0\" \"me\\0\" \\\n\"te\\0\" \"ed\\0\" \"ei\\0\" \"se\\0\" \"ue\\0\" \"vb\\0\" \"ff\\0\" \"fs\\0\" \"i1\\0\" \"is\\0\" \\\n\"i3\\0\" \"if\\0\" \"ic\\0\" \"al\\0\" \"ip\\0\" \"kb\\0\" \"ka\\0\" \"kC\\0\" \"kt\\0\" \"kD\\0\" \\\n\"kL\\0\" \"kd\\0\" \"kM\\0\" \"kE\\0\" \"kS\\0\" \"k0\\0\" \"k1\\0\" \"k;\\0\" \"k2\\0\" \"k3\\0\" \\\n\"k4\\0\" \"k5\\0\" \"k6\\0\" \"k7\\0\" \"k8\\0\" \"k9\\0\" \"kh\\0\" \"kI\\0\" \"kA\\0\" \"kl\\0\" \\\n\"kH\\0\" \"kN\\0\" \"kP\\0\" \"kr\\0\" \"kF\\0\" \"kR\\0\" \"kT\\0\" \"ku\\0\" \"ke\\0\" \"ks\\0\" \\\n\"l0\\0\" \"l1\\0\" \"la\\0\" \"l2\\0\" \"l3\\0\" \"l4\\0\" \"l5\\0\" \"l6\\0\" \"l7\\0\" \"l8\\0\" \\\n\"l9\\0\" \"mo\\0\" \"mm\\0\" \"nw\\0\" \"pc\\0\" \"DC\\0\" \"DL\\0\" \"DO\\0\" \"IC\\0\" \"SF\\0\" \\\n\"AL\\0\" \"LE\\0\" \"RI\\0\" \"SR\\0\" \"UP\\0\" \"pk\\0\" \"pl\\0\" \"px\\0\" \"ps\\0\" \"pf\\0\" \\\n\"po\\0\" \"rp\\0\" \"r1\\0\" \"r2\\0\" \"r3\\0\" \"rf\\0\" \"rc\\0\" \"cv\\0\" \"sc\\0\" \"sf\\0\" \\\n\"sr\\0\" \"sa\\0\" \"st\\0\" \"wi\\0\" \"ta\\0\" \"ts\\0\" \"uc\\0\" \"hu\\0\" \"iP\\0\" \"K1\\0\" \\\n\"K3\\0\" \"K2\\0\" \"K4\\0\" \"K5\\0\" \"pO\\0\" \"rP\\0\" \"ac\\0\" \"pn\\0\" \"kB\\0\" \"SX\\0\" \\\n\"RX\\0\" \"SA\\0\" \"RA\\0\" \"XN\\0\" \"XF\\0\" \"eA\\0\" \"LO\\0\" \"LF\\0\" \"@1\\0\" \"@2\\0\" \\\n\"@3\\0\" \"@4\\0\" \"@5\\0\" \"@6\\0\" \"@7\\0\" \"@8\\0\" \"@9\\0\" \"@0\\0\" \"%1\\0\" \"%2\\0\" \\\n\"%3\\0\" \"%4\\0\" \"%5\\0\" \"%6\\0\" \"%7\\0\" \"%8\\0\" \"%9\\0\" \"%0\\0\" \"&1\\0\" \"&2\\0\" \\\n\"&3\\0\" \"&4\\0\" \"&5\\0\" \"&6\\0\" \"&7\\0\" \"&8\\0\" \"&9\\0\" \"&0\\0\" \"*1\\0\" \"*2\\0\" \\\n\"*3\\0\" \"*4\\0\" \"*5\\0\" \"*6\\0\" \"*7\\0\" \"*8\\0\" \"*9\\0\" \"*0\\0\" \"#1\\0\" \"#2\\0\" \\\n\"#3\\0\" \"#4\\0\" \"%a\\0\" \"%b\\0\" \"%c\\0\" \"%d\\0\" \"%e\\0\" \"%f\\0\" \"%g\\0\" \"%h\\0\" \\\n\"%i\\0\" \"%j\\0\" \"!1\\0\" \"!2\\0\" \"!3\\0\" \"RF\\0\" \"F1\\0\" \"F2\\0\" \"F3\\0\" \"F4\\0\" \\\n\"F5\\0\" \"F6\\0\" \"F7\\0\" \"F8\\0\" \"F9\\0\" \"FA\\0\" \"FB\\0\" \"FC\\0\" \"FD\\0\" \"FE\\0\" \\\n\"FF\\0\" \"FG\\0\" \"FH\\0\" \"FI\\0\" \"FJ\\0\" \"FK\\0\" \"FL\\0\" \"FM\\0\" \"FN\\0\" \"FO\\0\" \\\n\"FP\\0\" \"FQ\\0\" \"FR\\0\" \"FS\\0\" \"FT\\0\" \"FU\\0\" \"FV\\0\" \"FW\\0\" \"FX\\0\" \"FY\\0\" \\\n\"FZ\\0\" \"Fa\\0\" \"Fb\\0\" \"Fc\\0\" \"Fd\\0\" \"Fe\\0\" \"Ff\\0\" \"Fg\\0\" \"Fh\\0\" \"Fi\\0\" \\\n\"Fj\\0\" \"Fk\\0\" \"Fl\\0\" \"Fm\\0\" \"Fn\\0\" \"Fo\\0\" \"Fp\\0\" \"Fq\\0\" \"Fr\\0\" \"cb\\0\" \\\n\"MC\\0\" \"ML\\0\" \"MR\\0\" \"Lf\\0\" \"SC\\0\" \"DK\\0\" \"RC\\0\" \"CW\\0\" \"WG\\0\" \"HU\\0\" \\\n\"DI\\0\" \"QD\\0\" \"TO\\0\" \"PU\\0\" \"fh\\0\" \"PA\\0\" \"WA\\0\" \"u0\\0\" \"u1\\0\" \"u2\\0\" \\\n\"u3\\0\" \"u4\\0\" \"u5\\0\" \"u6\\0\" \"u7\\0\" \"u8\\0\" \"u9\\0\" \"op\\0\" \"oc\\0\" \"Ic\\0\" \\\n\"Ip\\0\" \"sp\\0\" \"Sf\\0\" \"Sb\\0\" \"ZA\\0\" \"ZB\\0\" \"ZC\\0\" \"ZD\\0\" \"ZE\\0\" \"ZF\\0\" \\\n\"ZG\\0\" \"ZH\\0\" \"ZI\\0\" \"ZJ\\0\" \"ZK\\0\" \"ZL\\0\" \"ZM\\0\" \"ZN\\0\" \"ZO\\0\" \"ZP\\0\" \\\n\"ZQ\\0\" \"ZR\\0\" \"ZS\\0\" \"ZT\\0\" \"ZU\\0\" \"ZV\\0\" \"ZW\\0\" \"ZX\\0\" \"ZY\\0\" \"ZZ\\0\" \\\n\"Za\\0\" \"Zb\\0\" \"Zc\\0\" \"Zd\\0\" \"Ze\\0\" \"Zf\\0\" \"Zg\\0\" \"Zh\\0\" \"Zi\\0\" \"Zj\\0\" \\\n\"Zk\\0\" \"Zl\\0\" \"Zm\\0\" \"Zn\\0\" \"Zo\\0\" \"Zp\\0\" \"Zq\\0\" \"Zr\\0\" \"Zs\\0\" \"Zt\\0\" \\\n\"Zu\\0\" \"Zv\\0\" \"Zw\\0\" \"Zx\\0\" \"Zy\\0\" \"Km\\0\" \"Mi\\0\" \"RQ\\0\" \"Gm\\0\" \"AF\\0\" \\\n\"AB\\0\" \"xl\\0\" \"dv\\0\" \"ci\\0\" \"s0\\0\" \"s1\\0\" \"s2\\0\" \"s3\\0\" \"ML\\0\" \"MT\\0\" \\\n\"Xy\\0\" \"Zz\\0\" \"Yv\\0\" \"Yw\\0\" \"Yx\\0\" \"Yy\\0\" \"Yz\\0\" \"YZ\\0\" \"S1\\0\" \"S2\\0\" \\\n\"S3\\0\" \"S4\\0\" \"S5\\0\" \"S6\\0\" \"S7\\0\" \"S8\\0\" \"Xh\\0\" \"Xl\\0\" \"Xo\\0\" \"Xr\\0\" \\\n\"Xt\\0\" \"Xv\\0\" \"sA\\0\" \"YI\\0\" \"i2\\0\" \"rs\\0\" \"ug\\0\" \"bs\\0\" \"ns\\0\" \"nc\\0\" \\\n\"dC\\0\" \"dN\\0\" \"nl\\0\" \"bc\\0\" \"MT\\0\" \"NL\\0\" \"dB\\0\" \"dT\\0\" \"kn\\0\" \"ko\\0\" \\\n\"ma\\0\" \"pt\\0\" \"xr\\0\" \"G2\\0\" \"G3\\0\" \"G1\\0\" \"G4\\0\" \"GR\\0\" \"GL\\0\" \"GU\\0\" \\\n\"GD\\0\" \"GH\\0\" \"GV\\0\" \"GC\\0\" \"ml\\0\" \"mu\\0\" \"bx\\0\" ;\n\nstatic name_table_data const cap_names_data[] =\n{\n\t{               0,\t   BOOLEAN,\t  0,  -1 },\n\t{               3,\t   BOOLEAN,\t  1,  -1 },\n\t{               6,\t   BOOLEAN,\t  2,  -1 },\n\t{               9,\t   BOOLEAN,\t  3,  -1 },\n\t{              12,\t   BOOLEAN,\t  4,  -1 },\n\t{              15,\t   BOOLEAN,\t  5,  -1 },\n\t{              18,\t   BOOLEAN,\t  6,  -1 },\n\t{              21,\t   BOOLEAN,\t  7,  -1 },\n\t{              24,\t   BOOLEAN,\t  8,  -1 },\n\t{              27,\t   BOOLEAN,\t  9,  -1 },\n\t{              30,\t   BOOLEAN,\t 10,  -1 },\n\t{              33,\t   BOOLEAN,\t 11,  -1 },\n\t{              36,\t   BOOLEAN,\t 12,  -1 },\n\t{              39,\t   BOOLEAN,\t 13,  -1 },\n\t{              42,\t   BOOLEAN,\t 14,  -1 },\n\t{              45,\t   BOOLEAN,\t 15,  -1 },\n\t{              48,\t   BOOLEAN,\t 16,  -1 },\n\t{              51,\t   BOOLEAN,\t 17,  -1 },\n\t{              54,\t   BOOLEAN,\t 18,  -1 },\n\t{              57,\t   BOOLEAN,\t 19,  -1 },\n\t{              60,\t   BOOLEAN,\t 20,  -1 },\n\t{              63,\t   BOOLEAN,\t 21,  -1 },\n\t{              66,\t   BOOLEAN,\t 22,  -1 },\n\t{              69,\t   BOOLEAN,\t 23,  -1 },\n\t{              72,\t   BOOLEAN,\t 24,   1 },\n\t{              75,\t   BOOLEAN,\t 25,  -1 },\n\t{              78,\t   BOOLEAN,\t 26,  -1 },\n\t{              81,\t   BOOLEAN,\t 27,  -1 },\n\t{              84,\t   BOOLEAN,\t 28,  -1 },\n\t{              87,\t   BOOLEAN,\t 29,  -1 },\n\t{              90,\t   BOOLEAN,\t 30,  -1 },\n\t{              93,\t   BOOLEAN,\t 31,  -1 },\n\t{              96,\t   BOOLEAN,\t 32,  -1 },\n\t{              99,\t   BOOLEAN,\t 33,  -1 },\n\t{             102,\t   BOOLEAN,\t 34,  -1 },\n\t{             105,\t   BOOLEAN,\t 35,  -1 },\n\t{             108,\t   BOOLEAN,\t 36,  -1 },\n\t{             111,\t    NUMBER,\t  0,  -1 },\n\t{             114,\t    NUMBER,\t  1,  -1 },\n\t{             117,\t    NUMBER,\t  2,  -1 },\n\t{             120,\t    NUMBER,\t  3,  -1 },\n\t{             123,\t    NUMBER,\t  4,  -1 },\n\t{             126,\t    NUMBER,\t  5,  -1 },\n\t{             129,\t    NUMBER,\t  6,  -1 },\n\t{             132,\t    NUMBER,\t  7,  -1 },\n\t{             135,\t    NUMBER,\t  8,  -1 },\n\t{             138,\t    NUMBER,\t  9,  -1 },\n\t{             141,\t    NUMBER,\t 10,  -1 },\n\t{             144,\t    NUMBER,\t 11,  -1 },\n\t{             147,\t    NUMBER,\t 12,  -1 },\n\t{             150,\t    NUMBER,\t 13,  -1 },\n\t{             153,\t    NUMBER,\t 14,  -1 },\n\t{             156,\t    NUMBER,\t 15,  -1 },\n\t{             159,\t    NUMBER,\t 16,  -1 },\n\t{             162,\t    NUMBER,\t 17,  -1 },\n\t{             165,\t    NUMBER,\t 18,  -1 },\n\t{             168,\t    NUMBER,\t 19,  -1 },\n\t{             171,\t    NUMBER,\t 20,  -1 },\n\t{             174,\t    NUMBER,\t 21,  -1 },\n\t{             177,\t    NUMBER,\t 22,  -1 },\n\t{             180,\t    NUMBER,\t 23,  -1 },\n\t{             183,\t    NUMBER,\t 24,  -1 },\n\t{             186,\t    NUMBER,\t 25,  -1 },\n\t{             189,\t    NUMBER,\t 26,  -1 },\n\t{             192,\t    NUMBER,\t 27,  -1 },\n\t{             195,\t    NUMBER,\t 28,  -1 },\n\t{             198,\t    NUMBER,\t 29,  -1 },\n\t{             201,\t    NUMBER,\t 30,  -1 },\n\t{             204,\t    NUMBER,\t 31,  -1 },\n\t{             207,\t    NUMBER,\t 32,  -1 },\n\t{             210,\t    STRING,\t  0,  -1 },\n\t{             213,\t    STRING,\t  1,  -1 },\n\t{             216,\t    STRING,\t  2,  -1 },\n\t{             219,\t    STRING,\t  3,  -1 },\n\t{             222,\t    STRING,\t  4,  -1 },\n\t{             225,\t    STRING,\t  5,  -1 },\n\t{             228,\t    STRING,\t  6,  -1 },\n\t{             231,\t    STRING,\t  7,  -1 },\n\t{             234,\t    STRING,\t  8,  -1 },\n\t{             237,\t    STRING,\t  9,  -1 },\n\t{             240,\t    STRING,\t 10,  -1 },\n\t{             243,\t    STRING,\t 11,  -1 },\n\t{             246,\t    STRING,\t 12,  -1 },\n\t{             249,\t    STRING,\t 13,  -1 },\n\t{             252,\t    STRING,\t 14,  -1 },\n\t{             255,\t    STRING,\t 15,  -1 },\n\t{             258,\t    STRING,\t 16,  -1 },\n\t{             261,\t    STRING,\t 17,  -1 },\n\t{             264,\t    STRING,\t 18,  -1 },\n\t{             267,\t    STRING,\t 19,  -1 },\n\t{             270,\t    STRING,\t 20,  -1 },\n\t{             273,\t    STRING,\t 21,  -1 },\n\t{             276,\t    STRING,\t 22,  -1 },\n\t{             279,\t    STRING,\t 23,  -1 },\n\t{             282,\t    STRING,\t 24,  -1 },\n\t{             285,\t    STRING,\t 25,  -1 },\n\t{             288,\t    STRING,\t 26,  -1 },\n\t{             291,\t    STRING,\t 27,  -1 },\n\t{             294,\t    STRING,\t 28,  -1 },\n\t{             297,\t    STRING,\t 29,  -1 },\n\t{             300,\t    STRING,\t 30,  -1 },\n\t{             303,\t    STRING,\t 31,  -1 },\n\t{             306,\t    STRING,\t 32,  -1 },\n\t{             309,\t    STRING,\t 33,  -1 },\n\t{             312,\t    STRING,\t 34,  -1 },\n\t{             315,\t    STRING,\t 35,  -1 },\n\t{             318,\t    STRING,\t 36,  -1 },\n\t{             321,\t    STRING,\t 37,  -1 },\n\t{             324,\t    STRING,\t 38,  -1 },\n\t{             327,\t    STRING,\t 39,  -1 },\n\t{             330,\t    STRING,\t 40,  -1 },\n\t{             333,\t    STRING,\t 41,  -1 },\n\t{             336,\t    STRING,\t 42,  -1 },\n\t{             339,\t    STRING,\t 43,  -1 },\n\t{             342,\t    STRING,\t 44,  -1 },\n\t{             345,\t    STRING,\t 45,  -1 },\n\t{             348,\t    STRING,\t 46,  -1 },\n\t{             351,\t    STRING,\t 47,  -1 },\n\t{             354,\t    STRING,\t 48, 102 },\n\t{             357,\t    STRING,\t 49,  -1 },\n\t{             360,\t    STRING,\t 50,  -1 },\n\t{             363,\t    STRING,\t 51,  -1 },\n\t{             366,\t    STRING,\t 52,  -1 },\n\t{             369,\t    STRING,\t 53,  -1 },\n\t{             372,\t    STRING,\t 54,  -1 },\n\t{             375,\t    STRING,\t 55,  -1 },\n\t{             378,\t    STRING,\t 56,  -1 },\n\t{             381,\t    STRING,\t 57,  -1 },\n\t{             384,\t    STRING,\t 58,  -1 },\n\t{             387,\t    STRING,\t 59,  -1 },\n\t{             390,\t    STRING,\t 60,  -1 },\n\t{             393,\t    STRING,\t 61,  -1 },\n\t{             396,\t    STRING,\t 62,  -1 },\n\t{             399,\t    STRING,\t 63,  -1 },\n\t{             402,\t    STRING,\t 64,  -1 },\n\t{             405,\t    STRING,\t 65,  -1 },\n\t{             408,\t    STRING,\t 66,  -1 },\n\t{             411,\t    STRING,\t 67,  -1 },\n\t{             414,\t    STRING,\t 68,  -1 },\n\t{             417,\t    STRING,\t 69,  -1 },\n\t{             420,\t    STRING,\t 70,  -1 },\n\t{             423,\t    STRING,\t 71,  -1 },\n\t{             426,\t    STRING,\t 72,  -1 },\n\t{             429,\t    STRING,\t 73,  -1 },\n\t{             432,\t    STRING,\t 74,  -1 },\n\t{             435,\t    STRING,\t 75,  15 },\n\t{             438,\t    STRING,\t 76,  -1 },\n\t{             441,\t    STRING,\t 77,  -1 },\n\t{             444,\t    STRING,\t 78,  -1 },\n\t{             447,\t    STRING,\t 79,  -1 },\n\t{             450,\t    STRING,\t 80,  -1 },\n\t{             453,\t    STRING,\t 81,  -1 },\n\t{             456,\t    STRING,\t 82,  -1 },\n\t{             459,\t    STRING,\t 83,  -1 },\n\t{             462,\t    STRING,\t 84,  -1 },\n\t{             465,\t    STRING,\t 85,  -1 },\n\t{             468,\t    STRING,\t 86,  -1 },\n\t{             471,\t    STRING,\t 87,  -1 },\n\t{             474,\t    STRING,\t 88,  -1 },\n\t{             477,\t    STRING,\t 89,  -1 },\n\t{             480,\t    STRING,\t 90,  -1 },\n\t{             483,\t    STRING,\t 91,  -1 },\n\t{             486,\t    STRING,\t 92,  35 },\n\t{             489,\t    STRING,\t 93,  -1 },\n\t{             492,\t    STRING,\t 94,  -1 },\n\t{             495,\t    STRING,\t 95,  -1 },\n\t{             498,\t    STRING,\t 96,  -1 },\n\t{             501,\t    STRING,\t 97,  -1 },\n\t{             504,\t    STRING,\t 98,  -1 },\n\t{             507,\t    STRING,\t 99,  -1 },\n\t{             510,\t    STRING,\t100,  -1 },\n\t{             513,\t    STRING,\t101,  -1 },\n\t{             516,\t    STRING,\t102, 120 },\n\t{             519,\t    STRING,\t103,  -1 },\n\t{             522,\t    STRING,\t104,  -1 },\n\t{             525,\t    STRING,\t105,  -1 },\n\t{             528,\t    STRING,\t106,  -1 },\n\t{             531,\t    STRING,\t107,  -1 },\n\t{             534,\t    STRING,\t108,  -1 },\n\t{             537,\t    STRING,\t109,  -1 },\n\t{             540,\t    STRING,\t110,  -1 },\n\t{             543,\t    STRING,\t111,  -1 },\n\t{             546,\t    STRING,\t112, 111 },\n\t{             549,\t    STRING,\t113,  -1 },\n\t{             552,\t    STRING,\t114,  -1 },\n\t{             555,\t    STRING,\t115, 161 },\n\t{             558,\t    STRING,\t116, 163 },\n\t{             561,\t    STRING,\t117,  -1 },\n\t{             564,\t    STRING,\t118, 170 },\n\t{             567,\t    STRING,\t119,  -1 },\n\t{             570,\t    STRING,\t120, 166 },\n\t{             573,\t    STRING,\t121,  -1 },\n\t{             576,\t    STRING,\t122,  -1 },\n\t{             579,\t    STRING,\t123,  -1 },\n\t{             582,\t    STRING,\t124,  -1 },\n\t{             585,\t    STRING,\t125,  -1 },\n\t{             588,\t    STRING,\t126,  -1 },\n\t{             591,\t    STRING,\t127,  -1 },\n\t{             594,\t    STRING,\t128,  -1 },\n\t{             597,\t    STRING,\t129,  -1 },\n\t{             600,\t    STRING,\t130,  -1 },\n\t{             603,\t    STRING,\t131,  -1 },\n\t{             606,\t    STRING,\t132,  -1 },\n\t{             609,\t    STRING,\t133,  -1 },\n\t{             612,\t    STRING,\t134,  -1 },\n\t{             615,\t    STRING,\t135,  -1 },\n\t{             618,\t    STRING,\t136,  -1 },\n\t{             621,\t    STRING,\t137,  -1 },\n\t{             624,\t    STRING,\t138,  -1 },\n\t{             627,\t    STRING,\t139,  -1 },\n\t{             630,\t    STRING,\t140,  -1 },\n\t{             633,\t    STRING,\t141,  -1 },\n\t{             636,\t    STRING,\t142,  -1 },\n\t{             639,\t    STRING,\t143,  -1 },\n\t{             642,\t    STRING,\t144,  -1 },\n\t{             645,\t    STRING,\t145,  37 },\n\t{             648,\t    STRING,\t146,  -1 },\n\t{             651,\t    STRING,\t147, 165 },\n\t{             654,\t    STRING,\t148,  -1 },\n\t{             657,\t    STRING,\t149, 117 },\n\t{             660,\t    STRING,\t150,  16 },\n\t{             663,\t    STRING,\t151,  -1 },\n\t{             666,\t    STRING,\t152,  -1 },\n\t{             669,\t    STRING,\t153,  -1 },\n\t{             672,\t    STRING,\t154, 126 },\n\t{             675,\t    STRING,\t155,  -1 },\n\t{             678,\t    STRING,\t156,  -1 },\n\t{             681,\t    STRING,\t157,  -1 },\n\t{             684,\t    STRING,\t158,  -1 },\n\t{             687,\t    STRING,\t159,  -1 },\n\t{             690,\t    STRING,\t160,  -1 },\n\t{             693,\t    STRING,\t161,  -1 },\n\t{             696,\t    STRING,\t162,  -1 },\n\t{             699,\t    STRING,\t163,  -1 },\n\t{             702,\t    STRING,\t164, 183 },\n\t{             705,\t    STRING,\t165,  -1 },\n\t{             708,\t    STRING,\t166,  -1 },\n\t{             711,\t    STRING,\t167, 116 },\n\t{             714,\t    STRING,\t168,  -1 },\n\t{             717,\t    STRING,\t169,  97 },\n\t{             720,\t    STRING,\t170, 109 },\n\t{             723,\t    STRING,\t171,  -1 },\n\t{             726,\t    STRING,\t172,  -1 },\n\t{             729,\t    STRING,\t173, 100 },\n\t{             732,\t    STRING,\t174,  13 },\n\t{             735,\t    STRING,\t175,  -1 },\n\t{             738,\t    STRING,\t176, 118 },\n\t{             741,\t    STRING,\t177,  96 },\n\t{             744,\t    STRING,\t178,  -1 },\n\t{             747,\t    STRING,\t179,  87 },\n\t{             750,\t    STRING,\t180,  -1 },\n\t{             753,\t    STRING,\t181,  -1 },\n\t{             756,\t    STRING,\t182,  -1 },\n\t{             759,\t    STRING,\t183,  -1 },\n\t{             762,\t    STRING,\t184,  -1 },\n\t{             765,\t    STRING,\t185,  -1 },\n\t{             768,\t    STRING,\t186,  -1 },\n\t{             771,\t    STRING,\t187,  -1 },\n\t{             774,\t    STRING,\t188, 196 },\n\t{             777,\t    STRING,\t189,  -1 },\n\t{             780,\t    STRING,\t190,  -1 },\n\t{             783,\t    STRING,\t191, 195 },\n\t{             786,\t    STRING,\t192,  -1 },\n\t{             789,\t    STRING,\t193,  -1 },\n\t{             792,\t    STRING,\t194,  -1 },\n\t{             795,\t    STRING,\t195,  -1 },\n\t{             798,\t    STRING,\t196,  -1 },\n\t{             801,\t    STRING,\t197,  -1 },\n\t{             804,\t    STRING,\t198,  -1 },\n\t{             807,\t    STRING,\t199, 131 },\n\t{             810,\t    STRING,\t200, 158 },\n\t{             813,\t    STRING,\t201,  -1 },\n\t{             816,\t    STRING,\t202,  -1 },\n\t{             819,\t    STRING,\t203,  -1 },\n\t{             822,\t    STRING,\t204,  -1 },\n\t{             825,\t    STRING,\t205,  -1 },\n\t{             828,\t    STRING,\t206,  -1 },\n\t{             831,\t    STRING,\t207,  -1 },\n\t{             834,\t    STRING,\t208,  -1 },\n\t{             837,\t    STRING,\t209,  -1 },\n\t{             840,\t    STRING,\t210,  -1 },\n\t{             843,\t    STRING,\t211,  -1 },\n\t{             846,\t    STRING,\t212, 122 },\n\t{             849,\t    STRING,\t213,  -1 },\n\t{             852,\t    STRING,\t214,  -1 },\n\t{             855,\t    STRING,\t215,  -1 },\n\t{             858,\t    STRING,\t216,  -1 },\n\t{             861,\t    STRING,\t217,  46 },\n\t{             864,\t    STRING,\t218,  39 },\n\t{             867,\t    STRING,\t219,  -1 },\n\t{             870,\t    STRING,\t220,  -1 },\n\t{             873,\t    STRING,\t221,  88 },\n\t{             876,\t    STRING,\t222,  40 },\n\t{             879,\t    STRING,\t223,  -1 },\n\t{             882,\t    STRING,\t224,  -1 },\n\t{             885,\t    STRING,\t225,  47 },\n\t{             888,\t    STRING,\t226,  -1 },\n\t{             891,\t    STRING,\t227,  -1 },\n\t{             894,\t    STRING,\t228,  -1 },\n\t{             897,\t    STRING,\t229,  -1 },\n\t{             900,\t    STRING,\t230,  53 },\n\t{             903,\t    STRING,\t231,  54 },\n\t{             906,\t    STRING,\t232,  55 },\n\t{             909,\t    STRING,\t233,  56 },\n\t{             912,\t    STRING,\t234,  57 },\n\t{             915,\t    STRING,\t235,  58 },\n\t{             918,\t    STRING,\t236,  59 },\n\t{             921,\t    STRING,\t237,  60 },\n\t{             924,\t    STRING,\t238,  61 },\n\t{             927,\t    STRING,\t239,  62 },\n\t{             930,\t    STRING,\t240,  63 },\n\t{             933,\t    STRING,\t241,  64 },\n\t{             936,\t    STRING,\t242,  65 },\n\t{             939,\t    STRING,\t243,  66 },\n\t{             942,\t    STRING,\t244,  68 },\n\t{             945,\t    STRING,\t245,  69 },\n\t{             948,\t    STRING,\t246,  -1 },\n\t{             951,\t    STRING,\t247,  -1 },\n\t{             954,\t    STRING,\t248,  -1 },\n\t{             957,\t    STRING,\t249,  -1 },\n\t{             960,\t    STRING,\t250,  -1 },\n\t{             963,\t    STRING,\t251,  -1 },\n\t{             966,\t    STRING,\t252,  -1 },\n\t{             969,\t    STRING,\t253,  -1 },\n\t{             972,\t    STRING,\t254,  -1 },\n\t{             975,\t    STRING,\t255,  -1 },\n\t{             978,\t    STRING,\t256,  -1 },\n\t{             981,\t    STRING,\t257,   7 },\n\t{             984,\t    STRING,\t258,  94 },\n\t{             987,\t    STRING,\t259,  -1 },\n\t{             990,\t    STRING,\t260,  -1 },\n\t{             993,\t    STRING,\t261,  -1 },\n\t{             996,\t    STRING,\t262,  -1 },\n\t{             999,\t    STRING,\t263,  -1 },\n\t{            1002,\t    STRING,\t264,  -1 },\n\t{            1005,\t    STRING,\t265, 184 },\n\t{            1008,\t    STRING,\t266,  29 },\n\t{            1011,\t    STRING,\t267,  -1 },\n\t{            1014,\t    STRING,\t268,  -1 },\n\t{            1017,\t    STRING,\t269,  -1 },\n\t{            1020,\t    STRING,\t270,  -1 },\n\t{            1023,\t    STRING,\t271,  -1 },\n\t{            1026,\t    STRING,\t272,  -1 },\n\t{            1029,\t    STRING,\t273, 257 },\n\t{            1032,\t    STRING,\t274,  -1 },\n\t{            1035,\t    STRING,\t275,  -1 },\n\t{            1038,\t    STRING,\t276,  -1 },\n\t{            1041,\t    STRING,\t277,   4 },\n\t{            1044,\t    STRING,\t278,  -1 },\n\t{            1047,\t    STRING,\t279,  -1 },\n\t{            1050,\t    STRING,\t280,  -1 },\n\t{            1053,\t    STRING,\t281,  -1 },\n\t{            1056,\t    STRING,\t282,  -1 },\n\t{            1059,\t    STRING,\t283,  -1 },\n\t{            1062,\t    STRING,\t284, 229 },\n\t{            1065,\t    STRING,\t285,  -1 },\n\t{            1068,\t    STRING,\t286,  -1 },\n\t{            1071,\t    STRING,\t287,  -1 },\n\t{            1074,\t    STRING,\t288,  -1 },\n\t{            1077,\t    STRING,\t289,  -1 },\n\t{            1080,\t    STRING,\t290,  -1 },\n\t{            1083,\t    STRING,\t291,  -1 },\n\t{            1086,\t    STRING,\t292,  -1 },\n\t{            1089,\t    STRING,\t293,  -1 },\n\t{            1092,\t    STRING,\t294,  -1 },\n\t{            1095,\t    STRING,\t295,  -1 },\n\t{            1098,\t    STRING,\t296,  -1 },\n\t{            1101,\t    STRING,\t297, 142 },\n\t{            1104,\t    STRING,\t298,  -1 },\n\t{            1107,\t    STRING,\t299,  -1 },\n\t{            1110,\t    STRING,\t300, 149 },\n\t{            1113,\t    STRING,\t301,  -1 },\n\t{            1116,\t    STRING,\t302,  -1 },\n\t{            1119,\t    STRING,\t303,  -1 },\n\t{            1122,\t    STRING,\t304,  -1 },\n\t{            1125,\t    STRING,\t305,  -1 },\n\t{            1128,\t    STRING,\t306,  -1 },\n\t{            1131,\t    STRING,\t307,  -1 },\n\t{            1134,\t    STRING,\t308,  -1 },\n\t{            1137,\t    STRING,\t309,  48 },\n\t{            1140,\t    STRING,\t310, 247 },\n\t{            1143,\t    STRING,\t311, 238 },\n\t{            1146,\t    STRING,\t312, 239 },\n\t{            1149,\t    STRING,\t313, 240 },\n\t{            1152,\t    STRING,\t314, 241 },\n\t{            1155,\t    STRING,\t315, 242 },\n\t{            1158,\t    STRING,\t316, 243 },\n\t{            1161,\t    STRING,\t317, 244 },\n\t{            1164,\t    STRING,\t318, 245 },\n\t{            1167,\t    STRING,\t319, 246 },\n\t{            1170,\t    STRING,\t320,  -1 },\n\t{            1173,\t    STRING,\t321, 172 },\n\t{            1176,\t    STRING,\t322,  -1 },\n\t{            1179,\t    STRING,\t323, 171 },\n\t{            1182,\t    STRING,\t324, 103 },\n\t{            1185,\t    STRING,\t325,  -1 },\n\t{            1188,\t    STRING,\t326, 104 },\n\t{            1191,\t    STRING,\t327,  14 },\n\t{            1194,\t    STRING,\t328,  -1 },\n\t{            1197,\t    STRING,\t329,  -1 },\n\t{            1200,\t    STRING,\t330,  -1 },\n\t{            1203,\t    STRING,\t331,  -1 },\n\t{            1206,\t    STRING,\t332,  -1 },\n\t{            1209,\t    STRING,\t333,  -1 },\n\t{            1212,\t    STRING,\t334,  -1 },\n\t{            1215,\t    STRING,\t335,  -1 },\n\t{            1218,\t    STRING,\t336,  -1 },\n\t{            1221,\t    STRING,\t337,  -1 },\n\t{            1224,\t    STRING,\t338,  -1 },\n\t{            1227,\t    STRING,\t339,  -1 },\n\t{            1230,\t    STRING,\t340,  -1 },\n\t{            1233,\t    STRING,\t341,  -1 },\n\t{            1236,\t    STRING,\t342,  -1 },\n\t{            1239,\t    STRING,\t343,  -1 },\n\t{            1242,\t    STRING,\t344, 208 },\n\t{            1245,\t    STRING,\t345,  -1 },\n\t{            1248,\t    STRING,\t346,  -1 },\n\t{            1251,\t    STRING,\t347,  -1 },\n\t{            1254,\t    STRING,\t348,  -1 },\n\t{            1257,\t    STRING,\t349,  -1 },\n\t{            1260,\t    STRING,\t350,  -1 },\n\t{            1263,\t    STRING,\t351,  -1 },\n\t{            1266,\t    STRING,\t352,  -1 },\n\t{            1269,\t    STRING,\t353, 272 },\n\t{            1272,\t    STRING,\t354, 273 },\n\t{            1275,\t    STRING,\t355, 387 },\n\t{            1278,\t    STRING,\t356,  -1 },\n\t{            1281,\t    STRING,\t357,  -1 },\n\t{            1284,\t    STRING,\t358,  -1 },\n\t{            1287,\t    STRING,\t359,  -1 },\n\t{            1290,\t    STRING,\t360,  -1 },\n\t{            1293,\t    STRING,\t361,  -1 },\n\t{            1296,\t    STRING,\t362,  -1 },\n\t{            1299,\t    STRING,\t363,  -1 },\n\t{            1302,\t    STRING,\t364,  -1 },\n\t{            1305,\t    STRING,\t365,  67 },\n\t{            1308,\t    STRING,\t366,  -1 },\n\t{            1311,\t    STRING,\t367,  -1 },\n\t{            1314,\t    STRING,\t368, 341 },\n\t{            1317,\t    STRING,\t369,  -1 },\n\t{            1320,\t    STRING,\t370,  -1 },\n\t{            1323,\t    STRING,\t371, 274 },\n\t{            1326,\t    STRING,\t372,  -1 },\n\t{            1329,\t    STRING,\t373,  -1 },\n\t{            1332,\t    STRING,\t374,  -1 },\n\t{            1335,\t    STRING,\t375,  -1 },\n\t{            1338,\t    STRING,\t376,  -1 },\n\t{            1341,\t    STRING,\t377,  -1 },\n\t{            1344,\t    STRING,\t378,  -1 },\n\t{            1347,\t    STRING,\t379,  -1 },\n\t{            1350,\t    STRING,\t380,  -1 },\n\t{            1353,\t    STRING,\t381, 357 },\n\t{            1356,\t    STRING,\t382, 358 },\n\t{            1359,\t    STRING,\t383, 359 },\n\t{            1362,\t    STRING,\t384, 360 },\n\t{            1365,\t    STRING,\t385, 361 },\n\t{            1368,\t    STRING,\t386,  -1 },\n\t{            1371,\t    STRING,\t387,  -1 },\n\t{            1374,\t    STRING,\t388,  -1 },\n\t{            1377,\t    STRING,\t389,  -1 },\n\t{            1380,\t    STRING,\t390,  -1 },\n\t{            1383,\t    STRING,\t391,  -1 },\n\t{            1386,\t    STRING,\t392,  -1 },\n\t{            1389,\t    STRING,\t393,  -1 },\n\t{            1392,\t    STRING,\t394, 390 },\n\t{            1395,\t    STRING,\t395,  -1 },\n\t{            1398,\t    NUMBER,\t 33,  -1 },\n\t{            1401,\t   BOOLEAN,\t 37,  -1 },\n\t{            1404,\t   BOOLEAN,\t 38,  -1 },\n\t{            1407,\t   BOOLEAN,\t 39, 248 },\n\t{            1410,\t    NUMBER,\t 34,  -1 },\n\t{            1413,\t    NUMBER,\t 35, 203 },\n\t{            1416,\t    STRING,\t396,  -1 },\n\t{            1419,\t    STRING,\t397,  -1 },\n\t{            1422,\t   BOOLEAN,\t 40, 439 },\n\t{            1425,\t   BOOLEAN,\t 41,  -1 },\n\t{            1428,\t    NUMBER,\t 36,  -1 },\n\t{            1431,\t    NUMBER,\t 37,  -1 },\n\t{            1434,\t    NUMBER,\t 38,  -1 },\n\t{            1437,\t    STRING,\t398,  -1 },\n\t{            1440,\t    STRING,\t399, 379 },\n\t{            1443,\t   BOOLEAN,\t 42,  -1 },\n\t{            1446,\t   BOOLEAN,\t 43,  -1 },\n\t{            1449,\t    STRING,\t400, 386 },\n\t{            1452,\t    STRING,\t401, 425 },\n\t{            1455,\t    STRING,\t402, 385 },\n\t{            1458,\t    STRING,\t403, 388 },\n\t{            1461,\t    STRING,\t404, 412 },\n\t{            1464,\t    STRING,\t405, 406 },\n\t{            1467,\t    STRING,\t406, 415 },\n\t{            1470,\t    STRING,\t407,  -1 },\n\t{            1473,\t    STRING,\t408, 402 },\n\t{            1476,\t    STRING,\t409, 416 },\n\t{            1479,\t    STRING,\t410,  -1 },\n\t{            1482,\t    STRING,\t411, 464 },\n\t{            1485,\t    STRING,\t412, 399 },\n\t{            1488,\t    STRING,\t413,  -1 } \n};\n\nstatic struct name_table_entry *_nc_cap_table = 0;\n\nstatic const HashValue _nc_cap_hash_table[995] =\n{\n\t253,\n\t -1,\n\t 45,\n\t211,\n\t263,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t449,\n\t457,\n\t311,\n\t411,\n\t -1,\n\t132,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t123,\n\t 71,\n\t 75,\n\t 92,\n\t427,\n\t233,\n\t -1,\n\t336,\n\t -1,\n\t -1,\n\t370,\n\t291,\n\t494,\n\t472,\n\t138,\n\t186,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 19,\n\t193,\n\t436,\n\t431,\n\t453,\n\t -1,\n\t315,\n\t489,\n\t349,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t353,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t124,\n\t -1,\n\t -1,\n\t -1,\n\t394,\n\t -1,\n\t367,\n\t167,\n\t -1,\n\t191,\n\t371,\n\t -1,\n\t 89,\n\t -1,\n\t -1,\n\t -1,\n\t363,\n\t460,\n\t319,\n\t419,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 70,\n\t 74,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 38,\n\t -1,\n\t128,\n\t -1,\n\t398,\n\t -1,\n\t -1,\n\t481,\n\t -1,\n\t -1,\n\t202,\n\t -1,\n\t 28,\n\t 43,\n\t -1,\n\t 17,\n\t -1,\n\t -1,\n\t444,\n\t423,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t496,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t430,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t296,\n\t -1,\n\t 21,\n\t -1,\n\t187,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t321,\n\t276,\n\t -1,\n\t -1,\n\t 31,\n\t375,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t429,\n\t476,\n\t -1,\n\t -1,\n\t -1,\n\t300,\n\t400,\n\t -1,\n\t218,\n\t -1,\n\t -1,\n\t227,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 11,\n\t285,\n\t179,\n\t -1,\n\t325,\n\t280,\n\t -1,\n\t224,\n\t162,\n\t480,\n\t -1,\n\t -1,\n\t 51,\n\t -1,\n\t -1,\n\t201,\n\t204,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 22,\n\t -1,\n\t304,\n\t404,\n\t -1,\n\t154,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t108,\n\t -1,\n\t 76,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t329,\n\t284,\n\t -1,\n\t270,\n\t 84,\n\t383,\n\t250,\n\t426,\n\t -1,\n\t -1,\n\t260,\n\t113,\n\t110,\n\t114,\n\t 86,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t308,\n\t408,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t433,\n\t -1,\n\t112,\n\t230,\n\t -1,\n\t333,\n\t428,\n\t -1,\n\t223,\n\t288,\n\t484,\n\t254,\n\t -1,\n\t -1,\n\t210,\n\t264,\n\t -1,\n\t 98,\n\t -1,\n\t 83,\n\t471,\n\t -1,\n\t450,\n\t -1,\n\t312,\n\t487,\n\t -1,\n\t151,\n\t -1,\n\t -1,\n\t -1,\n\t342,\n\t 24,\n\t -1,\n\t 80,\n\t 99,\n\t -1,\n\t234,\n\t -1,\n\t337,\n\t101,\n\t -1,\n\t  8,\n\t292,\n\t391,\n\t -1,\n\t139,\n\t164,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t194,\n\t437,\n\t -1,\n\t454,\n\t -1,\n\t316,\n\t492,\n\t -1,\n\t155,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t395,\n\t -1,\n\t143,\n\t168,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t364,\n\t -1,\n\t320,\n\t420,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t207,\n\t -1,\n\t -1,\n\t157,\n\t447,\n\t495,\n\t -1,\n\t137,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t440,\n\t445,\n\t424,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 79,\n\t175,\n\t -1,\n\t297,\n\t493,\n\t 23,\n\t178,\n\t -1,\n\t -1,\n\t -1,\n\t340,\n\t 52,\n\t -1,\n\t -1,\n\t -1,\n\t346,\n\t344,\n\t -1,\n\t322,\n\t277,\n\t -1,\n\t -1,\n\t 32,\n\t376,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t373,\n\t -1,\n\t470,\n\t -1,\n\t -1,\n\t -1,\n\t301,\n\t401,\n\t -1,\n\t127,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t339,\n\t 12,\n\t -1,\n\t -1,\n\t -1,\n\t326,\n\t281,\n\t348,\n\t125,\n\t 36,\n\t380,\n\t343,\n\t -1,\n\t 42,\n\t -1,\n\t267,\n\t -1,\n\t -1,\n\t372,\n\t115,\n\t -1,\n\t  2,\n\t345,\n\t -1,\n\t305,\n\t405,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t237,\n\t -1,\n\t330,\n\t121,\n\t -1,\n\t271,\n\t -1,\n\t384,\n\t251,\n\t -1,\n\t189,\n\t -1,\n\t261,\n\t199,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t177,\n\t -1,\n\t309,\n\t409,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t226,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t231,\n\t352,\n\t334,\n\t -1,\n\t -1,\n\t -1,\n\t289,\n\t486,\n\t255,\n\t135,\n\t160,\n\t212,\n\t265,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t434,\n\t -1,\n\t451,\n\t -1,\n\t313,\n\t413,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t214,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t235,\n\t  6,\n\t338,\n\t 10,\n\t -1,\n\t478,\n\t293,\n\t392,\n\t -1,\n\t140,\n\t217,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t347,\n\t455,\n\t459,\n\t317,\n\t417,\n\t -1,\n\t134,\n\t -1,\n\t -1,\n\t -1,\n\t 49,\n\t -1,\n\t -1,\n\t 72,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t153,\n\t -1,\n\t396,\n\t -1,\n\t144,\n\t169,\n\t -1,\n\t -1,\n\t200,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t482,\n\t365,\n\t461,\n\t442,\n\t421,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t197,\n\t432,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t446,\n\t441,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 18,\n\t -1,\n\t -1,\n\t -1,\n\t298,\n\t490,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 26,\n\t -1,\n\t -1,\n\t351,\n\t -1,\n\t -1,\n\t -1,\n\t323,\n\t278,\n\t -1,\n\t369,\n\t 33,\n\t377,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t302,\n\t491,\n\t -1,\n\t129,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t216,\n\t473,\n\t 27,\n\t 91,\n\t107,\n\t -1,\n\t -1,\n\t327,\n\t282,\n\t -1,\n\t268,\n\t -1,\n\t381,\n\t469,\n\t368,\n\t174,\n\t -1,\n\t258,\n\t198,\n\t -1,\n\t206,\n\t180,\n\t -1,\n\t -1,\n\t176,\n\t -1,\n\t306,\n\t488,\n\t -1,\n\t150,\n\t -1,\n\t -1,\n\t -1,\n\t438,\n\t475,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t228,\n\t -1,\n\t331,\n\t -1,\n\t -1,\n\t -1,\n\t286,\n\t485,\n\t252,\n\t -1,\n\t -1,\n\t209,\n\t262,\n\t 41,\n\t -1,\n\t466,\n\t -1,\n\t -1,\n\t -1,\n\t448,\n\t -1,\n\t310,\n\t410,\n\t -1,\n\t130,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 25,\n\t -1,\n\t -1,\n\t -1,\n\t 50,\n\t232,\n\t -1,\n\t335,\n\t -1,\n\t -1,\n\t -1,\n\t290,\n\t389,\n\t256,\n\t136,\n\t185,\n\t213,\n\t266,\n\t -1,\n\t -1,\n\t -1,\n\t192,\n\t435,\n\t -1,\n\t452,\n\t458,\n\t314,\n\t414,\n\t -1,\n\t152,\n\t -1,\n\t -1,\n\t -1,\n\t474,\n\t -1,\n\t -1,\n\t215,\n\t 81,\n\t  5,\n\t236,\n\t -1,\n\t 82,\n\t -1,\n\t -1,\n\t479,\n\t294,\n\t393,\n\t -1,\n\t141,\n\t190,\n\t -1,\n\t -1,\n\t105,\n\t -1,\n\t -1,\n\t -1,\n\t477,\n\t 20,\n\t362,\n\t -1,\n\t318,\n\t418,\n\t -1,\n\t156,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 95,\n\t467,\n\t 73,\n\t 93,\n\t220,\n\t219,\n\t -1,\n\t  9,\n\t119,\n\t -1,\n\t159,\n\t -1,\n\t397,\n\t468,\n\t145,\n\t188,\n\t -1,\n\t465,\n\t -1,\n\t205,\n\t106,\n\t 90,\n\t 44,\n\t  3,\n\t366,\n\t -1,\n\t443,\n\t422,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t  0,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t295,\n\t -1,\n\t173,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t355,\n\t -1,\n\t222,\n\t221,\n\t -1,\n\t -1,\n\t275,\n\t356,\n\t -1,\n\t 30,\n\t374,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t225,\n\t -1,\n\t -1,\n\t299,\n\t -1,\n\t -1,\n\t148,\n\t -1,\n\t -1,\n\t181,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t462,\n\t -1,\n\t -1,\n\t -1,\n\t324,\n\t279,\n\t -1,\n\t -1,\n\t 34,\n\t378,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t350,\n\t -1,\n\t303,\n\t403,\n\t -1,\n\t133,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 77,\n\t -1,\n\t182,\n\t -1,\n\t -1,\n\t328,\n\t283,\n\t -1,\n\t269,\n\t463,\n\t382,\n\t249,\n\t -1,\n\t -1,\n\t -1,\n\t259,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 85,\n\t -1,\n\t456,\n\t307,\n\t407,\n\t -1,\n\t147,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t -1,\n\t 78,\n\t -1,\n\t -1,\n\t354,\n\t -1,\n\t332,\n\t -1,\n\t -1,\n\t146,\n\t287,\n\t483,\n\t0\t/* base-of-table */\n};\n\n#if (BOOLCOUNT!=44)||(NUMCOUNT!=39)||(STRCOUNT!=414)\n#error\t--> term.h and comp_captab.c disagree about the <--\n#error\t--> numbers of booleans, numbers and/or strings <--\n#endif\n\n/* generated by MKcaptab.awk capalias(1) */\n\nstatic struct alias *_nc_capalias_table = 0;\n\nstatic const char capalias_text[] = \"\\\nsb\\0sr\\0BSD\\0\\\nBO\\0mr\\0AT&T\\0\\\nCI\\0vi\\0AT&T\\0\\\nCV\\0ve\\0AT&T\\0\\\nDS\\0mh\\0AT&T\\0\\\nFE\\0LF\\0AT&T\\0\\\nFL\\0LO\\0AT&T\\0\\\nXS\\0mk\\0AT&T\\0\\\nEE\\0mh\\0XENIX\\0\\\nGE\\0ae\\0XENIX\\0\\\nGS\\0as\\0XENIX\\0\\\nCF\\0vi\\0XENIX\\0\\\nCO\\0ve\\0XENIX\\0\\\nEN\\0@7\\0XENIX\\0\\\nHM\\0kh\\0XENIX\\0\\\nLD\\0kL\\0XENIX\\0\\\nPD\\0kN\\0XENIX\\0\\\nPN\\0po\\0XENIX\\0\\\nPS\\0pf\\0XENIX\\0\\\nPU\\0kP\\0XENIX\\0\\\nRT\\0@8\\0XENIX\\0\\\nUP\\0ku\\0XENIX\\0\\\nG6\\0XENIX\\0\\\nG7\\0XENIX\\0\\\nG5\\0XENIX\\0\\\nG8\\0XENIX\\0\\\nGr\\0XENIX\\0\\\nGr\\0XENIX\\0\\\nGu\\0XENIX\\0\\\nGd\\0XENIX\\0\\\nGh\\0XENIX\\0\\\nGv\\0XENIX\\0\\\nGc\\0XENIX\\0\\\nGG\\0XENIX\\0\\\nkq\\0%1\\0IBM\\0\\\nHS\\0mh\\0IRIS\\0\\\nKA\\0k;\\0Tek\\0\\\nKB\\0F1\\0Tek\\0\\\nKC\\0F2\\0Tek\\0\\\nKD\\0F3\\0Tek\\0\\\nKE\\0F4\\0Tek\\0\\\nKF\\0F5\\0Tek\\0\\\nBC\\0Sb\\0Tek\\0\\\nFC\\0Sf\\0Tek\\0\\\n\";\n\nstatic const alias_table_data capalias_data[] = {\n\t{    0,     3,     6},\t /* scroll */\n\t{   10,    13,    16},\t /* enter_reverse_mode */\n\t{   21,    24,    27},\t /* cursor_invisible */\n\t{   32,    35,    38},\t /* cursor_normal */\n\t{   43,    46,    49},\t /* enter_dim_mode */\n\t{   54,    57,    60},\t /* label_on */\n\t{   65,    68,    71},\t /* label_off */\n\t{   76,    79,    82},\t /* enter_secure_mode */\n\t{   87,    90,    93},\t /* exit_attribute_mode */\n\t{   99,   102,   105},\t /* exit_alt_charset_mode */\n\t{  111,   114,   117},\t /* enter_alt_charset_mode */\n\t{  123,   126,   129},\t /* cursor_invis */\n\t{  135,   138,   141},\t /* cursor_normal */\n\t{  147,   150,   153},\t /* key_end */\n\t{  159,   162,   165},\t /* key_home */\n\t{  171,   174,   177},\t /* key_dl */\n\t{  183,   186,   189},\t /* key_npage */\n\t{  195,   198,   201},\t /* prtr_off */\n\t{  207,   210,   213},\t /* prtr_on */\n\t{  219,   222,   225},\t /* key_ppage */\n\t{  231,   234,   237},\t /* kent */\n\t{  243,   246,   249},\t /* kcuu1 */\n\t{  255,    -1,   258},\t /* double-ACS_ULCORNER */\n\t{  264,    -1,   267},\t /* double-ACS_LLCORNER */\n\t{  273,    -1,   276},\t /* double-ACS_URCORNER */\n\t{  282,    -1,   285},\t /* double-ACS_LRCORNER */\n\t{  291,    -1,   294},\t /* double-ACS_LTEE */\n\t{  300,    -1,   303},\t /* double-ACS_RTEE */\n\t{  309,    -1,   312},\t /* double-ACS_BTEE */\n\t{  318,    -1,   321},\t /* double */\n\t{  327,    -1,   330},\t /* double-ACS_HLINE */\n\t{  336,    -1,   339},\t /* double-ACS_VLINE */\n\t{  345,    -1,   348},\t /* double-ACS_PLUS */\n\t{  354,    -1,   357},\t /* acs-glitch */\n\t{  363,   366,   369},\t /* key_help */\n\t{  373,   376,   379},\t /* enter_dim_mode */\n\t{  384,   387,   390},\t /* key_f10 */\n\t{  394,   397,   400},\t /* key_f11 */\n\t{  404,   407,   410},\t /* key_f12 */\n\t{  414,   417,   420},\t /* key_f13 */\n\t{  424,   427,   430},\t /* key_f14 */\n\t{  434,   437,   440},\t /* key_f15 */\n\t{  444,   447,   450},\t /* set_background */\n\t{  454,   457,   460},\t /* set_foreground */\n};\n\n/* generated by MKcaptab.awk infoalias(1) */\n\nstatic struct alias *_nc_infoalias_table = 0;\n\nstatic const char infoalias_text[] = \"\\\nfont0\\0s0ds\\0IBM\\0\\\nfont1\\0s1ds\\0IBM\\0\\\nfont2\\0s2ds\\0IBM\\0\\\nfont3\\0s3ds\\0IBM\\0\\\nkbtab\\0kcbt\\0IBM\\0\\\nksel\\0kslt\\0IBM\\0\\\n\";\n\nstatic const alias_table_data infoalias_data[] = {\n\t{    0,     6,    11},\t /* set0_des_seq */\n\t{   15,    21,    26},\t /* set1_des_seq */\n\t{   30,    36,    41},\t /* set2_des_seq */\n\t{   45,    51,    56},\t /* set3_des_seq */\n\t{   60,    66,    71},\t /* key_backtab */\n\t{   75,    80,    85},\t /* key_select */\n};\n\n\n#if 1\nstatic void\nnext_string(const char *strings, unsigned *offset)\n{\n    *offset += (unsigned) strlen(strings + *offset) + 1;\n}\n\nstatic const struct name_table_entry *\n_nc_build_names(struct name_table_entry **actual,\n\t\tconst name_table_data *source,\n\t\tconst char *strings)\n{\n    if (*actual == 0) {\n\t*actual = typeCalloc(struct name_table_entry, CAPTABSIZE);\n\tif (*actual != 0) {\n\t    unsigned n;\n\t    unsigned len = 0;\n\t    for (n = 0; n < CAPTABSIZE; ++n) {\n\t\t(*actual)[n].nte_name = strings + len;\n\t\t(*actual)[n].nte_type = source[n].nte_type;\n\t\t(*actual)[n].nte_index = source[n].nte_index;\n\t\t(*actual)[n].nte_link = source[n].nte_link;\n\t\tnext_string(strings, &len);\n\t    }\n\t}\n    }\n    return *actual;\n}\n\n#define add_alias(field) \\\n\tif (source[n].field >= 0) { \\\n\t\t(*actual)[n].field = strings + source[n].field; \\\n\t}\n\nstatic const struct alias *\n_nc_build_alias(struct alias **actual,\n\t\tconst alias_table_data *source,\n\t\tconst char *strings,\n\t\tsize_t tablesize)\n{\n    if (*actual == 0) {\n\t*actual = typeCalloc(struct alias, tablesize + 1);\n\tif (*actual != 0) {\n\t    size_t n;\n\t    for (n = 0; n < tablesize; ++n) {\n\t\tadd_alias(from);\n\t\tadd_alias(to);\n\t\tadd_alias(source);\n\t    }\n\t}\n    }\n    return *actual;\n}\n\n#define build_names(root) _nc_build_names(&_nc_##root##_table, \\\n\t\t\t\t\t  root##_names_data, \\\n\t\t\t\t\t  root##_names_text)\n#define build_alias(root) _nc_build_alias(&_nc_##root##alias_table, \\\n\t\t\t\t\t  root##alias_data, \\\n\t\t\t\t\t  root##alias_text, \\\n\t\t\t\t\t  SIZEOF(root##alias_data))\n#else\n#define build_names(root) _nc_ ## root ## _table\n#define build_alias(root) _nc_ ## root ## alias_table\n#endif\n\nNCURSES_EXPORT(const struct name_table_entry *) _nc_get_table (bool termcap)\n{\n    return termcap ? build_names(cap) : build_names(info) ;\n}\n\n/* entrypoint used by tack (do not alter) */\nNCURSES_EXPORT(const HashValue *) _nc_get_hash_table (bool termcap)\n{\n    return termcap ? _nc_cap_hash_table: _nc_info_hash_table ;\n}\n\nNCURSES_EXPORT(const struct alias *) _nc_get_alias_table (bool termcap)\n{\n    return termcap ? build_alias(cap) : build_alias(info) ;\n}\n\nstatic HashValue\ninfo_hash(const char *string)\n{\n    long sum = 0;\n\n    DEBUG(9, (\"hashing %s\", string));\n    while (*string) {\n\tsum += (long) (*string + (*(string + 1) << 8));\n\tstring++;\n    }\n\n    DEBUG(9, (\"sum is %ld\", sum));\n    return (HashValue) (sum % HASHTABSIZE);\n}\n\n#define TCAP_LEN 2\t\t/* only 1- or 2-character names are used */\n\nstatic HashValue\ntcap_hash(const char *string)\n{\n    char temp[TCAP_LEN + 1];\n    int limit = 0;\n\n    while (*string) {\n\ttemp[limit++] = *string++;\n\tif (limit >= TCAP_LEN)\n\t    break;\n    }\n    temp[limit] = '\\0';\n    return info_hash(temp);\n}\n\nstatic int\ncompare_tcap_names(const char *a, const char *b)\n{\n    return !strncmp(a, b, (size_t) TCAP_LEN);\n}\n\nstatic int\ncompare_info_names(const char *a, const char *b)\n{\n    return !strcmp(a, b);\n}\n\nstatic const HashData hash_data[2] = {\n    { HASHTABSIZE, _nc_info_hash_table, info_hash, compare_info_names },\n    { HASHTABSIZE, _nc_cap_hash_table, tcap_hash, compare_tcap_names }\n};\n\nNCURSES_EXPORT(const HashData *) _nc_get_hash_info (bool termcap)\n{\n    return &hash_data[(termcap != FALSE)];\n}\n\n#if NO_LEAKS\nNCURSES_EXPORT(void) _nc_comp_captab_leaks(void)\n{\n#if 1\n    FreeIfNeeded(_nc_cap_table);\n    FreeIfNeeded(_nc_info_table);\n    FreeIfNeeded(_nc_capalias_table);\n    FreeIfNeeded(_nc_infoalias_table);\n#endif\n}\n#endif /* NO_LEAKS */\n","/****************************************************************************\n * Copyright (c) 2006-2012,2017 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey                                                *\n *     and: Juergen Pfeifer                                                 *\n ****************************************************************************/\n\n#include <curses.priv.h>\n\n#include <ctype.h>\n\n#include <tic.h>\n\nMODULE_ID(\"$Id: entries.c,v 1.26 2017/08/04 09:01:39 tom Exp $\")\n\n/****************************************************************************\n *\n * Entry queue handling\n *\n ****************************************************************************/\n/*\n *  The entry list is a doubly linked list with NULLs terminating the lists:\n *\n *\t  ---------   ---------   ---------\n *\t  |       |   |       |   |       |   offset\n *        |-------|   |-------|   |-------|\n *\t  |   ----+-->|   ----+-->|  NULL |   next\n *\t  |-------|   |-------|   |-------|\n *\t  |  NULL |<--+----   |<--+----   |   last\n *\t  ---------   ---------   ---------\n *\t      ^                       ^\n *\t      |                       |\n *\t      |                       |\n *\t   _nc_head                _nc_tail\n */\n\nNCURSES_EXPORT_VAR(ENTRY *) _nc_head = 0;\nNCURSES_EXPORT_VAR(ENTRY *) _nc_tail = 0;\n\nstatic ENTRY *\n_nc_delink_entry(ENTRY * headp, TERMTYPE2 *tterm)\n/* delink the allocated storage for the given list entry */\n{\n    ENTRY *ep, *last;\n\n    for (last = 0, ep = headp; ep != 0; last = ep, ep = ep->next) {\n\tif (&(ep->tterm) == tterm) {\n\t    if (last != 0) {\n\t\tlast->next = ep->next;\n\t    }\n\t    if (ep->next != 0) {\n\t\tep->next->last = last;\n\t    }\n\t    if (ep == _nc_head) {\n\t\t_nc_head = ep->next;\n\t    }\n\t    if (ep == _nc_tail) {\n\t\t_nc_tail = last;\n\t    }\n\t    break;\n\t}\n    }\n    return ep;\n}\n\nNCURSES_EXPORT(void)\n_nc_free_entry(ENTRY * headp, TERMTYPE2 *tterm)\n/* free the allocated storage consumed by the given list entry */\n{\n    ENTRY *ep;\n\n    if ((ep = _nc_delink_entry(headp, tterm)) != 0) {\n\tfree(ep);\n    }\n}\n\nNCURSES_EXPORT(void)\n_nc_free_entries(ENTRY * headp)\n/* free the allocated storage consumed by list entries */\n{\n    (void) headp;\t\t/* unused - _nc_head is altered here! */\n\n    while (_nc_head != 0) {\n\t_nc_free_termtype2(&(_nc_head->tterm));\n    }\n}\n\nNCURSES_EXPORT(void)\n_nc_leaks_tinfo(void)\n{\n#if NO_LEAKS\n    char *s;\n#endif\n\n    T((T_CALLED(\"_nc_free_tinfo()\")));\n#if NO_LEAKS\n    _nc_globals.leak_checking = TRUE;\n    _nc_free_tparm();\n    _nc_tgetent_leaks();\n\n    if (TerminalOf(CURRENT_SCREEN) != 0) {\n\tdel_curterm(TerminalOf(CURRENT_SCREEN));\n    }\n    _nc_forget_prescr();\n\n    _nc_comp_captab_leaks();\n    _nc_free_entries(_nc_head);\n    _nc_get_type(0);\n    _nc_first_name(0);\n    _nc_db_iterator_leaks();\n    _nc_keyname_leaks();\n#if BROKEN_LINKER || USE_REENTRANT\n    _nc_names_leaks();\n    _nc_codes_leaks();\n    FreeIfNeeded(_nc_prescreen.real_acs_map);\n#endif\n    _nc_comp_error_leaks();\n\n    if ((s = _nc_home_terminfo()) != 0)\n\tfree(s);\n\n#ifdef TRACE\n    T((T_RETURN(\"\")));\n    trace(0);\n    _nc_trace_buf(-1, (size_t) 0);\n#endif\n\n#endif /* NO_LEAKS */\n    returnVoid;\n}\n\n#if NO_LEAKS\nNCURSES_EXPORT(void)\n_nc_free_tinfo(int code)\n{\n    _nc_leaks_tinfo();\n    exit(code);\n}\n#endif\n","/****************************************************************************\n * Copyright (c) 1998-2009,2010 Free Software Foundation, Inc.              *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/****************************************************************************\n *  Author: Thomas E. Dickey <dickey@clark.net> 1997                        *\n ****************************************************************************/\n\n/*\n**\ttries.c\n**\n**\tFunctions to manage the tree of partial-completions for keycodes.\n**\n*/\n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: tries.c,v 1.30 2010/08/28 21:08:23 tom Exp $\")\n\n/*\n * Expand a keycode into the string that it corresponds to, returning null if\n * no match was found, otherwise allocating a string of the result.\n */\nNCURSES_EXPORT(char *)\n_nc_expand_try(TRIES * tree, unsigned code, int *count, size_t len)\n{\n    TRIES *ptr = tree;\n    char *result = 0;\n\n    if (code != 0) {\n\twhile (ptr != 0) {\n\t    if ((result = _nc_expand_try(ptr->child, code, count, len + 1))\n\t\t!= 0) {\n\t\tbreak;\n\t    }\n\t    if (ptr->value == code) {\n\t\t*count -= 1;\n\t\tif (*count == -1) {\n\t\t    result = typeCalloc(char, len + 2);\n\t\t    break;\n\t\t}\n\t    }\n\t    ptr = ptr->sibling;\n\t}\n    }\n    if (result != 0) {\n\tif (ptr != 0 && (result[len] = (char) ptr->ch) == 0)\n\t    *((unsigned char *) (result + len)) = 128;\n#ifdef TRACE\n\tif (len == 0 && USE_TRACEF(TRACE_MAXIMUM)) {\n\t    _tracef(\"expand_key %s %s\",\n\t\t    _nc_tracechar(CURRENT_SCREEN, (int) code),\n\t\t    _nc_visbuf(result));\n\t    _nc_unlock_global(tracef);\n\t}\n#endif\n    }\n    return result;\n}\n\n/*\n * Remove a code from the specified tree, freeing the unused nodes.  Returns\n * true if the code was found/removed.\n */\nNCURSES_EXPORT(int)\n_nc_remove_key(TRIES ** tree, unsigned code)\n{\n    T((T_CALLED(\"_nc_remove_key(%p,%d)\"), (void *) tree, code));\n\n    if (code == 0)\n\treturnCode(FALSE);\n\n    while (*tree != 0) {\n\tif (_nc_remove_key(&(*tree)->child, code)) {\n\t    returnCode(TRUE);\n\t}\n\tif ((*tree)->value == code) {\n\t    if ((*tree)->child) {\n\t\t/* don't cut the whole sub-tree */\n\t\t(*tree)->value = 0;\n\t    } else {\n\t\tTRIES *to_free = *tree;\n\t\t*tree = (*tree)->sibling;\n\t\tfree(to_free);\n\t    }\n\t    returnCode(TRUE);\n\t}\n\ttree = &(*tree)->sibling;\n    }\n    returnCode(FALSE);\n}\n\n/*\n * Remove a string from the specified tree, freeing the unused nodes.  Returns\n * true if the string was found/removed.\n */\nNCURSES_EXPORT(int)\n_nc_remove_string(TRIES ** tree, const char *string)\n{\n    T((T_CALLED(\"_nc_remove_string(%p,%s)\"), (void *) tree, _nc_visbuf(string)));\n\n    if (string == 0 || *string == 0)\n\treturnCode(FALSE);\n\n    while (*tree != 0) {\n\tif (UChar((*tree)->ch) == UChar(*string)) {\n\t    if (string[1] != 0)\n\t\treturnCode(_nc_remove_string(&(*tree)->child, string + 1));\n\t    if ((*tree)->child == 0) {\n\t\tTRIES *to_free = *tree;\n\t\t*tree = (*tree)->sibling;\n\t\tfree(to_free);\n\t\treturnCode(TRUE);\n\t    } else {\n\t\treturnCode(FALSE);\n\t    }\n\t}\n\ttree = &(*tree)->sibling;\n    }\n    returnCode(FALSE);\n}\n"]}